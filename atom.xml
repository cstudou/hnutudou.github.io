<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Tudou</title>
  
  <subtitle>study &amp; life</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-11-18T12:11:34.112Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Tudou</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>二分图</title>
    <link href="http://yoursite.com/2019/11/18/%E4%BA%8C%E5%88%86%E5%9B%BE/"/>
    <id>http://yoursite.com/2019/11/18/二分图/</id>
    <published>2019-11-18T12:09:26.964Z</published>
    <updated>2019-11-18T12:11:34.112Z</updated>
    
    <content type="html"><![CDATA[<p>简介： 用染色法判断二分图</p><a id="more"></a><h1 id="二分图"><a href="#二分图" class="headerlink" title="二分图"></a>二分图</h1><p>&emsp;&emsp;二部图又叫二分图，是图论中的一种特殊模型。设G=(V,E)是一个无向图，如果顶点V可分割为两个互不相交的子集(A,B)，并且图中的每条边（i，j）所关联的两个顶点i和j分别属于这两个不同的顶点集(i in A,j in B)，则称图G为一个二分图。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//二分图：简单来说，如果图中点可以被分为两组,图中不含奇数环 </span></span><br><span class="line"><span class="comment">//对所有的点染色，相邻两个点的颜色一定不一样 </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">200020</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,color[maxn];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; adj[maxn];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">color[u]=c;   <span class="comment">//对这一个点染色</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;adj[u].size(); i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> v=adj[u][i];</span><br><span class="line"><span class="keyword">if</span>(!color[v])       <span class="comment">//v点也没有染色 </span></span><br><span class="line">&#123; </span><br><span class="line"><span class="keyword">if</span>(!dfs(v, <span class="number">3</span>-c))<span class="keyword">return</span> <span class="literal">false</span>;     <span class="comment">//染色失败，只能染成1和2 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(color[v]==c)<span class="keyword">return</span> <span class="literal">false</span>;     <span class="comment">//一条边两个点不能是相同的颜色 </span></span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="keyword">while</span>(m--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> x,y;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;x&gt;&gt;y;</span><br><span class="line">adj[x].push_back(y);</span><br><span class="line">adj[y].push_back(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">bool</span> flag=<span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(!color[i])   <span class="comment">//如果还没有染色 </span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(!dfs(i,<span class="number">1</span>))<span class="comment">//如果有冲突 </span></span><br><span class="line">&#123;</span><br><span class="line">flag=<span class="literal">false</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(flag)<span class="built_in">cout</span>&lt;&lt;<span class="string">"Yes"</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="string">"No"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;简介： 用染色法判断二分图&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法笔记" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>I/O库</title>
    <link href="http://yoursite.com/2019/11/18/I-O%E5%BA%93/"/>
    <id>http://yoursite.com/2019/11/18/I-O库/</id>
    <published>2019-11-18T11:55:03.000Z</published>
    <updated>2019-11-18T11:55:03.834Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>文件I/O</title>
    <link href="http://yoursite.com/2019/11/17/%E6%96%87%E4%BB%B6I-O/"/>
    <id>http://yoursite.com/2019/11/17/文件I-O/</id>
    <published>2019-11-17T10:30:31.000Z</published>
    <updated>2019-11-18T08:59:51.054Z</updated>
    
    <content type="html"><![CDATA[<p>简介： APUE第三章-文件I/O</p><a id="more"></a><h1 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a>文件描述符</h1><p>对内核而言，所有打开的文件都通过文件描述符引用，当打开一个现有文件或者创建一个新文件时，内核会向进程返回文件描述符。</p><p>UNIX系统shell把文件描述符0与标准输入关联，文件描述符1与标准输出关联，文件描述符2与标准错误管理。0，1，2分别用STDIN_FILENO,STDOUT_FILENO,STDERR_FILENO表示（头文件为<code>&lt;unistd.h&gt;</code>）。</p><h1 id="函数open与openat"><a href="#函数open与openat" class="headerlink" title="函数open与openat"></a>函数open与openat</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">open</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">int</span> oflag, ...<span class="comment">/*mode_t mode*/</span>)</span></span>;</span><br><span class="line"><span class="comment">//对于open，只有新创建文件时，最后的权限位才被声明</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">openat</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">int</span> oflag, ...<span class="comment">/*mode_t mode*/</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>参数path：要打开或者创建的文件名<br>参数oflag:<br>&emsp;&emsp;O_RDONLY&emsp;&emsp;只读打开<br>&emsp;&emsp;O_WRONLY&emsp;&emsp;只写打开<br>&emsp;&emsp;O_RDWR&emsp;&emsp;读、写打开<br>&emsp;&emsp;O_EXEC&emsp;&emsp;只执行打开<br>&emsp;&emsp;O_SEARCH&emsp;&emsp;只搜索打开（应用于目录）<br>以上五个参数必须指定一个<br>&emsp;&emsp;O_APPEND&emsp;&emsp;每次写都追加到文件末尾<br>&emsp;&emsp;O_CREAT&emsp;&emsp;若文件不存在则创建，使用open时必须指定权限位<br>&emsp;&emsp;O_TRUNC&emsp;&emsp;若文件存在，而且为只写或读写成功打开，则将其长度截断为0<br>以上参数为可选<br>&emsp;&emsp;两函数返回的文件描述符一定是最小的未用描述符数值<br>&emsp;&emsp;区别：</p><ul><li>path指定绝对路径名，此时fd可被忽略，openat相当于open</li><li>path制定相对路径名，fd指出相对路径名在文件系统中的开始地址</li><li>path制定相对路径名，fd具有特殊值AT_FDCWD，此时路径名在当前工作目录中获取</li></ul><h1 id="函数creat"><a href="#函数creat" class="headerlink" title="函数creat"></a>函数creat</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">creat</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">mode_t</span> mode)</span></span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;此函数等价于</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">open(<span class="name">apth</span>, O_WRONLT | O_CREAT | OTRUNC, mode)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;creat只以只写方式打开所创建的文件</p><h1 id="函数close"><a href="#函数close" class="headerlink" title="函数close"></a>函数close</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">close</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;关闭一个打开的文件，关闭文件时还会释放加载该文件上的所有记录锁</p><h1 id="函数lseek"><a href="#函数lseek" class="headerlink" title="函数lseek"></a>函数lseek</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">off_t</span> lseek(<span class="keyword">int</span> fd, <span class="keyword">off_t</span> offset, <span class="keyword">int</span> whence);</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;每个打开文件都有一个与其关联的文件偏移量（通常为非负整数），当打开一个文件时，除非制定O_APPEND选项，复杂偏移量设置为0<br>&emsp;&emsp;offset参数：与参数whence的值有关</p><ul><li>whence是SEEK_SET，则将该文件的偏移量设置为距文件开始offset字节处</li><li>whence是SEEK_CUR,则将该文件的偏移量设置为当前值加offset，offset可正可负</li><li>whence是SEEK_END，则将该文件的偏移量值设置为文件长度加offset，offset可正可负</li></ul><p>&emsp;&emsp;若lseek成功执行，则返回新的文件偏移量，如果文件描述符指向的是一个管道、FIFO、或者网络套接字，则lseek返回-1，并将errno设置为ESPIPE。<br>&emsp;&emsp;lseek仅将文件偏移量记录在内核中，它并不引起任何I/O操作。文件偏移量可以大于当前长度，在这种情况下，对该文件的下一次写将加长该文件，并在文件中构成一个空洞。<strong>文件中的空洞并不要求在磁盘上占用存储区</strong>。当定位到超出文件尾端之后写时，对于新写的数据需要分配磁盘块，但是对于源文件尾端和新开始写位置之间的部分不需要分配磁盘块。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_MODE   (S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH) </span></span><br><span class="line"><span class="keyword">char</span> buf1[]=<span class="string">"abcdefghij"</span>; </span><br><span class="line"><span class="keyword">char</span> buf2[]=<span class="string">"ABCDEFGHIJ"</span>; </span><br><span class="line">     </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">     <span class="keyword">int</span> fd; </span><br><span class="line">     <span class="keyword">if</span>((fd=creat(<span class="string">"file.hole"</span>, FILE_MODE)) &lt; <span class="number">0</span>) </span><br><span class="line">     &#123; </span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"creat error"</span>); </span><br><span class="line">     &#125; </span><br><span class="line">     <span class="keyword">if</span>(write(fd, buf1, <span class="number">10</span>) != <span class="number">10</span>) </span><br><span class="line">     &#123; </span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"buf1 write error"</span>); </span><br><span class="line">     &#125; </span><br><span class="line">     <span class="keyword">if</span>(lseek(fd, <span class="number">16384</span>, SEEK_SET) == <span class="number">-1</span>) </span><br><span class="line">     &#123; </span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"lseek error"</span>);</span><br><span class="line">     &#125; </span><br><span class="line">     <span class="keyword">if</span>(srite(fd, buf2, <span class="number">10</span>)!=<span class="number">10</span>) </span><br><span class="line">     &#123; </span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"buf2 write error"</span>); </span><br><span class="line">     &#125; </span><br><span class="line">     <span class="built_in">exit</span>(<span class="number">0</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s2.ax1x.com/2019/11/18/M6Zqdf.png" alt=""><br>有空洞的文件占8个磁盘块</p><h1 id="函数read"><a href="#函数read" class="headerlink" title="函数read"></a>函数read</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ssize_t</span> read(<span class="keyword">int</span> fd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> nbytes);</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;如果read成功，则返回读到的字节数，如果已经到达文件的末尾，返回0；<br>&emsp;&emsp;实际读取字节数少于要求读取字节数：</p><ul><li>读普通文件时，在读到要求字节数之前已达到了文件尾端</li><li>当从终端设备读时，通常一次最多读一行</li><li>当从网络读时，网络中的缓冲机制可能造成返回值小于所需数量</li><li>当从管道或者FIFO读时，若管道包含字节数少于所需数量，那么read只返回实际可用字节数</li><li>当从某些面向记录的设备（如磁带）读时，一次最多返回一个记录</li><li>当一信号造成中断，而已经读取了部分数据量时<br>&emsp;&emsp;读操作从文件当前偏移量处开始，在成功返回之前，该偏移量将增加实际读到的字节数</li></ul><h1 id="函数write"><a href="#函数write" class="headerlink" title="函数write"></a>函数write</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="keyword">ssize_t</span> write(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> nbytes);</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;若成功，返回已写字节数；若出错，返回-1<br>&emsp;&emsp;出错的一个常见原因是磁盘已写满，或者超过了一个给定进程的文件长度限制</p><h1 id="文件共享"><a href="#文件共享" class="headerlink" title="文件共享"></a>文件共享</h1><p>&emsp;&emsp;内核使用三种数据结构表示打开文件</p><ul><li>每个进程在进程表中都有一个记录项，记录项中包含一张打开的文件描述符表，每个文件描述符占用一项。与每个文件描述符相关联的是：<br>&emsp;&emsp;1. 文件描述符标值<br>&emsp;&emsp;2. 指向一个文件表项的指针</li><li>内核为所有打开文件维持一张文件表，每个文件表项包含<br>&emsp;&emsp;1. 文件状态标值<br>&emsp;&emsp;2. 当前文件偏移量<br>&emsp;&emsp;3. 指向该文件v节点表项的指针</li><li>每个打开文件都有一个v（v-node）节点结构，v节点包含了文件类型和对此文件进行各种操作函数的指针。对于大多数文件，v节点还包含了该文件的i节点（索引节点），i节点包含了文件的所有者、文件长度、指向文件实际数据块在磁盘上所在的位置的指针等。<br><img src="https://s2.ax1x.com/2019/11/18/M6lTVs.png" alt=""></li></ul><p>&emsp;&emsp;若两个独立进程各自打开同意文件，则有如下关系：<br><img src="https://s2.ax1x.com/2019/11/18/M63zNR.png" alt=""></p><ul><li>在完成每个write后，在文件表项中的当前文件偏移量处增加所写入的字节数</li><li>如果用O_APPEND标志打开一个文件，则相应的标值也被设置到文件表项的文件状态标志中</li><li>若一个文件用lseek定位到文件当前的尾端，则文件表项中的当前文件偏移量首先会被设置为i节点表象中的文件长度。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;简介： APUE第三章-文件I/O&lt;/p&gt;
    
    </summary>
    
    
      <category term="APUE" scheme="http://yoursite.com/categories/APUE/"/>
    
    
      <category term="Linux C/C++" scheme="http://yoursite.com/tags/Linux-C-C/"/>
    
      <category term="APUE" scheme="http://yoursite.com/tags/APUE/"/>
    
  </entry>
  
  <entry>
    <title>线程安全</title>
    <link href="http://yoursite.com/2019/11/16/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/"/>
    <id>http://yoursite.com/2019/11/16/线程安全/</id>
    <published>2019-11-16T04:28:19.000Z</published>
    <updated>2019-11-16T05:10:44.425Z</updated>
    
    <content type="html"><![CDATA[<p>简介： 并发问题-线程安全</p><a id="more"></a><p>#线程安全：<br>&emsp;&emsp;线程安全：当一个函数被多个并发线程反复调用时，它会一直产生正确的结果，则这个函数是线程安全的。<br>&emsp;&emsp;不安全函数类：</p><ul><li>不保护共享变量的函数</li><li>保持跨越多个调用的状态的函数</li><li>返回静态变量的指针的函数</li><li>调用线程不安全函数的函数</li></ul><h1 id="可重入函数"><a href="#可重入函数" class="headerlink" title="可重入函数"></a>可重入函数</h1><p>&emsp;&emsp;可重入函数性质：当它们被多个线程调用时，不会引用任何共享数据。<br><img src="https://s2.ax1x.com/2019/11/16/MwqPiR.jpg" alt=""><br>&emsp;&emsp;显式可重入：所有数据引用都是本地的自动栈变量（没有引用静态或者全局变量）<br>&emsp;&emsp;隐式可重入：显式可重入函数中有一些参数是引用传递的，但其不是指向共享变量的指针<br>&emsp;&emsp;标准 C 库中的函数都是线程安全的（如 malloc, free, printf, scanf），大多数 Unix 的系统调用也都是线程安全的</p><h1 id="竞争"><a href="#竞争" class="headerlink" title="竞争"></a>竞争</h1><p>&emsp;&emsp;当一个程序的正确性依赖于一个线程要在另一个线程到达y点之前到达它的控制流中的x点时，就会发生竞争。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 4</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thread</span><span class="params">(<span class="keyword">void</span> *vargp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> mytid=*((<span class="keyword">int</span> *)vargp);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"hello from thread %d\n"</span>, mytid);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">pthread_t</span> tid[N]; </span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;N; i++)</span><br><span class="line">&#123;</span><br><span class="line">pthread_create(&amp;tid[i], <span class="literal">NULL</span>, thread, &amp;i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;N; i++)</span><br><span class="line">&#123;</span><br><span class="line">pthread_join(tid[i], <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s2.ax1x.com/2019/11/16/MwONPs.png" alt=""><br>&emsp;&emsp;竞争出现在第14行和第6行，如果在for循环之前就输出了i，则是正确的结果，如若不然，就会失败。<br>&emsp;&emsp;改进后的函数，给每个i都开辟一个单独的存储空间</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span><span class="comment">; i&lt;N; i++)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">ptr</span>=(<span class="built_in">int</span> *)malloc(sizeof(<span class="built_in">int</span>))<span class="comment">;</span></span><br><span class="line">*<span class="built_in">ptr</span>=i<span class="comment">;</span></span><br><span class="line">pthread_create(&amp;tid[i], <span class="literal">NULL</span>, thread, <span class="built_in">ptr</span>)<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h1><p>&emsp;&emsp;指的是一组线程被阻塞了，等待一个永远不会为真的条件，<br>&emsp;&emsp;互斥锁加锁规则：给定所有互斥操作的一个全序，如果每个线程都是以一种顺序获得互斥锁并且以相反的顺序释放，则这个程序是无死锁的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;简介： 并发问题-线程安全&lt;/p&gt;
    
    </summary>
    
    
      <category term="csapp" scheme="http://yoursite.com/categories/csapp/"/>
    
    
      <category term="Linux C/C++" scheme="http://yoursite.com/tags/Linux-C-C/"/>
    
      <category term="网络编程" scheme="http://yoursite.com/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>拓扑排序</title>
    <link href="http://yoursite.com/2019/11/15/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/"/>
    <id>http://yoursite.com/2019/11/15/拓扑排序/</id>
    <published>2019-11-15T13:11:01.000Z</published>
    <updated>2019-11-15T13:26:09.351Z</updated>
    
    <content type="html"><![CDATA[<p>简介： 拓扑排序算法</p><a id="more"></a><p>&emsp;&emsp;可以求出拓扑序列</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">100010</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; adj[maxn],ans;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> indegree[maxn],n,m;  <span class="comment">//indegree是用来存每个节点的入度 </span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">topologicalSort</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> num=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(indegree[i]==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">q.push(i);</span><br><span class="line"><span class="comment">//cout&lt;&lt;i&lt;&lt;'.';</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(!q.empty())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> u=q.front();</span><br><span class="line">q.pop();</span><br><span class="line"></span><br><span class="line">ans.push_back(u);  <span class="comment">//把该节点加入数组，，其已经是拓扑序列中的一员了 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;adj[u].size(); i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> v=adj[u][i];</span><br><span class="line">indegree[v]--;       <span class="comment">//入度减1</span></span><br><span class="line"><span class="keyword">if</span>(indegree[v]==<span class="number">0</span>)q.push(v); </span><br><span class="line">&#125;</span><br><span class="line">adj[u].clear();  <span class="comment">//清空从这条边出去的所有边 </span></span><br><span class="line">num++;     <span class="comment">//加入拓扑序列的顶点数加1 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(num==n)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">else</span><span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="keyword">while</span>(m--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> x,y;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;x&gt;&gt;y;</span><br><span class="line">adj[x].push_back(y);</span><br><span class="line">indegree[y]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">bool</span> flag = topologicalSort();</span><br><span class="line"><span class="keyword">if</span>(flag)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> i : ans)<span class="built_in">cout</span>&lt;&lt;i&lt;&lt;<span class="string">' '</span>;</span><br><span class="line"><span class="keyword">else</span><span class="built_in">cout</span>&lt;&lt;<span class="number">-1</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;简介： 拓扑排序算法&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法笔记" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Trie</title>
    <link href="http://yoursite.com/2019/11/14/Trie/"/>
    <id>http://yoursite.com/2019/11/14/Trie/</id>
    <published>2019-11-14T13:02:30.161Z</published>
    <updated>2019-11-14T13:16:39.511Z</updated>
    
    <content type="html"><![CDATA[<p>简介： 字典树</p><a id="more"></a><p>&emsp;&emsp;Trie字典树主要用于存储字符串，Trie 的每个 Node 保存一个字符。用链表来描述的话，就是一个字符串就是一个链表。每个Node都保存了它的所有子节点。例如我们往字典树中插入see、pain、paint三个单词:</p><p><img src="https://s2.ax1x.com/2019/11/14/MNHZkV.png" alt=""></p><h1 id="构建函数"><a href="#构建函数" class="headerlink" title="构建函数"></a>构建函数</h1><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> insert(<span class="keyword">char</span> <span class="keyword">str</span>[])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> p=<span class="number">0</span>;          <span class="comment">//第p个节点 ，0为根节点又为空节点 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; <span class="keyword">str</span>[i]; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> u=<span class="keyword">str</span>[i]-<span class="string">'a'</span>;</span><br><span class="line"><span class="keyword">if</span>(!son[p][u])son[p][u]=++idx;   </span><br><span class="line">p=son[p][u];         <span class="comment">//下一个字母 ,无论如何都会往下查找即执行这一句 </span></span><br><span class="line">&#125;</span><br><span class="line">cnt[p]++;       <span class="comment">//以p结尾的单词数量多了一个 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="查询函数"><a href="#查询函数" class="headerlink" title="查询函数"></a>查询函数</h1><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> query(<span class="keyword">char</span> <span class="keyword">str</span>[])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> p=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; <span class="keyword">str</span>[i]; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> u=<span class="keyword">str</span>[i]-<span class="string">'a'</span>;</span><br><span class="line"><span class="keyword">if</span>(!son[p][u])<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">p=son[p][u];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> cnt[p];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;简介： 字典树&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法笔记" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>echo-预线程化</title>
    <link href="http://yoursite.com/2019/11/10/echo-%E9%A2%84%E7%BA%BF%E7%A8%8B%E5%8C%96/"/>
    <id>http://yoursite.com/2019/11/10/echo-预线程化/</id>
    <published>2019-11-10T10:38:40.000Z</published>
    <updated>2019-11-10T10:55:02.387Z</updated>
    
    <content type="html"><![CDATA[<p>简介： 基于预线程化的echo服务器</p><a id="more"></a><h1 id="main函数"><a href="#main函数" class="headerlink" title="main函数"></a>main函数</h1><p>&emsp;&emsp;创建一系列对等的工作线程，在工作线程中处理客户端传来的输入。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> main(<span class="built_in">int</span> argc, <span class="built_in">char</span> **argv)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">int</span> i,listenfd,connfd;</span><br><span class="line">socklen_t clientlen;</span><br><span class="line"><span class="keyword">struct</span> sockaddr_storage clientaddr;</span><br><span class="line">pthread_t tid;</span><br><span class="line"><span class="keyword">if</span>(argc != <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line">fprintf(stderr, <span class="string">"usage: %s &lt;port&gt;\n"</span>, argv<span class="literal">[<span class="number">0</span>]</span>);</span><br><span class="line">exit(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">listenfd=<span class="keyword">open</span><span class="constructor">_listenfd(<span class="params">argv</span>[1])</span>;</span><br><span class="line">sbuf<span class="constructor">_init(&amp;<span class="params">sbuf</span>, SBUFSIZE)</span>;</span><br><span class="line"><span class="comment">//工作线程 </span></span><br><span class="line">for(i=<span class="number">0</span>; i&lt;NTHREADS; i++)</span><br><span class="line">&#123;</span><br><span class="line">pthread<span class="constructor">_create(&amp;<span class="params">tid</span>, NULL, <span class="params">thread</span>, NULL)</span>;  <span class="comment">//创建对等线程 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">clientlen=sizeof(<span class="keyword">struct</span> sockaddr_storage);</span><br><span class="line">connfd=accept(listenfd, (<span class="keyword">struct</span> sockaddr *)&amp;clientaddr, &amp;clientlen);</span><br><span class="line">sbuf<span class="constructor">_insert(&amp;<span class="params">sbuf</span>, <span class="params">connfd</span>)</span>;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="thread函数"><a href="#thread函数" class="headerlink" title="thread函数"></a>thread函数</h1><p>&emsp;&emsp;首先将线程分离，以便线程结束时系统回收线程的资源，然后读取客户端的输入。</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">void</span> *<span class="function"><span class="title">thread</span>(<span class="variable">void</span> *<span class="variable">vargp</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="title">pthread_detach</span>(<span class="title">pthread_self</span>());</span></span><br><span class="line"><span class="function"><span class="title">while</span>(<span class="number">1</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="variable">int</span> <span class="variable">connfd</span>=<span class="function"><span class="title">sbuf_remove</span>(&amp;<span class="variable">sbuf</span>);   <span class="comment">//取出连接符</span></span></span><br><span class="line"><span class="function"><span class="title">echo_cnt</span>(<span class="variable">connfd</span>);</span></span><br><span class="line"><span class="function"><span class="title">close</span>(<span class="variable">connfd</span>); </span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure><h1 id="echo-cnt函数"><a href="#echo-cnt函数" class="headerlink" title="echo_cnt函数"></a>echo_cnt函数</h1><p>&emsp;&emsp;调用echo_cnt函数时通过pthread_once函数来初始化线程，读取输入时，对统计总字符的变量加锁以保证其互斥访问。</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">static void init_echo_cnt(void)</span><br><span class="line">&#123;</span><br><span class="line">sem_init(&amp;mutex, <span class="number">0</span>, <span class="number">1</span>)<span class="comment">;</span></span><br><span class="line"><span class="keyword">byte_cnt=0;</span></span><br><span class="line"><span class="keyword">&#125;</span></span><br><span class="line"><span class="keyword">void </span>echo_cnt(int connfd)</span><br><span class="line">&#123;</span><br><span class="line">int n<span class="comment">;</span></span><br><span class="line">char <span class="keyword">buf[MAXNLINE];</span></span><br><span class="line"><span class="keyword"></span>rio_t rio<span class="comment">;</span></span><br><span class="line">rio_readinitb(&amp;rio, connfd)<span class="comment">;</span></span><br><span class="line">static pthread_once_t once = PTHREAD_ONCE_INIT<span class="comment">;</span></span><br><span class="line">pthread_once(&amp;once, init_echo_cnt)<span class="comment">; //即使是在多线程程序中，此函数也只调用一次，由once参数控制 </span></span><br><span class="line">while((n=rio_readlineb(&amp;rio, <span class="keyword">buf, </span>MAXNLINE)) != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">P(&amp;mutex)<span class="comment">;</span></span><br><span class="line"><span class="keyword">byte_cnt+=n;</span></span><br><span class="line"><span class="keyword"></span>printf(<span class="string">"server received %d (%d total) bytes on fd %d\n"</span>, n, <span class="keyword">byte_cnt, </span>connfd)<span class="comment">;</span></span><br><span class="line">V(&amp;mutex)<span class="comment">;</span></span><br><span class="line">rio_writen(connfd, <span class="keyword">buf, </span>n)<span class="comment">;</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="sbuf相关函数"><a href="#sbuf相关函数" class="headerlink" title="sbuf相关函数"></a>sbuf相关函数</h1><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">typedef <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">int</span> *buf;</span><br><span class="line"><span class="built_in">int</span> n;</span><br><span class="line"><span class="built_in">int</span> front,rear;</span><br><span class="line">sem_t mutex;</span><br><span class="line">sem_t items;</span><br><span class="line">sem_t slots;</span><br><span class="line">&#125;sbuf_t;</span><br><span class="line"></span><br><span class="line">void sbuf<span class="constructor">_init(<span class="params">sbuf_t</span> <span class="operator">*</span><span class="params">sp</span>, <span class="params">int</span> <span class="params">x</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">sp-&gt;buf=(<span class="built_in">int</span> *)calloc(x, sizeof(<span class="built_in">int</span>));</span><br><span class="line">sp-&gt;n=x;</span><br><span class="line">sp-&gt;front=sp-&gt;rear=<span class="number">0</span>;</span><br><span class="line">sem<span class="constructor">_init(&amp;<span class="params">sp</span>-&gt;<span class="params">mutex</span>, 0, 1)</span>;</span><br><span class="line">sem<span class="constructor">_init(&amp;<span class="params">sp</span>-&gt;<span class="params">slots</span>, 0, <span class="params">x</span>)</span>;</span><br><span class="line">sem<span class="constructor">_init(&amp;<span class="params">sp</span>-&gt;<span class="params">items</span>, 0, 0)</span>;</span><br><span class="line">&#125;</span><br><span class="line">void sbuf<span class="constructor">_insert(<span class="params">sbuf_t</span> <span class="operator">*</span><span class="params">sp</span>, <span class="params">int</span> <span class="params">item</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="constructor">P(&amp;<span class="params">sp</span>-&gt;<span class="params">slots</span>)</span>;</span><br><span class="line"><span class="constructor">P(&amp;<span class="params">sp</span>-&gt;<span class="params">mutex</span>)</span>;</span><br><span class="line">sp-&gt;buf<span class="literal">[(<span class="operator">++</span><span class="identifier">sp</span>-&gt;<span class="identifier">rear</span>) % (<span class="identifier">sp</span>-&gt;<span class="identifier">n</span>)]</span>=item;</span><br><span class="line"><span class="constructor">V(&amp;<span class="params">sp</span>-&gt;<span class="params">items</span>)</span>;</span><br><span class="line"><span class="constructor">V(&amp;<span class="params">sp</span>-&gt;<span class="params">mutex</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">int</span> sbuf<span class="constructor">_remove(<span class="params">sbuf_t</span> <span class="operator">*</span><span class="params">sp</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">int</span> item;</span><br><span class="line"><span class="constructor">P(&amp;<span class="params">sp</span>-&gt;<span class="params">items</span>)</span>;      <span class="comment">//取出来以后可用项的数目减一 </span></span><br><span class="line"><span class="constructor">P(&amp;<span class="params">sp</span>-&gt;<span class="params">mutex</span>)</span>;          <span class="comment">//加互斥锁 </span></span><br><span class="line">item=sp-&gt;buf<span class="literal">[(<span class="operator">++</span><span class="identifier">sp</span>-&gt;<span class="identifier">front</span>)%(<span class="identifier">sp</span>-&gt;<span class="identifier">n</span>)]</span>;</span><br><span class="line"><span class="constructor">V(&amp;<span class="params">sp</span>-&gt;<span class="params">mutex</span>)</span>;         <span class="comment">//解开互斥锁 </span></span><br><span class="line"><span class="constructor">V(&amp;<span class="params">sp</span>-&gt;<span class="params">slots</span>)</span>;        <span class="comment">//取出来，空槽位加一</span></span><br><span class="line">return item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;简介： 基于预线程化的echo服务器&lt;/p&gt;
    
    </summary>
    
    
      <category term="csapp" scheme="http://yoursite.com/categories/csapp/"/>
    
    
      <category term="Linux C/C++" scheme="http://yoursite.com/tags/Linux-C-C/"/>
    
      <category term="网络编程" scheme="http://yoursite.com/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>求组合数</title>
    <link href="http://yoursite.com/2019/11/08/%E6%B1%82%E7%BB%84%E5%90%88%E6%95%B0/"/>
    <id>http://yoursite.com/2019/11/08/求组合数/</id>
    <published>2019-11-08T10:44:38.000Z</published>
    <updated>2019-11-08T12:24:43.426Z</updated>
    
    <content type="html"><![CDATA[<p>简介： 求组合数的几种方法</p><a id="more"></a><h1 id="递推公式"><a href="#递推公式" class="headerlink" title="递推公式"></a>递推公式</h1><p>&emsp;&emsp;组合数(n中取m)的递推公式C(n,m)=C(n-1,m-1)+C(n-1,m)</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">void</span> unit()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>; i&lt;N; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> j=<span class="number">0</span>; j&lt;=i; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="number">0</span>==j)    s[i][j]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> s[i][j]=(s[i<span class="number">-1</span>][j]+s[i<span class="number">-1</span>][j<span class="number">-1</span>])%maxn;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="comment">//递推公式</span></span><br></pre></td></tr></table></figure><h1 id="逆元–求出阶乘"><a href="#逆元–求出阶乘" class="headerlink" title="逆元–求出阶乘"></a>逆元–求出阶乘</h1><ul><li>扩展欧几里得</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> n,a,b;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> fa[<span class="number">100010</span>],fb[<span class="number">100010</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exgcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> &amp;x, <span class="keyword">int</span> &amp;y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(b==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">x=<span class="number">1</span>,y=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">exgcd(b,a%b,y,x);</span><br><span class="line">y-=(a/b)*x%maxn;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">fa[<span class="number">0</span>]=fb[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;<span class="number">100010</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> x=<span class="number">0</span>,y=<span class="number">0</span>;</span><br><span class="line">fa[i]=fa[i<span class="number">-1</span>]*i%maxn;</span><br><span class="line">exgcd(i, maxn, x, y);</span><br><span class="line">fb[i]=fb[i<span class="number">-1</span>]*(x%maxn+maxn)%maxn; <span class="comment">//此时可能逆元为负</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(n--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;fa[a]*fb[a-b]%maxn*fb[b]%maxn&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>费马小定理</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> n,a,b;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> fa[<span class="number">100010</span>],fb[<span class="number">100010</span>];</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">fuck</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a, <span class="keyword">long</span> <span class="keyword">long</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> res=<span class="number">1</span>,t=a;;</span><br><span class="line">    <span class="keyword">while</span>(b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>) res=res*t%maxn;</span><br><span class="line">        t=t*t%maxn;</span><br><span class="line">        b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exgcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> &amp;x, <span class="keyword">int</span> &amp;y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">fa[<span class="number">0</span>]=fb[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;<span class="number">100010</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">fa[i]=fa[i<span class="number">-1</span>]*i%maxn;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> x=fuck(i, maxn<span class="number">-2</span>);</span><br><span class="line">fb[i]=fb[i<span class="number">-1</span>]*(x%maxn+maxn)%maxn;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(n--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;fa[a]*fb[a-b]%maxn*fb[b]%maxn&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="累乘法"><a href="#累乘法" class="headerlink" title="累乘法"></a>累乘法</h1><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">LL C(LL a, LL b, LL p)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(b&gt;a)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">LL res=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(int <span class="built_in">i</span>=<span class="number">1</span>, <span class="built_in">j</span>=a; <span class="built_in">i</span>&lt;=b; <span class="built_in">i</span>++,<span class="built_in">j</span>--)</span><br><span class="line">&#123;</span><br><span class="line">res=res*<span class="built_in">j</span><span class="comment">%p;   //a - a-b+1</span></span><br><span class="line">res=res*qmi(<span class="built_in">i</span>,p<span class="number">-2</span>,p)<span class="comment">%p;  // b!  (快速幂求逆元)</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;简介： 求组合数的几种方法&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法笔记" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>数论知识</title>
    <link href="http://yoursite.com/2019/11/08/%E6%95%B0%E8%AE%BA%E7%9F%A5%E8%AF%86/"/>
    <id>http://yoursite.com/2019/11/08/数论知识/</id>
    <published>2019-11-08T04:45:36.000Z</published>
    <updated>2019-11-15T12:29:45.600Z</updated>
    
    <content type="html"><![CDATA[<p>简介： 一些常见的数论问题</p><a id="more"></a><h1 id="线性筛法求素数"><a href="#线性筛法求素数" class="headerlink" title="线性筛法求素数"></a>线性筛法求素数</h1><p>&emsp;&emsp;每次都用其最小质因子筛，如果不是素数，就把它筛去</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">线性筛法求素数 </span><br><span class="line"><span class="built_in">int</span> primes[N], cnt;     <span class="comment">// primes[]存储所有素数</span></span><br><span class="line"><span class="built_in">bool</span> st[N];         <span class="comment">// st[x]存储x是否被筛掉</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">void</span> get_primes(<span class="built_in">int</span> n)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">2</span>; i &lt;= n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!st[i]) primes[cnt ++ ] = i;   <span class="comment">//当前i没有被筛过 </span></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> j = <span class="number">0</span>; primes[j] &lt;= n / i; j ++ )   <span class="comment">//枚举所有质数 </span></span><br><span class="line">        &#123;</span><br><span class="line">            st[primes[j] * i] = <span class="literal">true</span>;   <span class="comment">//用最小质因子筛，等于true就不会加入队列 </span></span><br><span class="line">            <span class="keyword">if</span> (i % primes[j] == <span class="number">0</span>) <span class="keyword">break</span>;  <span class="comment">//primers[j]是i的最小质因子，退出</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="欧几里得算法-求最大公约数"><a href="#欧几里得算法-求最大公约数" class="headerlink" title="欧几里得算法-求最大公约数"></a>欧几里得算法-求最大公约数</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">欧几里得算法 </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b ? gcd(b, a % b) : a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="欧拉函数"><a href="#欧拉函数" class="headerlink" title="欧拉函数"></a>欧拉函数</h1><p>&emsp;&emsp;欧拉函数表示1-N中与N互质的数的个数</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">结论： P(N)表示 <span class="number">1</span> ~ N 中与 N互质的数的个数</span><br><span class="line">N=p1^a1×p2^a2×……×pn^an   <span class="comment">//分解质因数 </span></span><br><span class="line">P(N)=N(<span class="number">1</span><span class="number">-1</span>/p1)(<span class="number">1</span><span class="number">-1</span>/p2)……(<span class="number">1</span><span class="number">-1</span>/pn)</span><br></pre></td></tr></table></figure><p>主要代码</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> phi(<span class="built_in">int</span> x)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> res = x;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">2</span>; i &lt;= x / i; i ++ )</span><br><span class="line">        <span class="keyword">if</span> (x % i == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            res = res / i * (i - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">while</span> (x % i == <span class="number">0</span>) x /= i;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">if</span> (x &gt; <span class="number">1</span>) res = res / x * (x - <span class="number">1</span>);   <span class="comment">//最后x如果不等于1，说明现在它是原来x的一个质因数 </span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="线性筛法求欧拉函数"><a href="#线性筛法求欧拉函数" class="headerlink" title="线性筛法求欧拉函数"></a>线性筛法求欧拉函数</h1><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> primes[N], cnt;     <span class="comment">// primes[]存储所有素数</span></span><br><span class="line"><span class="built_in">int</span> euler[N];           <span class="comment">// 存储每个数的欧拉函数</span></span><br><span class="line"><span class="built_in">bool</span> st[N];         <span class="comment">// st[x]存储x是否被筛掉</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">void</span> get_eulers(<span class="built_in">int</span> n)</span><br><span class="line">&#123;</span><br><span class="line">    euler[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">2</span>; i &lt;= n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!st[i])</span><br><span class="line">        &#123;</span><br><span class="line">            primes[cnt ++ ] = i;</span><br><span class="line">            euler[i] = i - <span class="number">1</span>;   <span class="comment">//一个数是质数，其欧拉函数值为i-1 ，因为前面i-1个数都与他互质 </span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> j = <span class="number">0</span>; primes[j] &lt;= n / i; j ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">int</span> t = primes[j] * i;</span><br><span class="line">            st[t] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % primes[j] == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                euler[t] = euler[i] * primes[j];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            euler[t] = euler[i] * (primes[j] - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="费马小定理"><a href="#费马小定理" class="headerlink" title="费马小定理"></a>费马小定理</h1><p>&emsp;&emsp;马小定理(Fermat’s little theorem)是数论中的一个重要定理，在1636年提出。如果p是一个质数，而整数a不是p的倍数，则有<code>a^（p-1）≡1（mod p）</code></p><h1 id="扩展的欧几里得算法"><a href="#扩展的欧几里得算法" class="headerlink" title="扩展的欧几里得算法"></a>扩展的欧几里得算法</h1><p>&emsp;&emsp;如果a、b是整数，那么一定存在整数x、y使得ax+by=gcd(a,b)<br><img src="https://s2.ax1x.com/2019/11/08/MZYagP.jpg" alt=""></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 求x, y，使得ax + by = gcd(a, b)</span></span><br><span class="line"><span class="built_in">int</span> exgcd(<span class="built_in">int</span> a, <span class="built_in">int</span> b, <span class="built_in">int</span> &amp;x, <span class="built_in">int</span> &amp;y)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!b)</span><br><span class="line">    &#123;</span><br><span class="line">        x = <span class="number">1</span>; y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">int</span> d = exgcd(b, a % b, y, x);  <span class="comment">//倒过来写 </span></span><br><span class="line">    y -= (a/b) * x;</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">exgcd(b,a%b,x,y);</span></span><br><span class="line"><span class="comment">    int temp=x;</span></span><br><span class="line"><span class="comment">    x=y;</span></span><br><span class="line"><span class="comment">    y=temp-(a/b)*y;</span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="逆元"><a href="#逆元" class="headerlink" title="逆元"></a>逆元</h1><p>&emsp;&emsp;若a*x≡1(mod b),且a与b互质，我们定义x是a的逆元，记为a^(-1)，所以也可以说x是a在mod b意义下的倒数</p><h2 id="扩展的欧几里得算法求"><a href="#扩展的欧几里得算法求" class="headerlink" title="扩展的欧几里得算法求"></a>扩展的欧几里得算法求</h2><figure class="highlight gml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void exgcd(LL a, LL b, LL &amp;<span class="symbol">x</span>, LL &amp;<span class="symbol">y</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keywords">if</span>(b==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="symbol">x</span>=<span class="number">1</span>;<span class="symbol">y</span>=<span class="number">0</span>;</span><br><span class="line"><span class="keywords">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line">exgcd(b,a%b,<span class="symbol">x</span>,<span class="symbol">y</span>);</span><br><span class="line">int temp=<span class="symbol">x</span>;</span><br><span class="line"><span class="symbol">x</span>=<span class="symbol">y</span>%<span class="keywords">mod</span>;</span><br><span class="line"><span class="symbol">y</span>=(temp-(a/b)*<span class="symbol">y</span>)%<span class="keywords">mod</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="费马小定理求"><a href="#费马小定理求" class="headerlink" title="费马小定理求"></a>费马小定理求</h2><p>&emsp;&emsp;用快速幂求p的mod-2次方即为逆元</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">fuck</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a, <span class="keyword">long</span> <span class="keyword">long</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> res=<span class="number">1</span>,t=a;;</span><br><span class="line">    <span class="keyword">while</span>(b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>) res=res*t%maxn;</span><br><span class="line">        t=t*t%maxn;</span><br><span class="line">        b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;简介： 一些常见的数论问题&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法笔记" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>哈希表</title>
    <link href="http://yoursite.com/2019/11/07/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    <id>http://yoursite.com/2019/11/07/哈希表/</id>
    <published>2019-11-07T13:13:14.213Z</published>
    <updated>2019-11-08T04:43:44.165Z</updated>
    
    <content type="html"><![CDATA[<p>简介： 如何建立哈希表 &amp; 如何解决冲突</p><a id="more"></a><p>&emsp;&emsp;哈希表：是根据关键码值(Key value)而直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表。</p><h1 id="拉链法"><a href="#拉链法" class="headerlink" title="拉链法"></a>拉链法</h1><p>&emsp;&emsp;把所有对maxn取模相等的数存在一起</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//stl</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; vi(<span class="number">100010</span>);   <span class="comment">//定义100010个空间，值不确定</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> x)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> k=(x%maxn+maxn)%maxn;      <span class="comment">//如 10%3=-1 </span></span><br><span class="line">vi[k].push_back(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//数组模拟</span></span><br><span class="line"><span class="keyword">int</span> ans[maxn],e[maxn],ne[maxn],idx;</span><br><span class="line"><span class="keyword">int</span> n,x;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> x)</span>   <span class="comment">//头插法</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> k=(x%maxn+maxn)%maxn;      <span class="comment">//如 10%3=-1 </span></span><br><span class="line">e[idx]=x;</span><br><span class="line">ne[idx]=ans[k];</span><br><span class="line">ans[k]=idx++;            <span class="comment">//ans[k]为head </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> k=(x%maxn + maxn) % maxn;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=ans[k]; i!=<span class="number">-1</span>; i=ne[i])  <span class="comment">//从前往后找next</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(e[i]==x)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//需要在main中//fill(ans, ans+maxn, -1);    //初始化为-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">string</span> s;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">fill(ans, ans+maxn, <span class="number">-1</span>);        <span class="comment">//初始化为-1 </span></span><br><span class="line"><span class="keyword">while</span>(n--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;s&gt;&gt;x;</span><br><span class="line"><span class="keyword">if</span>(s==<span class="string">"I"</span>)</span><br><span class="line">&#123;</span><br><span class="line">insert(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(find(x))<span class="built_in">cout</span>&lt;&lt;<span class="string">"Yes"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">else</span><span class="built_in">cout</span>&lt;&lt;<span class="string">"No"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="开放寻址法"><a href="#开放寻址法" class="headerlink" title="开放寻址法"></a>开放寻址法</h1><p>&emsp;&emsp;不断向后找坑位，找到就占住</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">200010</span>,N=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> ans[maxn],e[maxn],ne[maxn],idx;</span><br><span class="line"><span class="keyword">int</span> n,x;</span><br></pre></td></tr></table></figure><p>核心代码：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> find(<span class="built_in">int</span> x)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">int</span> k=(x%maxn + maxn) % maxn;</span><br><span class="line"><span class="keyword">while</span>(ans[k]!=N &amp;&amp; ans[k]!=x)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//找下一个坑</span></span><br><span class="line">k++;</span><br><span class="line"><span class="keyword">if</span>(k==maxn)k=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> x;       <span class="comment">//若没插入，则返回插入位置</span></span><br><span class="line">                <span class="comment">//若插入了，返回数所在的位置 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">string</span> s;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line"><span class="comment">//fill(ans, ans+maxn, -1);        //初始化为-1 </span></span><br><span class="line"><span class="built_in">memset</span>(ans,<span class="number">0x3f</span>,<span class="keyword">sizeof</span>(ans)); <span class="comment">//按字节 </span></span><br><span class="line"><span class="keyword">while</span>(n--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;s&gt;&gt;x;</span><br><span class="line"><span class="keyword">if</span>(s==<span class="string">"I"</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> k=find(x);</span><br><span class="line">ans[k]=x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> k=find(x);</span><br><span class="line"><span class="keyword">if</span>(ans[k]!=null)<span class="built_in">cout</span>&lt;&lt;<span class="string">"Yes"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">else</span><span class="built_in">cout</span>&lt;&lt;<span class="string">"No"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;简介： 如何建立哈希表 &amp;amp; 如何解决冲突&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法笔记" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>并查集</title>
    <link href="http://yoursite.com/2019/11/07/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    <id>http://yoursite.com/2019/11/07/并查集/</id>
    <published>2019-11-07T12:16:09.000Z</published>
    <updated>2019-11-07T12:44:39.204Z</updated>
    
    <content type="html"><![CDATA[<p>简介： 并查集算法</p><a id="more"></a><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">100010</span>;</span><br><span class="line"><span class="keyword">int</span> father[maxn];</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findfather</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//路径压缩 </span></span><br><span class="line"><span class="keyword">if</span>(x!=father[x])father[x]=findfather(father[x]);     <span class="comment">//如果找到根节点，则返回根节点编号x </span></span><br><span class="line"><span class="keyword">return</span> father[x];  <span class="comment">//否则，递归判断x的父节点是否是根节点 ,不能写成x，因为递归退回来的时候x仍然是1，2，3，4，5，。。。。。 并且不能写else return </span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">int a=x;</span></span><br><span class="line"><span class="comment">//寻找根节点 </span></span><br><span class="line"><span class="comment">while(x!=father[x])x=father[x];</span></span><br><span class="line"><span class="comment">//此时x为根节点，要把路径上所有节点的father改为x</span></span><br><span class="line"><span class="comment">while(a!=father[a])</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">int z=a;</span></span><br><span class="line"><span class="comment">a=father[a];</span></span><br><span class="line"><span class="comment">father[z]=x;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">return x;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">&#123;</span><br><span class="line">father[i]=i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(m--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">char</span> op[<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> a,b;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;op&gt;&gt;a&gt;&gt;b;</span><br><span class="line"><span class="keyword">if</span>(op[<span class="number">0</span>]==<span class="string">'M'</span>)father[findfather(a)]=findfather(b);          <span class="comment">//a的父亲节点是b </span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(findfather(a)==findfather(b))<span class="built_in">cout</span>&lt;&lt;<span class="string">"YES"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">else</span><span class="built_in">cout</span>&lt;&lt;<span class="string">"NO"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"> &#125; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过路径压缩，能快速把节点的father全部设为其祖先</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;简介： 并查集算法&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法笔记" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>最小生成树</title>
    <link href="http://yoursite.com/2019/11/07/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/"/>
    <id>http://yoursite.com/2019/11/07/最小生成树/</id>
    <published>2019-11-07T11:33:52.000Z</published>
    <updated>2019-11-07T12:44:44.068Z</updated>
    
    <content type="html"><![CDATA[<p>简介： prim &amp; krusakl</p><a id="more"></a><h1 id="prim算法"><a href="#prim算法" class="headerlink" title="prim算法"></a>prim算法</h1><p>&emsp;&emsp;prim算法基于贪心，与Dijkstra算法类似，其时间复杂度为O(nlogn)，适合于稠密图。过程可以形象的表示为让一颗小树慢慢长大。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//------邻接矩阵---</span></span><br><span class="line"><span class="comment">//在main函数中要将G初始化为INF </span></span><br><span class="line"><span class="built_in">int</span> n,G[maxn][maxn],dis[maxn];       <span class="comment">//顶点与集合s的最短距离</span></span><br><span class="line"><span class="built_in">bool</span> vis[maxn];</span><br><span class="line"><span class="built_in">int</span> prim()</span><br><span class="line">&#123;</span><br><span class="line">fill(dis, dis+manx, INF);</span><br><span class="line">dis[<span class="number">1</span>]=<span class="number">0</span>         <span class="comment">//表示与集合s的最小距离 </span></span><br><span class="line"><span class="built_in">int</span> ans=<span class="number">0</span>;                <span class="comment">//存储最小生成树边权之和</span></span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">int</span> u=<span class="number">-1</span>,mi=INF;</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">int</span> j=<span class="number">0</span>; j&lt;n; j++)  <span class="comment">//找到未访问节点中dis[]最小的 </span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(vis[j]==<span class="literal">false</span> &amp;&amp; dis[j]&lt;mi)</span><br><span class="line">&#123;</span><br><span class="line">u=j,mi=dis[j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(u==<span class="number">-1</span>)<span class="keyword">return</span> <span class="number">-1</span>;          <span class="comment">//找不到小于INF的d[u]，说明剩下的点与集合s不连通</span></span><br><span class="line">vis[u]=<span class="literal">true</span>;</span><br><span class="line">ans+=dis[u];</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">int</span> v=<span class="number">1</span>; v&lt;=n; v++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(vis[v]==<span class="literal">false</span> &amp;&amp; G[u][v]!=INF &amp;&amp; G[u][v]&lt;d[v])dis[v]=G[u][v];</span><br><span class="line"> &#125; </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="kruskal算法"><a href="#kruskal算法" class="headerlink" title="kruskal算法"></a>kruskal算法</h1><p>&emsp;&emsp;kruskal算法时间复杂度为O(ElogE)，适用于稀疏图。其思想是每次找出最短的那条边连到生成树集合中。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">struct node</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">int</span> x,y,cost;</span><br><span class="line"><span class="built_in">bool</span> operator&lt;(node &amp;s) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> cost&lt;s.cost;</span><br><span class="line">&#125; </span><br><span class="line">&#125;E[maxn];</span><br><span class="line"><span class="built_in">int</span> krusakl(<span class="built_in">int</span> n, <span class="built_in">int</span> m)     <span class="comment">//n为顶点，m为边 </span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">int</span> ans=<span class="number">0</span>,num_edge=<span class="number">0</span>;       <span class="comment">//num_edge表示当前生成树的边数</span></span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">&#123;</span><br><span class="line">fataher[i]=i;        <span class="comment">//初始化并查集 </span></span><br><span class="line"> &#125; </span><br><span class="line"> sort(E, E+m);         <span class="comment">//按边权从小到大排序</span></span><br><span class="line"> <span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>; i&lt;m; i++)<span class="comment">//枚举的是所有的边 </span></span><br><span class="line"> &#123;</span><br><span class="line"> <span class="built_in">int</span> faU=findfather(E[i].u);         <span class="comment">//查询测试边两个端点所在集合的根节点</span></span><br><span class="line"><span class="built_in">int</span> faV=findfather(E[i].v);</span><br><span class="line"><span class="keyword">if</span>(faU!=faV)</span><br><span class="line">&#123;</span><br><span class="line">father[faU]=faV;     <span class="comment">//合并集合，把测试边加入到最小生成树中 </span></span><br><span class="line">ans+=E[i].cost;</span><br><span class="line">num_edge++;</span><br><span class="line"><span class="keyword">if</span>(num_edge==n<span class="number">-1</span>)<span class="keyword">break</span>; </span><br><span class="line"> &#125; </span><br><span class="line">  &#125; </span><br><span class="line">  <span class="keyword">if</span>(num_edge!=n<span class="number">-1</span>)<span class="keyword">return</span> INF;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;简介： prim &amp;amp; krusakl&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法笔记" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>快速幂</title>
    <link href="http://yoursite.com/2019/11/07/%E5%BF%AB%E9%80%9F%E5%B9%82/"/>
    <id>http://yoursite.com/2019/11/07/快速幂/</id>
    <published>2019-11-07T11:27:24.000Z</published>
    <updated>2019-11-07T11:33:02.024Z</updated>
    
    <content type="html"><![CDATA[<p>简介： 快速幂求n次方</p><a id="more"></a><p>快速幂的基本思想是把n次看成一个二进制数，每次取末尾的1，其时间复杂度为log2(n)</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">求 m^k mod p，时间复杂度 O(logk)。</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> qmi(<span class="built_in">int</span> m, <span class="built_in">int</span> k, <span class="built_in">int</span> p)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> res = <span class="number">1</span>, t = m;</span><br><span class="line">    <span class="keyword">while</span> (k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (k&amp;<span class="number">1</span>) res = res * t % p;  <span class="comment">//若此位为1，则相乘 </span></span><br><span class="line">        t = t * t % p;   <span class="comment">//每次都要算乘积 </span></span><br><span class="line">        k &gt;&gt;= <span class="number">1</span>;   <span class="comment">//丢弃算完的这一位 </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;简介： 快速幂求n次方&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法笔记" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>二叉树</title>
    <link href="http://yoursite.com/2019/11/07/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>http://yoursite.com/2019/11/07/二叉树/</id>
    <published>2019-11-07T11:22:28.000Z</published>
    <updated>2019-11-07T11:26:45.811Z</updated>
    
    <content type="html"><![CDATA[<p>简介： 二叉树的一些基本操作</p><a id="more"></a><h1 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h1><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct <span class="keyword">node</span><span class="title"></span></span><br><span class="line"><span class="title">&#123;</span></span><br><span class="line"><span class="title">int</span> x;</span><br><span class="line"><span class="keyword">node</span> <span class="title">*lchild</span>,*rchild;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="新建节点"><a href="#新建节点" class="headerlink" title="新建节点"></a>新建节点</h1><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Node</span> <span class="title">*newNode</span>(int x)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">node</span> <span class="title">*Noot</span>=new <span class="keyword">node</span><span class="title">;</span></span><br><span class="line"><span class="title">Node-</span>&gt;<span class="attr">lchild=</span><span class="keyword">Node</span><span class="title">-&gt;rchild</span>=nullptr;</span><br><span class="line"><span class="keyword">Node</span><span class="title">-&gt;data</span>=x;</span><br><span class="line">return <span class="keyword">Node</span><span class="title">;</span></span><br><span class="line"><span class="title">&#125;</span></span><br></pre></td></tr></table></figure><h1 id="插入节点"><a href="#插入节点" class="headerlink" title="插入节点"></a>插入节点</h1><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void <span class="keyword">insert</span>(<span class="type">node</span> *<span class="built_in">&amp;root</span>, int x)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span><span class="built_in">(root</span>==nullptr)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">root</span>=newNode(x);</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(x&lt;<span class="built_in">=root</span>-&gt;data)<span class="keyword">insert</span><span class="built_in">(root</span>-&gt;lchild, x);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">insert</span><span class="built_in">(root</span>-&gt;rchild, x);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h1 id="建树"><a href="#建树" class="headerlink" title="建树"></a>建树</h1><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">node</span> <span class="title">*creat</span>(int data[], int n)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">node</span> <span class="title">*root</span>=nullptr;</span><br><span class="line">for(int i=<span class="number">0</span>; i<span class="tag">&lt;n; i++)</span></span><br><span class="line"><span class="tag">&#123;</span></span><br><span class="line"><span class="tag">insert(root, data[i]);</span></span><br><span class="line"><span class="tag">&#125;</span></span><br><span class="line"><span class="tag">return root;</span></span><br><span class="line"><span class="tag">&#125;</span></span><br></pre></td></tr></table></figure><h1 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h1><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void research(node *root, int x, int <span class="keyword">new</span><span class="type">data</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(root==nullptr)<span class="keyword">return</span> ;  <span class="comment">//找不到</span></span><br><span class="line"><span class="keyword">if</span>(root-&gt;data==x)root-&gt;data=<span class="keyword">new</span><span class="type">data</span>;</span><br><span class="line">research(root-&gt;lchild, x, <span class="keyword">new</span><span class="type">data</span>);      <span class="comment">//递归查找 </span></span><br><span class="line">research(root-&gt;rchild, x, <span class="keyword">new</span><span class="type">data</span>); </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;简介： 二叉树的一些基本操作&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法笔记" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>线程同步</title>
    <link href="http://yoursite.com/2019/11/07/%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5/"/>
    <id>http://yoursite.com/2019/11/07/线程同步/</id>
    <published>2019-11-07T07:36:43.000Z</published>
    <updated>2019-11-09T13:29:51.998Z</updated>
    
    <content type="html"><![CDATA[<p>简介： 如何解决线程的同步问题</p><a id="more"></a><h1 id="共享变量"><a href="#共享变量" class="headerlink" title="共享变量"></a>共享变量</h1><p>&emsp;&emsp;一个变量v是<strong>同步</strong>的，当且仅当它的一个实例被一个以上的线程引用。<br>&emsp;&emsp;每个线程都有它自己独立的上下文，包括<strong>线程ID、栈、栈指针、PC、条件码和通用目的寄存器值</strong>。每个线程和其他线程共享进程上下文的剩余部分，这包括整个用户虚拟地址空间，它是由制度文本（代码）、读/写数据、堆以及所有的共享库代码和数据区域组成的。在实际的线程内存模型中，寄存器的值虽然是隔离且被保护的，但是在栈中的值并不是这样的（其他线程也可以访问）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> **ptr;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thread</span><span class="params">(<span class="keyword">void</span> *vargp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> myid=(<span class="keyword">int</span>)vargp;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[%d]: %s (cnt=%d)\n"</span>, myid, ptr[myid], ++cnt);   <span class="comment">//每个线程都可以访问全局变量 </span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">pthread_t</span> tid;</span><br><span class="line"><span class="keyword">char</span>* msgs[N]=</span><br><span class="line">&#123;</span><br><span class="line"><span class="string">"hello from foo"</span>,</span><br><span class="line"><span class="string">"hello from bar"</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ptr = msgs;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;N; i++)</span><br><span class="line">&#123;</span><br><span class="line">pthread_create(&amp;tid, <span class="literal">NULL</span>, thread, (<span class="keyword">void</span> *)i);</span><br><span class="line">&#125;</span><br><span class="line">pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="用信号量同步线程"><a href="#用信号量同步线程" class="headerlink" title="用信号量同步线程"></a>用信号量同步线程</h1><h2 id="同步不正确的计数器程序"><a href="#同步不正确的计数器程序" class="headerlink" title="同步不正确的计数器程序"></a>同步不正确的计数器程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">long</span> cnt=<span class="number">0</span>; <span class="comment">//系统总是重新从它所在的内存读取数据，即使它前面的指令刚刚从该处读取过数据。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thread</span><span class="params">(<span class="keyword">void</span> *vargp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">long</span> i, niters=*((<span class="keyword">long</span> *)vargp);</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;niters; i++)cnt++;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">long</span> niters=<span class="number">1000000</span>;</span><br><span class="line"><span class="keyword">pthread_t</span> tid1, tid2;</span><br><span class="line"><span class="comment">//if(argc != 2)</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//fprintf(stderr, "usage: %s &lt;niters&gt;\n", argv[0]);</span></span><br><span class="line"><span class="comment">//return 0;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//niters=atoi(argv[1]);   //把字符串转换为整形数,参数为const char *,C++使用时需调用.c_str()</span></span><br><span class="line"><span class="comment">// 创建一个线程并且等待它们终止</span></span><br><span class="line">pthread_create(&amp;tid1, <span class="literal">NULL</span>, thread, &amp;niters); </span><br><span class="line">pthread_create(&amp;tid2, <span class="literal">NULL</span>, thread, &amp;niters);</span><br><span class="line">pthread_join(tid1, <span class="literal">NULL</span>);</span><br><span class="line">pthread_join(tid2, <span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">//检查结果</span></span><br><span class="line"><span class="keyword">if</span>(cnt != (<span class="number">2</span>*niters))<span class="built_in">printf</span>(<span class="string">"BOOM! cnt=%ld\n"</span>, cnt);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"OK cnt=%ld\n"</span>, cnt);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>); </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;运行结果为：<br><img src="https://s2.ax1x.com/2019/11/07/MkaTzV.png" alt=""><br>&emsp;&emsp;可见结果并不像预期的一样时2*niters，这是因为我们没有办法预测操作系统是否将为你的线程选择一个正确的顺序。<br>&emsp;&emsp;汇编代码为：<br><img src="https://s2.ax1x.com/2019/11/07/MkwTDU.png" alt=""><br>&emsp;&emsp;比如按如下指令顺序次序执行，会得到一个错误的值：<br><img src="https://s2.ax1x.com/2019/11/07/Mk03Ps.png" alt=""><br>关于volatile关键字可以参考：<a href="https://blog.csdn.net/ijn842/article/details/81273232" target="_blank" rel="noopener">https://blog.csdn.net/ijn842/article/details/81273232</a></p><h3 id="临界区（critical-section）"><a href="#临界区（critical-section）" class="headerlink" title="临界区（critical section）"></a>临界区（critical section）</h3><p>&emsp;&emsp;操作共享变量cnt内容的指令（L，U，S）构成了一个（关于共享变量cnt）的<strong>临界区</strong>，这个临界区不应该和其他线程的临界区交替执行。如果我们想要<strong>拥有对共享变量的互斥访问</strong>，就必须确保每个线程在执行它的临界区的指令时不和其他线程的临界区交替执行。</p><h2 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h2><p>&emsp;&emsp;可以利用PV操作来解决临界区问题。</p><ul><li>P( <strong>s</strong> ): 如果s不为0，那么P将s减1，并且立即返回。如果s为0，那么就挂起这个线程，直到s变为非0，而一个V操作会重启这个线程。</li><li>V( <strong>s</strong> ): V操作将s加1。如果有线程阻塞在P操作等待s变为非0，那么V操作会重启这些线程中的一个。V唯一的要求就是必须重启一个正在等待的线程，所有<strong>当多个线程在等待同一信号量时，不能预测V操作要重启哪一个线程</strong>。<br>&emsp;&emsp;PV操作保证了一个程序不可能有一个负值信号量，这个属性称为<strong>信号量不变性</strong>。</li></ul><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#<span class="keyword">include</span> &lt;semaphore.h&gt;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> sem<span class="constructor">_init(<span class="params">sem_t</span> <span class="operator">*</span><span class="params">sem</span>, 0, <span class="params">unsigned</span> <span class="params">int</span> <span class="params">value</span>)</span>;</span><br><span class="line"><span class="comment">//将信号量sem初始化为value</span></span><br><span class="line"><span class="comment">//第二个参数不为0时此信号量在进程间共享，否则只能为当前进程的所有线程共享</span></span><br><span class="line"><span class="built_in">int</span> sem<span class="constructor">_wait(<span class="params">sem_t</span> <span class="operator">*</span><span class="params">s</span>)</span>    <span class="comment">//P(s)</span></span><br><span class="line"><span class="built_in">int</span> sem<span class="constructor">_post(<span class="params">sem_t</span> <span class="operator">*</span><span class="params">s</span>)</span>    <span class="comment">//V(s)</span></span><br></pre></td></tr></table></figure><h2 id="同步正确的计数器程序"><a href="#同步正确的计数器程序" class="headerlink" title="同步正确的计数器程序"></a>同步正确的计数器程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;semaphore.h&gt; </span></span></span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">long</span> cnt=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">sem_t</span> mutex;      <span class="comment">//申请互斥变量 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">P</span><span class="params">(<span class="keyword">sem_t</span> *s)</span>    <span class="comment">//P操作 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(sem_wait(s)&lt;<span class="number">0</span>) <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"sem_wait error: %s\n"</span>, strerror(errno)),<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">V</span><span class="params">(<span class="keyword">sem_t</span> *s)</span>   <span class="comment">//V操作 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(sem_post(s)&lt;<span class="number">0</span>)<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"sem_post error: %s\n"</span>, strerror(errno)),<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thread</span><span class="params">(<span class="keyword">void</span> *vargp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">long</span> niters=(*(<span class="keyword">long</span> *)vargp);</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;niters; i++)</span><br><span class="line">&#123;</span><br><span class="line">P(&amp;mutex);        <span class="comment">//进行pv操作， 保护临界区 </span></span><br><span class="line">cnt++;</span><br><span class="line">V(&amp;mutex);</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">long</span> niters=<span class="number">1000</span>;</span><br><span class="line"><span class="keyword">pthread_t</span> tid1,tid2;</span><br><span class="line">sem_init(&amp;mutex, <span class="number">0</span>, <span class="number">1</span>);   <span class="comment">//将mutex初始化为1 </span></span><br><span class="line">pthread_create(&amp;tid1, <span class="literal">NULL</span>, thread, &amp;niters);</span><br><span class="line">pthread_create(&amp;tid2, <span class="literal">NULL</span>, thread, &amp;niters);</span><br><span class="line">pthread_join(tid1, <span class="literal">NULL</span>);</span><br><span class="line">pthread_join(tid2, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span>(cnt != (<span class="number">2</span>*niters))<span class="built_in">printf</span>(<span class="string">"BOOM! cnt=%ld\n"</span>, cnt);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"OK cnt=%ld\n"</span>, cnt);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;利用PV操作，可以做到互斥访问临界区，所以能得到正确的结果</p><h2 id="生产者-消费者问题"><a href="#生产者-消费者问题" class="headerlink" title="生产者-消费者问题"></a>生产者-消费者问题</h2><p>&emsp;&emsp;生产者和消费者线程共享一个有n个槽的有限缓冲区。生产者线程反复生成新的项目，并把它们插入到缓冲区中，消费者线程不断地从缓冲区中取出这些项目，然后消费它们。<br><img src="https://s2.ax1x.com/2019/11/08/MZcnXQ.png" alt=""><br>&emsp;&emsp;因为插入和消费都涉及更新共享变量，所以我们必须保证对缓冲区的访问时互斥的。</p><p><strong>结构体</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> *buf;      <span class="comment">//buf数组</span></span><br><span class="line"><span class="keyword">int</span> n;         <span class="comment">//槽位的最大值</span></span><br><span class="line"><span class="keyword">int</span> front;     <span class="comment">//buf中的第一个值前面 </span></span><br><span class="line"><span class="keyword">int</span> rear;      <span class="comment">//buf中的最后一个值</span></span><br><span class="line"><span class="keyword">sem_t</span> mutex;   <span class="comment">//对buf进行控制的互斥量</span></span><br><span class="line"><span class="keyword">sem_t</span> slots;   <span class="comment">//统计buf中空槽位数目</span></span><br><span class="line"><span class="keyword">sem_t</span> items;   <span class="comment">//统计buf中可用项数目 </span></span><br><span class="line">&#125;<span class="keyword">sbuf_t</span>;</span><br></pre></td></tr></table></figure><p><strong>初始化结构体</strong></p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化缓冲区 </span></span><br><span class="line">void sbuf<span class="constructor">_intit(<span class="params">sbuf_t</span> <span class="operator">*</span><span class="params">sp</span>, <span class="params">int</span> <span class="params">n</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">sp-&gt;buf=(<span class="built_in">int</span> *)calloc(n, sizeof(<span class="built_in">int</span>));   <span class="comment">//分配n个 </span></span><br><span class="line"><span class="comment">//calloc在动态分配完内存后,自动初始化该内存空间为零,而</span></span><br><span class="line"><span class="comment">//malloc不做初始化,分配到的空间中的数据是随机数据</span></span><br><span class="line">sp-&gt;n=n;</span><br><span class="line">sp-&gt;front=sp-&gt;rear=<span class="number">0</span>;</span><br><span class="line">sem<span class="constructor">_init(&amp;<span class="params">sp</span>-&gt;<span class="params">mutex</span>, 0, 1)</span>;    <span class="comment">//将mutex初始化为1</span></span><br><span class="line">sem<span class="constructor">_init(&amp;<span class="params">sp</span>-&gt;<span class="params">slots</span>, 0, <span class="params">n</span>)</span>;    <span class="comment">//将空槽位初始化为n</span></span><br><span class="line">sem<span class="constructor">_init(&amp;<span class="params">sp</span>-&gt;<span class="params">items</span>, 0, 0)</span>;    <span class="comment">//将可用项数目初始化为0 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>释放申请的buf空间</strong></p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void <span class="keyword">sbuf_deinit(sbuf </span>*<span class="built_in">sp</span>)</span><br><span class="line">&#123;</span><br><span class="line">free(<span class="built_in">sp</span>-&gt;<span class="keyword">buf);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>将一个可用项插入buf</strong></p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void sbuf<span class="constructor">_insert(<span class="params">sbuf_t</span> <span class="operator">*</span><span class="params">sp</span>, <span class="params">int</span> <span class="params">item</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="constructor">P(&amp;<span class="params">sp</span>-&gt;<span class="params">slots</span>)</span>;  <span class="comment">//将可用槽位的数目减一 </span></span><br><span class="line"><span class="constructor">P(&amp;<span class="params">sp</span>-&gt;<span class="params">mutex</span>)</span>;  <span class="comment">//加互斥锁 </span></span><br><span class="line">sp-&gt;buf<span class="literal">[(<span class="operator">++</span><span class="identifier">sp</span>-&gt;<span class="identifier">rear</span>)%(<span class="identifier">sp</span>-&gt;<span class="identifier">n</span>)]</span> = item;     <span class="comment">//当到达buf尾端时，要取模</span></span><br><span class="line"><span class="constructor">V(&amp;<span class="params">sp</span>-&gt;<span class="params">mutex</span>)</span>;      <span class="comment">//解开互斥锁 </span></span><br><span class="line"><span class="constructor">V(&amp;<span class="params">sp</span>-&gt;<span class="params">items</span>)</span>;       <span class="comment">//可用项的数目加一 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>从buf中取出一个可用项</strong></p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> sbuf<span class="constructor">_remove(<span class="params">sbuf_t</span> <span class="operator">*</span><span class="params">sp</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">int</span> item;</span><br><span class="line"><span class="constructor">P(&amp;<span class="params">sp</span>-&gt;<span class="params">items</span>)</span>;      <span class="comment">//取出来以后可用项的数目减一 </span></span><br><span class="line"><span class="constructor">P(&amp;<span class="params">sp</span>-&gt;<span class="params">mutex</span>)</span>;          <span class="comment">//加互斥锁 </span></span><br><span class="line">item=sp-&gt;buf<span class="literal">[(<span class="operator">++</span><span class="identifier">sp</span>-&gt;<span class="identifier">front</span>)%(<span class="identifier">sp</span>-&gt;<span class="identifier">n</span>)]</span>;</span><br><span class="line"><span class="constructor">V(&amp;<span class="params">sp</span>-&gt;<span class="params">mutex</span>)</span>;         <span class="comment">//解开互斥锁 </span></span><br><span class="line"><span class="constructor">V(&amp;<span class="params">sp</span>-&gt;<span class="params">slots</span>)</span>;        <span class="comment">//取出来，空槽位加一</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>PV操作</strong></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void P(sem_t *s)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(sem_wait(s) &lt; <span class="number">0</span>)fprintf(stderr, <span class="string">"sem_wait error: %s\n"</span>, strerror(errno)),<span class="keyword">exit</span>(<span class="number">0</span>);</span><br><span class="line"> &#125; </span><br><span class="line">void V(sem_t *s)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(sem_post(s) &lt; <span class="number">0</span>)fprintf(stderr, <span class="string">"sem_post error: %s\n"</span>, strerror(errno)),<span class="keyword">exit</span>(<span class="number">0</span>);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;简介： 如何解决线程的同步问题&lt;/p&gt;
    
    </summary>
    
    
      <category term="csapp" scheme="http://yoursite.com/categories/csapp/"/>
    
    
      <category term="Linux C/C++" scheme="http://yoursite.com/tags/Linux-C-C/"/>
    
      <category term="网络编程" scheme="http://yoursite.com/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>字符串哈希</title>
    <link href="http://yoursite.com/2019/11/06/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%93%88%E5%B8%8C/"/>
    <id>http://yoursite.com/2019/11/06/字符串哈希/</id>
    <published>2019-11-06T13:28:24.000Z</published>
    <updated>2019-11-06T13:55:33.932Z</updated>
    
    <content type="html"><![CDATA[<p>简介： 字符串前缀哈希法</p><a id="more"></a><p>&emsp;&emsp;判断一个字符串两段字符是否相等</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//要人品足够好，保证没有冲突现象发生 </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ULL;<span class="comment">//溢出相当于取模 </span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">100010</span>,P=<span class="number">131</span>;  <span class="comment">//p=131或者13331为经验值 ,若哈希值特别大，则需要取模，对2^64取模为经验值 </span></span><br><span class="line">ULL p[maxn],h[maxn];</span><br><span class="line"><span class="keyword">char</span> str[maxn];</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="function">ULL <span class="title">get</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span>  <span class="comment">//结果溢出即为取模 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> h[r]-h[l<span class="number">-1</span>]*p[r-l+<span class="number">1</span>];           <span class="comment">//公式高位|--------l-1----相当于乘10的n次-------r|低位  </span></span><br><span class="line"><span class="comment">//参数为1-l哈希值，1-r哈希值 </span></span><br><span class="line"> &#125; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m&gt;&gt;str+<span class="number">1</span>;</span><br><span class="line">p[<span class="number">0</span>]=<span class="number">1</span>;          <span class="comment">//p的0次方等于1 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">&#123;</span><br><span class="line">p[i]=p[i<span class="number">-1</span>]*P;             <span class="comment">//预处理p数组，，用于字符串哈希，相当于p进制 </span></span><br><span class="line">h[i]=h[i<span class="number">-1</span>]*P + str[i];     <span class="comment">//计算哈希值 ，a*p^0 + b*p^2+..... 并且不断取模 </span></span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">while</span>(m--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> l1,r1,l2,r2;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;l1&gt;&gt;r1&gt;&gt;l2&gt;&gt;r2;</span><br><span class="line"><span class="keyword">if</span>(get(l1,r1)==get(l2,r2))<span class="built_in">cout</span>&lt;&lt;<span class="string">"Yes"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="string">"No"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;简介： 字符串前缀哈希法&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法笔记" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>KMP</title>
    <link href="http://yoursite.com/2019/11/06/KMP/"/>
    <id>http://yoursite.com/2019/11/06/KMP/</id>
    <published>2019-11-06T13:16:49.000Z</published>
    <updated>2019-11-06T13:29:17.198Z</updated>
    
    <content type="html"><![CDATA[<p>简介： KMP算法</p><a id="more"></a><p>&emsp;&emsp;kmp算法时间复杂度：O(m+n)<br>&emsp;&emsp;在某个字符失配时，该字符对应的next 值会告诉你下一步匹配中，模式串应该跳到哪个位置（跳到next [j] 的位置）。此时不必重新开始匹配。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">10010</span>,M=<span class="number">100010</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">char</span> p[N],s[M];</span><br><span class="line"><span class="keyword">int</span> ne[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;p+<span class="number">1</span>&gt;&gt;m&gt;&gt;s+<span class="number">1</span>;</span><br><span class="line"><span class="comment">//求next的过程， next[1]=0 找前面子集字符串 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>,j=<span class="number">0</span>; i&lt;=n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>(j &amp;&amp; p[i]!=p[j+<span class="number">1</span>])j=ne[j];</span><br><span class="line"><span class="keyword">if</span>(p[i]==p[j+<span class="number">1</span>])j++;</span><br><span class="line">ne[i]=j;</span><br><span class="line"> &#125; </span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,j=<span class="number">0</span>; i&lt;=m; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>(j &amp;&amp; p[j+<span class="number">1</span>]!=s[i])j=ne[j];    <span class="comment">//没有匹配上，求next</span></span><br><span class="line"><span class="keyword">if</span>(s[i]==p[j+<span class="number">1</span>]) j++;      <span class="comment">//这个字符匹配，求下一个</span></span><br><span class="line"><span class="keyword">if</span>(j==n)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;i-n&lt;&lt;<span class="string">" "</span>;      <span class="comment">//完全匹配上</span></span><br><span class="line">j=ne[j];           <span class="comment">//求解下一个 </span></span><br><span class="line"> &#125; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;简介： KMP算法&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法笔记" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>最短路径</title>
    <link href="http://yoursite.com/2019/11/06/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/"/>
    <id>http://yoursite.com/2019/11/06/最短路径/</id>
    <published>2019-11-06T12:13:17.000Z</published>
    <updated>2019-11-06T13:15:56.650Z</updated>
    
    <content type="html"><![CDATA[<p>简介： 最短路径算法</p><a id="more"></a><h1 id="Dijkstra-算法"><a href="#Dijkstra-算法" class="headerlink" title="Dijkstra 算法"></a>Dijkstra 算法</h1><p>&emsp;&emsp;时间复杂度O(n²），适用于稠密图。<br>&emsp;&emsp;示例：<br><img src="https://s2.ax1x.com/2019/11/06/Mi30sI.jpg" alt=""></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="built_in">int</span> maxn=<span class="number">510</span>,INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="built_in">int</span> G[maxn][maxn],dis[maxn];            <span class="comment">//G为矩阵，dis为起点到各个点的最短距离</span></span><br><span class="line"><span class="built_in">bool</span> vis[maxn];</span><br><span class="line"><span class="built_in">void</span> dijkstra(<span class="built_in">int</span> s)      <span class="comment">//s为起点 </span></span><br><span class="line">&#123;</span><br><span class="line">fill(dis, dis+maxn, INF);             <span class="comment">//将距离初始化为INF，即就是无穷大</span></span><br><span class="line">d[s]=<span class="number">0</span>;                <span class="comment">//起点到起点的距离为0</span></span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>; i&lt;n; i++)      <span class="comment">//循环n次 </span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">int</span> u=<span class="number">-1</span>,mi=INF;         </span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">int</span> j=<span class="number">1</span>; j&lt;=n; j++)<span class="comment">//找到为访问顶点中的d[]最小的 </span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(vis[j]==<span class="literal">false</span> &amp;&amp; d[j]&lt;mi)</span><br><span class="line">&#123;</span><br><span class="line">u=j;</span><br><span class="line">mi=d[j];</span><br><span class="line">&#125; </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">if</span>(u==<span class="number">-1</span>)<span class="keyword">return</span> ;            <span class="comment">//如果找不到小于MI的d[]，说明剩下的顶点与起点s不连通      </span></span><br><span class="line">vis[u]=<span class="literal">true</span>;          <span class="comment">//标记为访问过 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">int</span> v=<span class="number">1</span>; v&lt;=n; v++)</span><br><span class="line">&#123;       <span class="comment">//如果v没有访问 &amp;&amp; u能到达v &amp;&amp; 以u为中介点能使d[v] 更优</span></span><br><span class="line"><span class="keyword">if</span>(vis[v]==<span class="literal">false</span> &amp;&amp; G[u][v]!=INF &amp;&amp; d[v]&gt;d[u]+G[u][v])d[v]=G[u][v]+d[v];    <span class="comment">//优化</span></span><br><span class="line">&#125; </span><br><span class="line"> &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="堆优化版的Dijkstra算法"><a href="#堆优化版的Dijkstra算法" class="headerlink" title="堆优化版的Dijkstra算法"></a>堆优化版的Dijkstra算法</h1><p>&emsp;&emsp;时间复杂度O((m+n)logn)，适用于稀疏图。利用stl中的优先队列来进行优化。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//--------------堆优化</span></span><br><span class="line"><span class="keyword">using</span> PII = pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dij</span><span class="params">(<span class="keyword">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">fill(dis, dis+maxn, INF);</span><br><span class="line">dis[s]=<span class="number">0</span>;</span><br><span class="line">priority_queue&lt;PII, <span class="built_in">vector</span>&lt;PII&gt;, greater&lt;PII&gt;&gt; heap;</span><br><span class="line">heap.push(&#123;<span class="number">0</span>,s&#125;);         <span class="comment">//s到自己的距离为0   //一定要注意要先写距离再写点，，因为堆排序的时候要用距离作为第一尺度 </span></span><br><span class="line"><span class="keyword">while</span>(heap.size())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">auto</span> t=heap.top();</span><br><span class="line">heap.pop();</span><br><span class="line"><span class="keyword">int</span> u=t.second,w=t.first;        <span class="comment">//取出最小的点和该店到源点的最短距离 </span></span><br><span class="line"><span class="keyword">if</span>(vis[u]) <span class="keyword">continue</span>;              <span class="comment">//可能存在一些冗余边比如2-&gt;3(2);2-&gt;3(4) 后面的被舍弃 </span></span><br><span class="line">vis[u]=<span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;adj[u].size(); j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> v=adj[u][j].v;</span><br><span class="line"><span class="keyword">if</span>(vis[v]==<span class="literal">false</span> &amp;&amp; dis[v]&gt;w+adj[u][j].dis)</span><br><span class="line">&#123;</span><br><span class="line">dis[v]=w+adj[u][j].dis;</span><br><span class="line">heap.push(&#123;dis[v],v&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="folyd-算法"><a href="#folyd-算法" class="headerlink" title="folyd 算法"></a>folyd 算法</h1><p>&emsp;&emsp;时间复杂度为O(n³)</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">void floyd()</span><br><span class="line">&#123;</span><br><span class="line">for(int k=<span class="number">1</span>; k&lt;=n; k++)       //以k为中介，枚举所有顶点 </span><br><span class="line">&#123;</span><br><span class="line">for(int i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">&#123;</span><br><span class="line">for(int j=<span class="number">1</span>; j&lt;=n; j++)</span><br><span class="line">&#123;</span><br><span class="line">if(dis<span class="string">[i]</span><span class="string">[k]</span>!=INF &amp;&amp; dis<span class="string">[k]</span><span class="string">[j]</span>!=INF &amp;&amp; dis<span class="string">[i]</span><span class="string">[k]</span>+dis<span class="string">[k]</span><span class="string">[j]</span>&lt;dis<span class="string">[i]</span><span class="string">[j]</span>)</span><br><span class="line">dis<span class="string">[i]</span><span class="string">[j]</span>=dis<span class="string">[i]</span><span class="string">[k]</span>+dis<span class="string">[k]</span><span class="string">[j]</span>;               //存的时候要把dis<span class="string">[i]</span><span class="string">[i]</span>设置为<span class="number">0</span>，因为自己到自己的距离为<span class="number">0</span> </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Bellman-算法"><a href="#Bellman-算法" class="headerlink" title="Bellman 算法"></a>Bellman 算法</h1><p>&emsp;&emsp;时间复杂度为O(nm),适用于权值为负的情况</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">100010</span>,INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> v,dis;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;node&gt; adj[maxn];</span><br><span class="line"><span class="keyword">int</span> m,n,d[maxn],vis[maxn];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Bellman</span><span class="params">(<span class="keyword">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">fill(d,d+maxn,INF);</span><br><span class="line">d[s]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n<span class="number">-1</span>; i++)   <span class="comment">//n-1次松弛操作   两个点一条边要一次松弛 </span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//copy(dis, dis+maxn, ans); //保证不发生串联 如果不加，可能会用更新后的值依次更新后面的节点 ,此时一次只更新一层 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> u=<span class="number">1</span>; u&lt;=n; u++)   <span class="comment">//枚举每一条边 </span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;adj[u].size(); j++)   <span class="comment">//如果以u为中介可以使d[v]变小 </span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> v=adj[u][j].v;</span><br><span class="line"><span class="keyword">int</span> dis=adj[u][j].dis;</span><br><span class="line"><span class="keyword">if</span>(d[u]+dis&lt;d[v])d[v]=d[u]+dis;     <span class="comment">//松弛操作 </span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//if(dis[n] &gt;INF/2)return false;     //可能会有一条负权边把n号点更新 </span></span><br><span class="line"><span class="comment">//return true;</span></span><br><span class="line"><span class="comment">//判断负环</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> u=<span class="number">1</span>; u&lt;=n; u++)     <span class="comment">//如果还能进行松弛操作 </span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;adj[u].size(); j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> v=adj[u][j].v;</span><br><span class="line"><span class="keyword">int</span> dis=adj[u][j].dis;</span><br><span class="line"><span class="keyword">if</span>(d[u]+dis&lt;d[v])<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="spfa算法"><a href="#spfa算法" class="headerlink" title="spfa算法"></a>spfa算法</h1><p>&emsp;&emsp;一般情况下时间复杂度为O(m)最坏时间复杂度为O(nm),适用于权值为负的情况。对比Bellman算法，spfa只有在松弛操作后才会入队，同样适用于权值为负的情况。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">100010</span>,INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">bool</span> vis[maxn];</span><br><span class="line"><span class="keyword">int</span> n,dis[maxn],num[maxn];         <span class="comment">//num数组记录顶点的入队次数 </span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">SPFA</span><span class="params">(<span class="keyword">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">fill(dis, dis+maxn, INF); </span><br><span class="line">dis[s]=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">q.push(s);        <span class="comment">//源点入队</span></span><br><span class="line">vis[s]=<span class="literal">true</span>;</span><br><span class="line">num[s]++; <span class="comment">//入队次数加1</span></span><br><span class="line"><span class="keyword">while</span>(!q.empty())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">auto</span> u=q.front();</span><br><span class="line">q.pop();</span><br><span class="line">vis[u]=<span class="literal">false</span>;          <span class="comment">//设置u不在队列</span></span><br><span class="line"><span class="comment">//遍历所有邻边</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;adj[u].size(); j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> v=adj[u][j].v;</span><br><span class="line"><span class="keyword">int</span> d=adj[u][j].dis;</span><br><span class="line"><span class="keyword">if</span>(dis[u]+d &lt; dis[v])</span><br><span class="line">&#123;</span><br><span class="line">dis[v]=dis[u]+d;</span><br><span class="line"><span class="keyword">if</span>(!vis[v])     <span class="comment">//v不在队列 </span></span><br><span class="line">&#123;</span><br><span class="line">q.push(v);   <span class="comment">//有松弛操作才入队 </span></span><br><span class="line">vis[v]=<span class="literal">true</span>;</span><br><span class="line">num[v]++;</span><br><span class="line"><span class="keyword">if</span>(num[v]&gt;=n)<span class="keyword">return</span> <span class="literal">false</span>;      <span class="comment">//有可达负环 </span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> &#125; </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="keyword">return</span> <span class="literal">true</span>; </span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;简介： 最短路径算法&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法笔记" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>echo服务器-基于线程</title>
    <link href="http://yoursite.com/2019/11/06/echo%E6%9C%8D%E5%8A%A1%E5%99%A8%E2%80%94%E2%80%94%E5%9F%BA%E4%BA%8E%E7%BA%BF%E7%A8%8B/"/>
    <id>http://yoursite.com/2019/11/06/echo服务器——基于线程/</id>
    <published>2019-11-06T07:45:08.000Z</published>
    <updated>2019-11-10T10:40:43.930Z</updated>
    
    <content type="html"><![CDATA[<p>简介： 基于线程的并发编程</p><a id="more"></a><h1 id="并行方法"><a href="#并行方法" class="headerlink" title="并行方法"></a>并行方法</h1><p>&emsp;&emsp;前面实现的服务器，一次只能处理一个请求，只有当前的请求处理完了，才能继续处理下一个。<br><img src="https://s2.ax1x.com/2019/11/06/MPrLjK.jpg" alt=""><br>&emsp;&emsp;服务器初始化后listen客户端的connect请求，当客户端向服务器发送connect请求后，服务器accept并且开始等待客户端的输入，客户端 1 write之后转为等待响应(call read)，服务器的read接收到内容之后，发送响应(write) 后进入等待(read)，而客户端 1 接收到了响应(ret read)，最后根据用户指令退出(close)。而只有当客户端 1 断开之后，服务器才会处理客户端 2 的请求。我们可以使用并行的策略，同时处理不同客户端发来的请求。</p><h2 id="基于进程"><a href="#基于进程" class="headerlink" title="基于进程"></a>基于进程</h2><p>&emsp;&emsp;为每个客户端分离出一个单独的进程，是建立了连接之后才开始并行，连接的建立还是串行的。服务器在 accept 中返回 connfd 并且 fork 一个子进程来处理客户端连接。</p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul><li>每个客户端由独立子进程处理<ul><li>必须回收僵尸进程，来避免严重的内存泄露</li></ul></li><li>内核自动管理多个逻辑流</li><li>每个进程有其私有的地址空间</li><li>不同进程之间不共享数据</li><li>父进程和子进程都有 listenfd 和 connfd，所以在父进程中需要关闭 connfd，在子进程中需要关闭 listenfd<ul><li>内核会保存每个 socket 的引用计数，在 fork 之后 refcnt(connfd) = 2，所以在父进程需要关闭 connfd，这样在子进程结束后引用计数才会为零</li></ul></li></ul><h2 id="基于事件"><a href="#基于事件" class="headerlink" title="基于事件"></a>基于事件</h2><p>&emsp;&emsp;服务器会维护一个 connection 数组，包含若干 connfd，每个输入请求都被当做事件，然后每次从已有的事件中选取一个进行处理。</p><h3 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h3><ul><li>由程序员手动控制多个逻辑流</li><li>所有的逻辑流共享同一个地址空间</li><li>这个技术称为 I/O multiplexing</li></ul><h2 id="基于线程"><a href="#基于线程" class="headerlink" title="基于线程"></a>基于线程</h2><p>&emsp;&emsp;<strong>线程</strong>就是运行在进程上下文中的逻辑流<br>&emsp;&emsp;一个进程则包括线程、代码、数据和上下文。也就是说，线程作为单独可执行的部分，被抽离出来了，一个进程可以有多个线程。<br>&emsp;&emsp;每个线程有自己的线程 id，有自己的逻辑控制流，也有自己的用来保存局部变量的栈（其他线程可以修改）但是会共享所有的代码、数据以及内核上下文。和进程不同的是，线程没有一个明确的树状结构（使用 fork 是有明确父进程子进程区分的）。和进程中『并行』的概念一样，如果两个线程的控制流在时间上有『重叠』（或者说有交叉），那么就是并行的。线程共享代码和数据（进程通常不会），线程开销比较小（创建和回收）。一个线程可以杀死它的任何对等线程，或者等待它的任意对等线程终止，而且每个对等线程能读写相同的共享数据。</p><h3 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h3><ul><li>内核自动管理多个逻辑流</li><li>每个线程共享地址空间</li></ul><h1 id="Posix-线程"><a href="#Posix-线程" class="headerlink" title="Posix 线程"></a>Posix 线程</h1><p>&emsp;&emsp;Posix线程是在c语言中处理线程的一个标准接口，Pthreads定义了大概60个函数，允许程序创建、杀死、回收线程，与对等线程安全的共享数据，还可以通知对等线程系统状态的变化。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thread</span><span class="params">(<span class="keyword">void</span> *vargp)</span>  <span class="comment">//每个线程例程都以一个通用指针作为输入，返回一个通用指针 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"helo"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">pthread_t</span> tid;      <span class="comment">//存放线程ID </span></span><br><span class="line">pthread_create(&amp;tid, <span class="literal">NULL</span>, thread, <span class="literal">NULL</span>);    <span class="comment">//创建对等线程，此函数返回时，主线程与对等线程同时运行 </span></span><br><span class="line">pthread_join(tid, <span class="literal">NULL</span>);   <span class="comment">//子线程合入主线程，主线程阻塞等待子线程结束，然后回收子线程资源。 </span></span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);   <span class="comment">//终止运行在这个进程中的所有进程 </span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h2 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h2><p>&emsp;&emsp;线程通过调用pthread_create函数来创建其他线程:</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">typedef void *(func)(void *);</span><br><span class="line"><span class="built_in">int</span> pthread<span class="constructor">_create(<span class="params">pthread_t</span> <span class="operator">*</span><span class="params">tid</span>, <span class="params">pthread_attr_t</span> <span class="operator">*</span><span class="params">attr</span>, <span class="params">func</span> <span class="operator">*</span><span class="params">f</span>, <span class="params">void</span> <span class="operator">*</span><span class="params">arg</span>)</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;此函数创建一个新线程，并带着一个输入变量args，在新线程的上下文中运行线程例程f。可用attr参数来改变新线程的默认属性。当此函数返回时，tid包含新创建的线程ID，可调用pthread_self函数来获得自己的线程ID:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ptherad_t</span> pthread_self(<span class="keyword">void</span>);</span><br></pre></td></tr></table></figure><h2 id="终止线程"><a href="#终止线程" class="headerlink" title="终止线程"></a>终止线程</h2><ul><li>顶层线程例程返回时，线程会隐式终止</li><li>调用pthread_exit函数，线程显式终止，此时线程占用的资源不会释放<code>void pthread_exit(void *thread_return)</code>参数可以通过pthread_join传递</li><li>某个对等线程调用exit函数，该函数终止进程以及与进程相关的所有线程</li><li>另一个对等线程通过以当前线程ID为参数调用pthread_cancel</li></ul><h2 id="回收资源"><a href="#回收资源" class="headerlink" title="回收资源"></a>回收资源</h2><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> pthread<span class="constructor">_join(<span class="params">pthread_t</span> <span class="params">tid</span>, <span class="params">void</span> <span class="operator">**</span><span class="params">thread_return</span>)</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;pthread_join会阻塞，直到线程tid终止，将线程例程返回的通用指针赋值为thread_return指向的位置，然后回收终止线程占用的资源</p><h2 id="分离线程"><a href="#分离线程" class="headerlink" title="分离线程"></a>分离线程</h2><p>&emsp;&emsp;在任何一个时间点上，线程是可结合或者分离的。<br>&emsp;&emsp;一个<strong>可结合</strong>线程能<strong>被其他线程收回和杀死</strong>。在被其他线程回收之前，它的<strong>内存资源是不释放</strong>的。<br>&emsp;&emsp;一个<strong>分离</strong>的线程不能被其他线程回收或者杀死，它的<strong>内存资源在它终止时由系统自动释放</strong>。<br>&emsp;&emsp;默认情况下，线程被创建为可结合的，pthread_detach可分离可结合线程tid</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> pthread<span class="constructor">_detach(<span class="params">pthread_t</span> <span class="params">tid</span>)</span>;</span><br></pre></td></tr></table></figure><h2 id="初始化线程"><a href="#初始化线程" class="headerlink" title="初始化线程"></a>初始化线程</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pthread_once_t</span> once_control = PTHREAD_ONCE_INIT;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_once</span><span class="params">(<span class="keyword">pthread_once_t</span> *once_control, <span class="keyword">void</span> (*init_routine)(<span class="keyword">void</span>))</span></span>;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;此函数允许你初始化与线程例程相关的状态，once_control是一个全局或者静态变量，总是被初始化为PTHREAD_ONCE。</p><h1 id="并发服务器-基于线程"><a href="#并发服务器-基于线程" class="headerlink" title="并发服务器-基于线程"></a>并发服务器-基于线程</h1><p>&emsp;&emsp;主线程不断等待连接请求，然后创建一个对等线程处理该请求。<br>Q：当我们调用pthread_create时，如何将已连接描述符传递给对等线程<br>A：传递一个指向描述符的指针</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"csapp.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">echo</span><span class="params">(<span class="keyword">int</span> connfd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">size_t</span> n;</span><br><span class="line"><span class="keyword">rio_t</span> rio;</span><br><span class="line"><span class="keyword">char</span> buf[MAXNLINE];</span><br><span class="line">rio_readinitb(&amp;rio, connfd);</span><br><span class="line"><span class="keyword">while</span>((n=rio_readlineb(&amp;rio, buf, MAXNLINE)) != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"serve received %d bytes\n"</span>, (<span class="keyword">int</span>)n);</span><br><span class="line">rio_writen(connfd, buf, n);</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thread</span><span class="params">(<span class="keyword">void</span> *vargp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> connfd = *((<span class="keyword">int</span> *)vargp);       <span class="comment">//把描述符取出来</span></span><br><span class="line">pthread_detach(pthread_self());     <span class="comment">//分离线程，参数为线程ID</span></span><br><span class="line"><span class="built_in">free</span>(vargp);    <span class="comment">//释放空间</span></span><br><span class="line">echo(connfd);</span><br><span class="line">close(connfd);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> listenfd,*connfdp;</span><br><span class="line"><span class="keyword">socklen_t</span> clientlen;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_storage</span> <span class="title">clientaddr</span>;</span></span><br><span class="line"><span class="keyword">pthread_t</span> tid;</span><br><span class="line"><span class="keyword">if</span>(argc != <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"usage: %s &lt;port&gt;\n"</span>, argv[<span class="number">0</span>]);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">listenfd = open_listenfd(argv[<span class="number">1</span>]);</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">clientlen=<span class="keyword">sizeof</span>(struct sockaddr_storage);</span><br><span class="line">connfdp = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>));      <span class="comment">//开辟一个int大小的空间存描述符 </span></span><br><span class="line">*connfdp = accept(listenfd, (struct sockaddr *)&amp; clientaddr, &amp;clientlen);</span><br><span class="line">pthread_create(&amp;tid, <span class="literal">NULL</span>, thread, connfdp);  <span class="comment">//将指向描述符的指针传递给对等线程</span></span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;简介： 基于线程的并发编程&lt;/p&gt;
    
    </summary>
    
    
      <category term="csapp" scheme="http://yoursite.com/categories/csapp/"/>
    
    
      <category term="Linux C/C++" scheme="http://yoursite.com/tags/Linux-C-C/"/>
    
      <category term="网络编程" scheme="http://yoursite.com/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>大整数运算</title>
    <link href="http://yoursite.com/2019/11/04/%E5%A4%A7%E6%95%B4%E6%95%B0%E8%BF%90%E7%AE%97/"/>
    <id>http://yoursite.com/2019/11/04/大整数运算/</id>
    <published>2019-11-04T12:06:49.000Z</published>
    <updated>2019-11-04T13:39:15.702Z</updated>
    
    <content type="html"><![CDATA[<p>简介： 常用的大整数运算</p><a id="more"></a><h1 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h1><p>&emsp;&emsp;用string存储数组，将其倒着存，使得最高位在vector的末尾，这是为了方便进位</p><h1 id="加法"><a href="#加法" class="headerlink" title="加法"></a>加法</h1><p>&emsp;&emsp;注意最后可能t不为0，要将其存进去</p><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">vector</span>&lt;<span class="keyword">int</span>&gt; add(<span class="keyword">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;a, <span class="keyword">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;b)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">vector</span>&lt;<span class="keyword">int</span>&gt; C;</span><br><span class="line"><span class="keyword">int</span> t=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;a.<span class="keyword">size</span>()||i&lt;b.<span class="keyword">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(i&lt;a.<span class="keyword">size</span>())t+=a[i];</span><br><span class="line"><span class="keyword">if</span>(i&lt;b.<span class="keyword">size</span>())t+=b[i];</span><br><span class="line">C.push_back(t%10);</span><br><span class="line">t/=<span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(t)C.push_back(t);</span><br><span class="line"><span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="减法"><a href="#减法" class="headerlink" title="减法"></a>减法</h1><p>&emsp;&emsp;主要存模的时候要先加10再对10取模，因为t可能是负数，在c++中，比如-2%10=-2。<br>&emsp;&emsp;最后得到结果可能含有前导0，要pop_back</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="built_in">int</span>&gt; sub(vector&lt;<span class="built_in">int</span>&gt; &amp;a, vector&lt;<span class="built_in">int</span>&gt; &amp;b)</span><br><span class="line">&#123;</span><br><span class="line">vector&lt;<span class="built_in">int</span>&gt; C;</span><br><span class="line"><span class="built_in">int</span> t=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>; i&lt;a.size(); i++)</span><br><span class="line">&#123;</span><br><span class="line">t=a[i]-t;     <span class="comment">//要减去借位 </span></span><br><span class="line"> <span class="keyword">if</span>(i&lt;b.size())t-=b[i];</span><br><span class="line">C.push_back((t+<span class="number">10</span>)%<span class="number">10</span>);</span><br><span class="line"><span class="keyword">if</span>(t&lt;<span class="number">0</span>)t=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span>t=<span class="number">0</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(C.size()&gt;<span class="number">1</span> &amp;&amp; C.back()==<span class="number">0</span>)C.pop_back();</span><br><span class="line"><span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="乘法"><a href="#乘法" class="headerlink" title="乘法"></a>乘法</h1><p>&emsp;&emsp;不断相乘取模即可</p><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">vector</span>&lt;<span class="keyword">int</span>&gt; mul(<span class="keyword">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;a, <span class="keyword">int</span> b)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">vector</span>&lt;<span class="keyword">int</span>&gt; C;</span><br><span class="line"><span class="keyword">int</span> t=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;a.<span class="keyword">size</span>()||t; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(i&lt;a.<span class="keyword">size</span>())t+=b*a[i];</span><br><span class="line">C.push_back(t%10);</span><br><span class="line">t/=<span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="除法"><a href="#除法" class="headerlink" title="除法"></a>除法</h1><p>&emsp;&emsp;此时需要倒着遍历，因为除法运算需要从最高为开始除，最后需要把结果倒置并去除前置0。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="built_in">int</span>&gt; div(vector&lt;<span class="built_in">int</span>&gt; &amp;a, <span class="built_in">int</span> b, <span class="built_in">int</span> &amp;r)</span><br><span class="line">&#123;</span><br><span class="line">vector&lt;<span class="built_in">int</span>&gt; C;</span><br><span class="line">r=<span class="number">0</span>;</span><br><span class="line">for(<span class="built_in">int</span> i=a.size<span class="literal">()</span>-<span class="number">1</span>; i&gt;=<span class="number">0</span>; --i)</span><br><span class="line">&#123;</span><br><span class="line">r=r*<span class="number">10</span>+a<span class="literal">[<span class="identifier">i</span>]</span>;</span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">C</span>.</span></span>push<span class="constructor">_back(<span class="params">r</span><span class="operator">/</span><span class="params">b</span>)</span>;</span><br><span class="line">r=r%b;</span><br><span class="line">&#125;</span><br><span class="line">reverse(<span class="module-access"><span class="module"><span class="identifier">C</span>.</span></span><span class="keyword">begin</span><span class="literal">()</span>, <span class="module-access"><span class="module"><span class="identifier">C</span>.</span></span><span class="keyword">end</span><span class="literal">()</span>);</span><br><span class="line"><span class="keyword">while</span>(<span class="module-access"><span class="module"><span class="identifier">C</span>.</span></span>size<span class="literal">()</span>&gt;<span class="number">1</span><span class="operator"> &amp;&amp; </span><span class="module-access"><span class="module"><span class="identifier">C</span>.</span></span>back<span class="literal">()</span>==<span class="number">0</span>)<span class="module-access"><span class="module"><span class="identifier">C</span>.</span></span>pop<span class="constructor">_back()</span>;</span><br><span class="line">return C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;简介： 常用的大整数运算&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法笔记" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
</feed>

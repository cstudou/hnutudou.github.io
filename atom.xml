<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Tudou</title>
  
  <subtitle>study &amp; life</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-11-04T13:39:15.702Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Tudou</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>大整数运算</title>
    <link href="http://yoursite.com/2019/11/04/%E5%A4%A7%E6%95%B4%E6%95%B0%E8%BF%90%E7%AE%97/"/>
    <id>http://yoursite.com/2019/11/04/大整数运算/</id>
    <published>2019-11-04T12:06:49.000Z</published>
    <updated>2019-11-04T13:39:15.702Z</updated>
    
    <content type="html"><![CDATA[<p>简介： 常用的大整数运算</p><a id="more"></a><h1 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h1><p>&emsp;&emsp;用string存储数组，将其倒着存，使得最高位在vector的末尾，这是为了方便进位</p><h1 id="加法"><a href="#加法" class="headerlink" title="加法"></a>加法</h1><p>&emsp;&emsp;注意最后可能t不为0，要将其存进去</p><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">vector</span>&lt;<span class="keyword">int</span>&gt; add(<span class="keyword">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;a, <span class="keyword">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;b)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">vector</span>&lt;<span class="keyword">int</span>&gt; C;</span><br><span class="line"><span class="keyword">int</span> t=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;a.<span class="keyword">size</span>()||i&lt;b.<span class="keyword">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(i&lt;a.<span class="keyword">size</span>())t+=a[i];</span><br><span class="line"><span class="keyword">if</span>(i&lt;b.<span class="keyword">size</span>())t+=b[i];</span><br><span class="line">C.push_back(t%10);</span><br><span class="line">t/=<span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(t)C.push_back(t);</span><br><span class="line"><span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="减法"><a href="#减法" class="headerlink" title="减法"></a>减法</h1><p>&emsp;&emsp;主要存模的时候要先加10再对10取模，因为t可能是负数，在c++中，比如-2%10=-2。<br>&emsp;&emsp;最后得到结果可能含有前导0，要pop_back</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="built_in">int</span>&gt; sub(vector&lt;<span class="built_in">int</span>&gt; &amp;a, vector&lt;<span class="built_in">int</span>&gt; &amp;b)</span><br><span class="line">&#123;</span><br><span class="line">vector&lt;<span class="built_in">int</span>&gt; C;</span><br><span class="line"><span class="built_in">int</span> t=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>; i&lt;a.size(); i++)</span><br><span class="line">&#123;</span><br><span class="line">t=a[i]-t;     <span class="comment">//要减去借位 </span></span><br><span class="line"> <span class="keyword">if</span>(i&lt;b.size())t-=b[i];</span><br><span class="line">C.push_back((t+<span class="number">10</span>)%<span class="number">10</span>);</span><br><span class="line"><span class="keyword">if</span>(t&lt;<span class="number">0</span>)t=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span>t=<span class="number">0</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(C.size()&gt;<span class="number">1</span> &amp;&amp; C.back()==<span class="number">0</span>)C.pop_back();</span><br><span class="line"><span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="乘法"><a href="#乘法" class="headerlink" title="乘法"></a>乘法</h1><p>&emsp;&emsp;不断相乘取模即可</p><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">vector</span>&lt;<span class="keyword">int</span>&gt; mul(<span class="keyword">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;a, <span class="keyword">int</span> b)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">vector</span>&lt;<span class="keyword">int</span>&gt; C;</span><br><span class="line"><span class="keyword">int</span> t=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;a.<span class="keyword">size</span>()||t; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(i&lt;a.<span class="keyword">size</span>())t+=b*a[i];</span><br><span class="line">C.push_back(t%10);</span><br><span class="line">t/=<span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="除法"><a href="#除法" class="headerlink" title="除法"></a>除法</h1><p>&emsp;&emsp;此时需要倒着遍历，因为除法运算需要从最高为开始除，最后需要把结果倒置并去除前置0。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="built_in">int</span>&gt; div(vector&lt;<span class="built_in">int</span>&gt; &amp;a, <span class="built_in">int</span> b, <span class="built_in">int</span> &amp;r)</span><br><span class="line">&#123;</span><br><span class="line">vector&lt;<span class="built_in">int</span>&gt; C;</span><br><span class="line">r=<span class="number">0</span>;</span><br><span class="line">for(<span class="built_in">int</span> i=a.size<span class="literal">()</span>-<span class="number">1</span>; i&gt;=<span class="number">0</span>; --i)</span><br><span class="line">&#123;</span><br><span class="line">r=r*<span class="number">10</span>+a<span class="literal">[<span class="identifier">i</span>]</span>;</span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">C</span>.</span></span>push<span class="constructor">_back(<span class="params">r</span><span class="operator">/</span><span class="params">b</span>)</span>;</span><br><span class="line">r=r%b;</span><br><span class="line">&#125;</span><br><span class="line">reverse(<span class="module-access"><span class="module"><span class="identifier">C</span>.</span></span><span class="keyword">begin</span><span class="literal">()</span>, <span class="module-access"><span class="module"><span class="identifier">C</span>.</span></span><span class="keyword">end</span><span class="literal">()</span>);</span><br><span class="line"><span class="keyword">while</span>(<span class="module-access"><span class="module"><span class="identifier">C</span>.</span></span>size<span class="literal">()</span>&gt;<span class="number">1</span><span class="operator"> &amp;&amp; </span><span class="module-access"><span class="module"><span class="identifier">C</span>.</span></span>back<span class="literal">()</span>==<span class="number">0</span>)<span class="module-access"><span class="module"><span class="identifier">C</span>.</span></span>pop<span class="constructor">_back()</span>;</span><br><span class="line">return C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;简介： 常用的大整数运算&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法笔记" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>排序算法</title>
    <link href="http://yoursite.com/2019/11/04/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2019/11/04/排序算法/</id>
    <published>2019-11-04T12:06:49.000Z</published>
    <updated>2019-11-04T13:11:02.668Z</updated>
    
    <content type="html"><![CDATA[<p>简介： 常用的排序算法</p><a id="more"></a><h1 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h1><p>&emsp;&emsp;每次从未排序序列中选最小的一个数插入到前面已排序序列</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*          选择排序   1&lt;=i&lt;=n</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">#<span class="keyword">if</span> <span class="number">0</span></span><br><span class="line"><span class="built_in">int</span> A&#123;maxn&#125;, n; </span><br><span class="line"><span class="built_in">void</span> SelectSort()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">1</span>; i&lt;=n; ++i)        <span class="comment">//进行n趟操作 </span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">int</span> k=i;</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">int</span> j=i; j&lt;=n; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(A[k]&gt;A[j])             <span class="comment">//比前面大，记录下来 </span></span><br><span class="line">&#123;</span><br><span class="line">k=j;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line">swap(A[k], A[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h1><p>&emsp;&emsp;遍历数组，将遍历到的值插入前面已排序序列中</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*          插入排序   1&lt;=i&lt;=n</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> A[maxn], n;</span><br><span class="line"><span class="built_in">void</span> InsertSort()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">2</span>; i&lt;=n; ++i)        <span class="comment">//进行n-1趟查找 </span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">int</span> temp=A[i],j=i;</span><br><span class="line"><span class="keyword">while</span>(A[j<span class="number">-1</span>]&gt;temp &amp;&amp; j&gt;<span class="number">1</span>)   <span class="comment">//只要temp小于前面一个元素 </span></span><br><span class="line">&#123;</span><br><span class="line">A[j]=A[j<span class="number">-1</span>];           <span class="comment">//覆盖</span></span><br><span class="line">j--; </span><br><span class="line">&#125;</span><br><span class="line">A[j]=temp;         <span class="comment">//插入 </span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><p>&emsp;&emsp;冒n-1趟，每次把最小的/最大的冒泡的顶端</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*          冒泡排序   0&lt;i&lt;n</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> A[maxn], n;</span><br><span class="line"><span class="built_in">void</span> BubbleSort()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>; i&lt;n<span class="number">-1</span>; ++i)          <span class="comment">//n-1次排序 </span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">bool</span> flag =<span class="literal">false</span>;          <span class="comment">//只要某一趟没有交换元素，则说明排序完成 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">int</span> j=<span class="number">0</span>; j&lt;n-i<span class="number">-1</span>; ++j)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(A[j+<span class="number">1</span>] &lt; A[j])</span><br><span class="line">&#123;</span><br><span class="line">swap(A[j], A[j+<span class="number">1</span>]);</span><br><span class="line">flag=<span class="literal">true</span>;        <span class="comment">//交换了元素 </span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(!flag)<span class="keyword">break</span>; </span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><p>&emsp;&emsp;把区间分为若干等份，每次取n等份排序，到最后一次的时候序列就为有序序列</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*          归并排序   0&lt;i&lt;n         </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">void</span> merge(<span class="built_in">int</span> s[], <span class="built_in">int</span> l, <span class="built_in">int</span> r)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(l&gt;=r)<span class="keyword">return</span> ;   <span class="comment">//当l=r时没必要再排序 </span></span><br><span class="line"><span class="built_in">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">merge(s,l,mid);</span><br><span class="line">merge(s,mid+<span class="number">1</span>,r);</span><br><span class="line"><span class="built_in">int</span> k=<span class="number">0</span>,i=l,j=mid+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(i&lt;=mid &amp;&amp; j&lt;=r)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(s[i]&lt;s[j])temp[k++]=s[i++];</span><br><span class="line"><span class="keyword">else</span>temp[k++]=s[j++];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(i&lt;=mid)temp[k++]=s[i++];</span><br><span class="line"><span class="keyword">while</span>(j&lt;=r)temp[k++]=s[j++];</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">int</span> i=l,j=<span class="number">0</span>; i&lt;=r; i++,j++)s[i]=temp[j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><p>&emsp;&emsp;每次选取一个主元，一次排序后主元左边的数都小于等于它，右边的数都大于等于它</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*          快速排序   0&lt;i&lt;n         </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">void quick<span class="constructor">_sort(<span class="params">int</span> <span class="params">q</span>[], <span class="params">int</span> <span class="params">l</span>, <span class="params">int</span> <span class="params">r</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&gt;=r)    return ;<span class="comment">//只有一个数不用再排序</span></span><br><span class="line">    <span class="built_in">int</span> i = l-<span class="number">1</span>,j = r+<span class="number">1</span>,x = q<span class="literal">[<span class="identifier">l</span>+<span class="identifier">r</span>&gt;&gt;<span class="number">1</span>]</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; j) <span class="comment">//最后i和j会相差1</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">do</span> i++; <span class="keyword">while</span>(q<span class="literal">[<span class="identifier">i</span>]</span> &lt; x);</span><br><span class="line">        <span class="keyword">do</span> j--; <span class="keyword">while</span>(q<span class="literal">[<span class="identifier">j</span>]</span> &gt; x);</span><br><span class="line">        <span class="keyword">if</span>(i&lt;j) swap(q<span class="literal">[<span class="identifier">i</span>]</span>, q<span class="literal">[<span class="identifier">j</span>]</span>);     <span class="comment">//因为最后确定位置的数不知道在哪，所以两边都要递归</span></span><br><span class="line">    &#125;</span><br><span class="line">    quick<span class="constructor">_sort(<span class="params">q</span>, <span class="params">l</span>, <span class="params">j</span>)</span>;               <span class="comment">//不用i的原因是，比如 1，2两个数的情况会出错 分为两边，一边小于等于一边大于等于 --------j-i-1----------- </span></span><br><span class="line">                                <span class="comment">//可以这样改：用i的时候x不能为左边界，用j的时候x不能为有边界，改q[l+r&gt;&gt;1]即可</span></span><br><span class="line">    quick<span class="constructor">_sort(<span class="params">q</span>, <span class="params">j</span>+1, <span class="params">r</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h1><p>&emsp;&emsp;类似于数，每次都用down或者up操作不断上升/下降，直到整个堆有序，此时每个父节点都大于/小于它的子节点</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">100010</span>;</span><br><span class="line"><span class="keyword">int</span> heap[maxn],size;</span><br><span class="line"><span class="keyword">int</span> m,n;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">down</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> t=u;</span><br><span class="line"><span class="keyword">if</span>(u*<span class="number">2</span>&lt;=size &amp;&amp; heap[u*<span class="number">2</span>]&lt;heap[t])     t=u*<span class="number">2</span>;  <span class="comment">//有左儿子并且小于它 </span></span><br><span class="line"><span class="keyword">if</span>(u*<span class="number">2</span>+<span class="number">1</span>&lt;=size &amp;&amp; heap[u*<span class="number">2</span>+<span class="number">1</span>]&lt;heap[t])t=u*<span class="number">2</span>+<span class="number">1</span>; <span class="comment">//有右儿子并且小于它 </span></span><br><span class="line"><span class="keyword">if</span>(u!=t)</span><br><span class="line">&#123;</span><br><span class="line">swap(heap[t], heap[u]);</span><br><span class="line">down(t);            <span class="comment">//递归dowm下去 </span></span><br><span class="line"> &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">up</span><span class="params">(<span class="keyword">int</span> u)</span>   <span class="comment">//插入使用 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(u/<span class="number">2</span> &amp;&amp; heap[u/<span class="number">2</span>]&gt;heap[u])  <span class="comment">//有祖先并且祖先比它大 </span></span><br><span class="line">&#123;</span><br><span class="line">swap(heap[u], heap[u/<span class="number">2</span>]);</span><br><span class="line">u/=<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)<span class="built_in">cin</span>&gt;&gt;heap[i];</span><br><span class="line">size=n;        <span class="comment">//size指向最后一个元素 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=n/<span class="number">2</span>; i; --i)down(i);          <span class="comment">//利用二叉树性质，最后一个父节点开始down </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=<span class="number">6</span>; i++)<span class="built_in">cout</span>&lt;&lt;heap[i]&lt;&lt;<span class="string">' '</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">while</span>(m--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;heap[<span class="number">1</span>]&lt;&lt;<span class="string">" "</span>; </span><br><span class="line">heap[<span class="number">1</span>]=heap[size];      <span class="comment">//删掉堆顶元素 </span></span><br><span class="line">size--;    <span class="comment">//删掉元素</span></span><br><span class="line">down(<span class="number">1</span>); </span><br><span class="line"> &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;简介： 常用的排序算法&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法笔记" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>查找算法</title>
    <link href="http://yoursite.com/2019/11/04/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2019/11/04/查找算法/</id>
    <published>2019-11-04T12:06:49.000Z</published>
    <updated>2019-11-04T12:15:41.887Z</updated>
    
    <content type="html"><![CDATA[<p>简介： 常用的查找算法</p><a id="more"></a><h1 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h1><p>&emsp;&emsp;每次去中点mid，然后将区间分为两部分</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">*二分查找  区间为【<span class="built_in">left</span>，<span class="built_in">right</span>】，均为闭区间，传入的初始值为【<span class="number">0</span>，<span class="built_in">n</span>-<span class="number">1</span>】 </span><br><span class="line">*/ </span><br><span class="line"><span class="built_in">int</span> BinarySearch(<span class="built_in">int</span> A[], <span class="built_in">int</span> <span class="built_in">left</span>, <span class="built_in">int</span> <span class="built_in">right</span>, <span class="built_in">int</span> x)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">int</span> <span class="built_in">mid</span>;</span><br><span class="line">while(<span class="built_in">left</span>&lt;=<span class="built_in">right</span>)             //此处为&lt;= </span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">mid</span>=(<span class="built_in">left</span>+<span class="built_in">right</span>)/<span class="number">2</span>;</span><br><span class="line"><span class="built_in">if</span>(A[<span class="built_in">mid</span>]==x)</span><br><span class="line">&#123;</span><br><span class="line">return <span class="built_in">mid</span>;</span><br><span class="line">&#125;</span><br><span class="line">else <span class="built_in">if</span>(A[<span class="built_in">mid</span>]&gt;x)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">right</span>=<span class="built_in">mid</span>-<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">left</span>=<span class="built_in">mid</span>+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return -<span class="number">1</span>;              //查找失败 </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二分查找-将区间分为-left-mid-1-mid-right"><a href="#二分查找-将区间分为-left-mid-1-mid-right" class="headerlink" title="二分查找(将区间分为[left,mid-1],[mid, right])"></a>二分查找(将区间分为[left,mid-1],[mid, right])</h1><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 区间[l, r]被划分成[l, mid - 1]和[mid, r]时使用</span></span><br><span class="line"><span class="built_in">int</span> bsearch_1(<span class="built_in">int</span> l, <span class="built_in">int</span> r)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>(l&lt;r)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">int</span> mid=l+r+<span class="number">1</span>&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(check(mid))l=mid;</span><br><span class="line"><span class="keyword">else</span> r=mid<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二分查找-将区间分为-left-mid-mid-1-right"><a href="#二分查找-将区间分为-left-mid-mid-1-right" class="headerlink" title="二分查找(将区间分为[left, mid],[mid+1, right])"></a>二分查找(将区间分为[left, mid],[mid+1, right])</h1><p>&emsp;&emsp;此时计算mid时需要取left+right&gt;&gt;1。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用</span></span><br><span class="line"><span class="built_in">int</span> bsearch_1(<span class="built_in">int</span> l, <span class="built_in">int</span> r)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>(l&lt;r)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(check(mid))r=mid;</span><br><span class="line"><span class="keyword">else</span> l=mid+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="浮点数二分"><a href="#浮点数二分" class="headerlink" title="浮点数二分"></a>浮点数二分</h1><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//浮点数二分</span></span><br><span class="line"><span class="built_in">double</span> bsearch_1(<span class="built_in">double</span> l, <span class="built_in">double</span> r)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">const</span> <span class="built_in">double</span> eps=<span class="number">1e-8</span>;</span><br><span class="line"><span class="keyword">while</span>(r-l&gt;eps)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">double</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(check(mid))r=mid;</span><br><span class="line"><span class="keyword">else</span>l=mid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;简介： 常用的查找算法&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法笔记" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>echo服务器</title>
    <link href="http://yoursite.com/2019/11/04/echo%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <id>http://yoursite.com/2019/11/04/echo服务器/</id>
    <published>2019-11-04T11:26:52.000Z</published>
    <updated>2019-11-04T11:52:29.698Z</updated>
    
    <content type="html"><![CDATA[<p>简介： echo客户端&amp;服务器</p><a id="more"></a><h1 id="echo客户端"><a href="#echo客户端" class="headerlink" title="echo客户端"></a>echo客户端</h1><h2 id="main函数-amp-open-clientfd函数"><a href="#main函数-amp-open-clientfd函数" class="headerlink" title="main函数 &amp; open_clientfd函数"></a>main函数 &amp; open_clientfd函数</h2><p>&emsp;&emsp;echo客户端输入两个参数，一个是服务器的ip，一个是服务器的端口，将ip与端口传入open_clientfd函数获取一个已连接描述符。在和服务器连接以后，客户端应该进入一个循环，反复从标准输入读取文本行，发送文本行给服务器，从服务器读取回送的行，并输出结果到标准输出。当fgets在标准输入上遇到EOF时，或者因为用户在键盘上输入ctrl+D，或者在遇到一个重定向的输入文件中用尽了所有的文本行时，循环截止。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">open_clientfd</span><span class="params">(<span class="keyword">char</span> *hostname, <span class="keyword">char</span> *port)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> clientfd;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">addrinfo</span> *<span class="title">p</span>,*<span class="title">listp</span>,<span class="title">hints</span>;</span></span><br><span class="line"><span class="built_in">memset</span>(&amp;hints, <span class="number">0</span>, <span class="keyword">sizeof</span>(struct addrinfo));</span><br><span class="line">hints.ai_socktype = SOCK_STREAM;</span><br><span class="line">hints.ai_flags = AI_NUMERICSERV | AI_ADDRCONFIG | AI_PASSIVE;</span><br><span class="line"><span class="comment">//ai_addrconfig 只有当主机配置为ipv4时，getaddrinfo返回ipv4</span></span><br><span class="line"><span class="comment">//ai_passive 使得getaddrinfo默认返回套接字地址</span></span><br><span class="line"><span class="comment">//ai_numericserv 强制第二个参数service默认为端口号 </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">getaddrinfo(hostname, port, &amp;hints, &amp;listp);</span><br><span class="line"><span class="keyword">for</span>(p=listp; p; p=p-&gt;ai_next)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>((clientfd = socket(p-&gt;ai_family, p-&gt;ai_socktype, p-&gt;ai_protocol)) &lt; <span class="number">0</span>)<span class="keyword">continue</span>;</span><br><span class="line"><span class="comment">// 通过connect建立与服务器的连接</span></span><br><span class="line"><span class="comment">// int connect(int clientfd, const struct sockaddr *addr, socklen_t adddrlen)</span></span><br><span class="line"><span class="keyword">if</span>(connect(clientfd, p-&gt;ai_addr, p-&gt;ai_addrlen) != <span class="number">-1</span>)<span class="keyword">break</span>;</span><br><span class="line">close(clientfd); </span><br><span class="line">&#125;</span><br><span class="line">freeaddrinfo(listp);</span><br><span class="line"><span class="keyword">if</span>(!p)<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> clientfd;      <span class="comment">//客户端不需要监听 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> clientfd;</span><br><span class="line"><span class="keyword">char</span> *host, *port, buf[MAXNLINE];</span><br><span class="line"><span class="keyword">rio_t</span> rio;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(argc != <span class="number">3</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"usage: %s &lt;host&gt; &lt;port&gt;\n"</span>, argv[<span class="number">0</span>]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">host = argv[<span class="number">1</span>], port = argv[<span class="number">2</span>];</span><br><span class="line">clientfd = open_clientfd(host, port);</span><br><span class="line">rio_readinitb(&amp;rio, clientfd);</span><br><span class="line"><span class="keyword">while</span>(fgets(buf, MAXNLINE, <span class="built_in">stdin</span>) != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">rio_writen(clientfd, buf, <span class="built_in">strlen</span>(buf));</span><br><span class="line">rio_readlineb(&amp;rio, buf, MAXNLINE);  <span class="comment">//服务器写回来再让客户端读 </span></span><br><span class="line"><span class="built_in">fputs</span>(buf, <span class="built_in">stdout</span>);</span><br><span class="line">&#125;</span><br><span class="line">close(clientfd);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="rio函数"><a href="#rio函数" class="headerlink" title="rio函数"></a>rio函数</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LISTENQ 1024</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RIOBUFSIZE 1024*8</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXNLINE 1024*8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> rio_fd,rio_cnt;</span><br><span class="line"><span class="keyword">char</span> rio_buf[RIOBUFSIZE], *rio_bufptr;</span><br><span class="line">&#125;<span class="keyword">rio_t</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">ssize_t</span> rio_writen(<span class="keyword">int</span> fd, <span class="keyword">void</span> *usrbuf, <span class="keyword">size_t</span> n)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">size_t</span> nleft=n;</span><br><span class="line"><span class="keyword">size_t</span> nwritten;</span><br><span class="line"><span class="keyword">char</span> *buf = usrbuf;</span><br><span class="line"><span class="keyword">while</span>(nleft &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>((nwritten = write(fd, buf, nleft)) &lt;= <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(errno == EINTR)nwritten=<span class="number">0</span>;      <span class="comment">//中断了 </span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">nleft -= nwritten;</span><br><span class="line">buf += nwritten;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">ssize_t</span> rio_read(<span class="keyword">rio_t</span> *rp, <span class="keyword">char</span> *rc, <span class="keyword">size_t</span> n)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> cnt;</span><br><span class="line"><span class="keyword">while</span>(rp-&gt;rio_cnt &lt;= <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">rp-&gt;rio_cnt=read(rp-&gt;rio_fd, rp-&gt;rio_buf, <span class="keyword">sizeof</span>(rp-&gt;rio_buf));</span><br><span class="line"><span class="keyword">if</span>(rp-&gt;rio_cnt &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(errno != EINTR)<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(rp-&gt;rio_cnt == <span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span> rp-&gt;rio_bufptr = rp-&gt;rio_buf;</span><br><span class="line">&#125;</span><br><span class="line">cnt = n;</span><br><span class="line"><span class="keyword">if</span>(rp-&gt;rio_cnt &lt; n)cnt=rp-&gt;rio_cnt;</span><br><span class="line"><span class="built_in">memcpy</span>(rc, rp-&gt;rio_bufptr, cnt);</span><br><span class="line">rp-&gt;rio_bufptr+=cnt;</span><br><span class="line">rp-&gt;rio_cnt-=cnt;</span><br><span class="line"><span class="keyword">return</span> cnt;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">ssize_t</span> rio_readlineb(<span class="keyword">rio_t</span> *rio, <span class="keyword">void</span> *usrbuf, <span class="keyword">size_t</span> maxlen)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">char</span> *buf=usrbuf, c;</span><br><span class="line"><span class="keyword">int</span> n,rc;</span><br><span class="line"><span class="keyword">for</span>(n=<span class="number">1</span>; n&lt;maxlen; n++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>((rc = rio_read(rio, &amp;c, <span class="number">1</span>)) == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">*buf++ = c;</span><br><span class="line"><span class="keyword">if</span>(c==<span class="string">'\n'</span>)</span><br><span class="line">&#123;</span><br><span class="line">n++;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(rc == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(n==<span class="number">1</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">*buf = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> n<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rio_readinitb</span><span class="params">(<span class="keyword">rio_t</span> *rio, <span class="keyword">int</span> fd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">rio-&gt;rio_fd=fd;</span><br><span class="line">rio-&gt;rio_cnt=<span class="number">0</span>;</span><br><span class="line">rio-&gt;rio_bufptr=rio-&gt;rio_buf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="echo服务器-普通版"><a href="#echo服务器-普通版" class="headerlink" title="echo服务器(普通版)"></a>echo服务器(普通版)</h1><h2 id="main函数-amp-open-listenfd函数"><a href="#main函数-amp-open-listenfd函数" class="headerlink" title="main函数 &amp; open_listenfd函数"></a>main函数 &amp; open_listenfd函数</h2><p>&emsp;&emsp;服务器主程序，打开监听描述符，进入循环，等待一个来自客户端的连接请求，输出已连接的客户端域名和IP地址，并调用echo函数为这个客户端服务，在echo程序返回之后，主程序关闭已连接的描述符，一旦客户端和服务器都关闭了他们各自的描述符，连接终止。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">open_listenfd</span><span class="params">(<span class="keyword">char</span> *port)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">addrinfo</span> <span class="title">hints</span>,*<span class="title">p</span>,*<span class="title">listp</span>;</span></span><br><span class="line">    <span class="keyword">int</span> listenfd, optval=<span class="number">1</span>,rc;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;hints, <span class="number">0</span>, <span class="keyword">sizeof</span>(struct addrinfo));</span><br><span class="line">    hints.ai_socktype=SOCK_STREAM;</span><br><span class="line">    hints.ai_flags = AI_PASSIVE | AI_ADDRCONFIG;</span><br><span class="line">    hints.ai_flags |= AI_NUMERICSERV;</span><br><span class="line">    <span class="comment">//socket----&gt;bind----&gt;listen</span></span><br><span class="line">    getaddrinfo(<span class="literal">NULL</span>, port, &amp;hints, &amp;listp);</span><br><span class="line">   <span class="comment">// if(listp == NULL) </span></span><br><span class="line">    <span class="keyword">for</span>(p=listp; p; p=p-&gt;ai_next)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>((listenfd=socket(p-&gt;ai_family, p-&gt;ai_socktype, p-&gt;ai_protocol)) &lt; <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">       <span class="keyword">if</span>((rc= setsockopt(listenfd, SOL_SOCKET, SO_REUSEADDR, &amp; optval, <span class="keyword">sizeof</span>(<span class="keyword">int</span>))) &lt; <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, strerror(errno));</span><br><span class="line">        <span class="keyword">if</span>(bind(listenfd, p-&gt;ai_addr, p-&gt;ai_addrlen) == <span class="number">0</span>)     <span class="comment">//printf("%s\n", strerror(errno)); //break;</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">close(listenfd);</span><br><span class="line">    &#125;</span><br><span class="line">    freeaddrinfo(listp);</span><br><span class="line">    <span class="keyword">if</span>(!p)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(listen(listenfd, LISTENQ) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        close(listenfd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> listenfd;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> listenfd, connfd;</span><br><span class="line"><span class="keyword">socklen_t</span> clientlen;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_storage</span> <span class="title">clientaddr</span>;</span></span><br><span class="line"><span class="keyword">char</span> client_hostname[MAXNLINE], client_port[MAXNLINE];</span><br><span class="line"><span class="keyword">if</span>(argc != <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"usage: %s &lt;port&gt;\n"</span>, argv[<span class="number">0</span>]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">listenfd = open_listenfd(argv[<span class="number">1</span>]);</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">clientlen = <span class="keyword">sizeof</span>(clientaddr);</span><br><span class="line">connfd = accept(listenfd, (struct sockaddr *)&amp;clientaddr, &amp;clientlen);</span><br><span class="line">getnameinfo((struct sockaddr *)&amp;clientaddr, clientlen, client_hostnmae, MAXNLINE, client_port, MAXNLINE, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Connected to (%s %s)\n"</span>, client_hostname, client_port);</span><br><span class="line">echo(connfd);</span><br><span class="line">close(connfd);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="echo函数"><a href="#echo函数" class="headerlink" title="echo函数"></a>echo函数</h2><p>&emsp;&emsp;服务器调用echo函数读取从客户端传来的数据，读完以后再写回客户端让客户端读取输出。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void echo(<span class="built_in">int</span> connfd)</span><br><span class="line">&#123;</span><br><span class="line">size_t n;</span><br><span class="line"><span class="built_in">char</span> buf<span class="literal">[MAXNLINE]</span>;</span><br><span class="line">rio_t rio;</span><br><span class="line">rio<span class="constructor">_readinitb(&amp;<span class="params">rio</span>, <span class="params">connfd</span>)</span>;</span><br><span class="line"><span class="keyword">while</span>((n=rio<span class="constructor">_readlineb(&amp;<span class="params">rio</span>, <span class="params">buf</span>, MAXNLINE)</span>) != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">printf(<span class="string">"serve received %d bytes\n"</span>, (<span class="built_in">int</span>)n);</span><br><span class="line">rio<span class="constructor">_writen(<span class="params">connfd</span>, <span class="params">buf</span>, <span class="params">n</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="echo服务器-基于进程并发"><a href="#echo服务器-基于进程并发" class="headerlink" title="echo服务器(基于进程并发)"></a>echo服务器(基于进程并发)</h1><h2 id="main函数"><a href="#main函数" class="headerlink" title="main函数"></a>main函数</h2><p>&emsp;&emsp;利用SIGCHLD信号，在一个进程终止或者停止时，将SIGCHLD信号发送给其父进程，按系统默认将忽略此信号。建立连接后，创建一个子进程，再子进程中进行操作，最后由父进程回收子进程资源。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> listenfd, connfd;</span><br><span class="line"><span class="keyword">socklen_t</span> clientlen;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_storage</span> <span class="title">clientaddr</span>;</span></span><br><span class="line"><span class="keyword">if</span>(argc != <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"usage: %s &lt;port&gt;\n"</span>, argv[<span class="number">0</span>]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">listenfd = open_listenfd(argv[<span class="number">1</span>]);</span><br><span class="line">signal(SIGCHLD, sigchld_handler);  <span class="comment">//signal（参数1，参数2） 参数1：我们要进行处理的信号。参数2：我们处理的方式</span></span><br><span class="line"><span class="comment">//  在一个进程终止或者停止时，将SIGCHLD信号发送给其父进程，按系统默认将忽略此信号</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">clientlen = <span class="keyword">sizeof</span>(struct sockaddr_storage);</span><br><span class="line">connfd = accept(listenfd, (struct sockaddr *)&amp; clientaddr, &amp;clientlen);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(fork() == <span class="number">0</span>)     <span class="comment">//子进程 </span></span><br><span class="line">&#123;</span><br><span class="line">close(listenfd);       <span class="comment">//关闭副本中的监听描述符 </span></span><br><span class="line">echo(connfd);</span><br><span class="line">close(connfd);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>); </span><br><span class="line">&#125;</span><br><span class="line">close(connfd);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="sigchld-handler函数"><a href="#sigchld-handler函数" class="headerlink" title="sigchld_handler函数"></a>sigchld_handler函数</h2><p>&emsp;&emsp;当能回收到子进程时，就一直循环，若退出，说明子进程以及全部回收完毕。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">void</span> sigchld_handler(<span class="built_in">int</span> sig)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>(waitpid(<span class="number">-1</span>, <span class="number">0</span>, WNOHANG) &gt; <span class="number">0</span>) ;        <span class="comment">//-1表示回收任意子进程 </span></span><br><span class="line"><span class="comment">//正常返回回收id，，没有回收返回0，，出错返回-1</span></span><br><span class="line"><span class="keyword">return</span> ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="echo函数-1"><a href="#echo函数-1" class="headerlink" title="echo函数"></a>echo函数</h2><p>&emsp;&emsp;服务器调用echo函数读取从客户端传来的数据，读完以后再写回客户端让客户端读取输出。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void echo(<span class="built_in">int</span> connfd)</span><br><span class="line">&#123;</span><br><span class="line">size_t n;</span><br><span class="line"><span class="built_in">char</span> buf<span class="literal">[MAXNLINE]</span>;</span><br><span class="line">rio_t rio;</span><br><span class="line">rio<span class="constructor">_readinitb(&amp;<span class="params">rio</span>, <span class="params">connfd</span>)</span>;</span><br><span class="line"><span class="keyword">while</span>((n=rio<span class="constructor">_readlineb(&amp;<span class="params">rio</span>, <span class="params">buf</span>, MAXNLINE)</span>) != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">printf(<span class="string">"serve received %d bytes\n"</span>, (<span class="built_in">int</span>)n);</span><br><span class="line">rio<span class="constructor">_writen(<span class="params">connfd</span>, <span class="params">buf</span>, <span class="params">n</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="echo服务器-基于IO多路复用"><a href="#echo服务器-基于IO多路复用" class="headerlink" title="echo服务器(基于IO多路复用)"></a>echo服务器(基于IO多路复用)</h1><h2 id="main函数-1"><a href="#main函数-1" class="headerlink" title="main函数"></a>main函数</h2><p>&emsp;&emsp;利用一个read_set，其类似与一个数组，初始时使FD_SET把已连接描述符位和STDIN_FILENO位置为1，调用select函数，若FD_ISSET为true，则证明是客户端输入/服务端输入，此时再进行下一步操作,其中select函数在sys/select.h中。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> main(<span class="built_in">int</span> argc, <span class="built_in">char</span> **argv)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">int</span> listenfd, connfd;</span><br><span class="line">socklen_t clientlen;</span><br><span class="line"><span class="keyword">struct</span> sockaddr_storage clientaddr;</span><br><span class="line">fd_set read_set, ready_set;</span><br><span class="line"><span class="keyword">if</span>(argc!=<span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line">fprintf(stderr, <span class="string">"usage: %s &lt;port&gt;\n"</span>, argv<span class="literal">[<span class="number">0</span>]</span>);</span><br><span class="line">exit(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">listenfd = <span class="keyword">open</span><span class="constructor">_listen(<span class="params">argv</span>[1])</span>;</span><br><span class="line"><span class="constructor">FD_ZERO(&amp;<span class="params">read_set</span>)</span></span><br><span class="line"><span class="comment">// stdin类型为 FILE*</span></span><br><span class="line">    <span class="comment">//   STDIN_FILENO类型为 int</span></span><br><span class="line">    <span class="comment">// STDIN_FILENO    0    -----  STDOUT_FILENO   1  -----  STDERR_FILENO   2</span></span><br><span class="line"><span class="constructor">FD_SET(STDIN_FILENO, &amp;<span class="params">read_set</span>)</span>;</span><br><span class="line"><span class="constructor">FD_SET(LISTENFD, &amp;<span class="params">readset</span>)</span>;          <span class="comment">//把listenfd与标准输入位置为1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">ready_set = read_set;</span><br><span class="line">select(listenfd+<span class="number">1</span>, &amp;ready_set, NULL, NULL, NULL);</span><br><span class="line"><span class="keyword">if</span>(<span class="constructor">FD_ISSET(STDIN_FILENO, &amp;<span class="params">ready_set</span>)</span>)</span><br><span class="line">&#123;</span><br><span class="line">command<span class="literal">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(<span class="constructor">FD_ISSET(<span class="params">listenfd</span>, &amp;<span class="params">ready_set</span>)</span>)</span><br><span class="line">&#123;</span><br><span class="line">clientlen=sizeof(<span class="keyword">struct</span> sockaddr_storage);</span><br><span class="line">connfd=accept(listenfd, (<span class="keyword">struct</span> sockaddr*)&amp; clientaddr, &amp;clientlen);</span><br><span class="line">echo(connfd);</span><br><span class="line">close(connfd);</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="command函数"><a href="#command函数" class="headerlink" title="command函数"></a>command函数</h2><p>&emsp;&emsp;若为服务端输入，调用command函数，读取终端输入的字符串。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void command()   <span class="regexp">//</span>当STDIN_FILENO为<span class="number">1</span>时，会读取输入 </span><br><span class="line">&#123;</span><br><span class="line">char buf[MAXNLINE];</span><br><span class="line"><span class="keyword">if</span>(fgets(buf, MAXNLINE, stdin) != NULL)</span><br><span class="line">&#123;</span><br><span class="line">printf(<span class="string">"%s"</span>, buf);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span><span class="keyword">exit</span>(<span class="number">0</span>);       <span class="regexp">//</span>EOF,什么都没有读到 </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="echo函数-2"><a href="#echo函数-2" class="headerlink" title="echo函数"></a>echo函数</h2><p>&emsp;&emsp;服务器调用echo函数读取从客户端传来的数据，读完以后再写回客户端让客户端读取输出。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void echo(<span class="built_in">int</span> connfd)</span><br><span class="line">&#123;</span><br><span class="line">size_t n;</span><br><span class="line"><span class="built_in">char</span> buf<span class="literal">[MAXNLINE]</span>;</span><br><span class="line">rio_t rio;</span><br><span class="line">rio<span class="constructor">_readinitb(&amp;<span class="params">rio</span>, <span class="params">connfd</span>)</span>;</span><br><span class="line"><span class="keyword">while</span>((n=rio<span class="constructor">_readlineb(&amp;<span class="params">rio</span>, <span class="params">buf</span>, MAXNLINE)</span>) != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">printf(<span class="string">"serve received %d bytes\n"</span>, (<span class="built_in">int</span>)n);</span><br><span class="line">rio<span class="constructor">_writen(<span class="params">connfd</span>, <span class="params">buf</span>, <span class="params">n</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;简介： echo客户端&amp;amp;服务器&lt;/p&gt;
    
    </summary>
    
    
      <category term="csapp" scheme="http://yoursite.com/categories/csapp/"/>
    
    
      <category term="Linux C/C++" scheme="http://yoursite.com/tags/Linux-C-C/"/>
    
      <category term="网络编程" scheme="http://yoursite.com/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Tiny Web</title>
    <link href="http://yoursite.com/2019/11/04/Tiny%20Web/"/>
    <id>http://yoursite.com/2019/11/04/Tiny Web/</id>
    <published>2019-11-04T09:21:07.000Z</published>
    <updated>2019-11-04T11:52:43.708Z</updated>
    
    <content type="html"><![CDATA[<p>简介： Tiny Web 项目 </p><a id="more"></a><h1 id="客户端-服务器编程模型"><a href="#客户端-服务器编程模型" class="headerlink" title="客户端-服务器编程模型"></a>客户端-服务器编程模型</h1><p>&emsp;&emsp;客户端-服务器编程模型是一个典型的进程间通信模型。客户端进程和服务器进程通常分处两个不同的主机，如下图所示，客户端发送请求给服务器，服务器从本地资源库中查找需要的资源，然后发送响应给客户端，最后客户端（通常是浏览器）处理这个响应，把结果显示在浏览器上。<br><img src="https://cy-pic.kuaizhan.com/g3/16/84/727b-027a-4fe5-885c-5e3c480ca81200?sign=3d85ce18f45e8dd3544935e1884fddaa&t=1572860741" alt=""></p><p>&emsp;&emsp;这个过程看起来很简单，但是我们需要深入具体的实现细节。我们知道，TCP是基于连接的，需要先建立连接才能互相通信。在Linux中，socket为我们提供了方便的解决方案。每一对网络连接称为一个socket对，包括两个端点的socket地址，表示如下：<strong>(cliaddr : cliport, servaddr : servport)</strong></p><h1 id="C-S流程图"><a href="#C-S流程图" class="headerlink" title="C/S流程图"></a>C/S流程图</h1><p><img src="https://cy-pic.kuaizhan.com/g3/f0/06/7e7f-cec2-42d4-bf82-0b6eb453137992?sign=5af41daccf2b93eeda432cd7ede0a2b4&t=1572860706" alt=""><br>&emsp;&emsp;服务器调用socket函数获取一个socket，然后调用bind函数绑定本机的IP地址和端口，再调用listen函数开启监听，最后调用accept函数等待直到有客户端发起连接。</p><p>&emsp;&emsp;另一方面，客户端调用socket函数获取一个socket，然后调用connect函数向指定服务器发起连接请求，当连接成功或出现错误后返回。若连接成功，服务器端的accept函数也会成功返回，返回另一个已连接的socket（不是最初调用socket函数得到的socket），该socket可以直接用于与客户端通信。而服务器最初的那个socket可以继续循环调用accept函数，等待下一次连接的到来。</p><p>&emsp;&emsp;连接成功后，无论是客户端还是服务器，只要向socket读写数据就可以实现与对方socket的通信。图中rio_readlineb和rio_written是作者封装的I/O读写函数，与Linux系统提供的read和write作用基本相同。</p><p>&emsp;&emsp;客户端关闭连接时会发送一个EOF到服务器，服务器读取后关闭连接，进入下一个循环。这里面用到的所有Linux网络编程接口都定义在&lt;sys/socket.h&gt;头文件中。</p><h1 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h1><h2 id="HTTP-请求"><a href="#HTTP-请求" class="headerlink" title="HTTP 请求"></a>HTTP 请求</h2><p>&emsp;&emsp;一个HTTP请求：一个请求行(request line) 后面跟随0个或多个请求报头(request header), 再跟随一个空的文本行来终止报头。</p><p>&emsp;&emsp;请求行： <code>&lt;method&gt; &lt;uri&gt; &lt;version&gt;</code></p><p>&emsp;&emsp;请求报头：<code>&lt;header name&gt; : &lt;header data&gt;</code> 为服务器提供了额外的信息，例如浏览器的版本类型</p><h2 id="HTTP响应"><a href="#HTTP响应" class="headerlink" title="HTTP响应"></a>HTTP响应</h2><p>&emsp;&emsp;一个HTTP响应：一个响应行(response line) 后面跟随0个或多个响应报头(response header)，再跟随一个空的文本行来终止报头，最后跟随一个响应主体(response body)。</p><h1 id="服务动态内容"><a href="#服务动态内容" class="headerlink" title="服务动态内容"></a>服务动态内容</h1><h2 id="客户端如何将程序参数传递给服务器"><a href="#客户端如何将程序参数传递给服务器" class="headerlink" title="客户端如何将程序参数传递给服务器"></a>客户端如何将程序参数传递给服务器</h2><p>&emsp;&emsp;GET请求的参数在URI中传递，“?”字符分隔了文件名和参数，每个参数都用一个”&amp;”分隔开，参数中不允许有空格，必须用字符串“%20”来表示。</p><h2 id="服务器如何将参数传递给子进程"><a href="#服务器如何将参数传递给子进程" class="headerlink" title="服务器如何将参数传递给子进程"></a>服务器如何将参数传递给子进程</h2><pre><code>GET /cgi-bin/adder?123&amp;456 HTTP/1.1</code></pre><p>&emsp;&emsp;它调用 fork 来创建一个子进程，并调用 execve 在子进程的上下文中执行 /cgi-bin/adder 程序。</p><p>&emsp;&emsp;在调用 execve 之前，子进程将CGI环境变量 QUERY_STRING 设置为”123&amp;456”， adder 程序在运行时可以用unix getenv 函数来引用它。</p><h2 id="服务器如何将其他信息传递给子进程"><a href="#服务器如何将其他信息传递给子进程" class="headerlink" title="服务器如何将其他信息传递给子进程"></a>服务器如何将其他信息传递给子进程</h2><p><img src="https://cy-pic.kuaizhan.com/g3/78/d7/0e85-0be1-4da3-92d9-3a12a4f9e57d06?sign=f02b8de39d7be9b21cb411eb7c2e9667&t=1572863982" alt=""></p><h2 id="子进程将它的输出发送到哪里"><a href="#子进程将它的输出发送到哪里" class="headerlink" title="子进程将它的输出发送到哪里"></a>子进程将它的输出发送到哪里</h2><p>&emsp;&emsp;一个CGI程序将它的动态内容发送到标准输出，在子进程加载并运行CGI程序之前，它使用UNIX dup2 函数将它标准输出重定向到和客户端相关连的已连接描述符。因此，任何CGI程序写到标准输出的东西都会直接到达客户端。</p><h1 id="Tiny-Web服务器代码分析"><a href="#Tiny-Web服务器代码分析" class="headerlink" title="Tiny Web服务器代码分析"></a>Tiny Web服务器代码分析</h1><h2 id="main函数-amp-open-listenfd函数"><a href="#main函数-amp-open-listenfd函数" class="headerlink" title="main函数 &amp; open_listenfd函数"></a>main函数 &amp; open_listenfd函数</h2><p>&emsp;&emsp;Tiny是一个迭代服务器，监听在命令行中传递来的端口上的连接请求，在通过调用 open_listenfd 函数打开一个监听套接字以后，执行无限服务器循环，不断接受连接请求，执行事务，并关闭连接它的那一端。</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> open_listenfd(char *port)</span><br><span class="line">&#123;</span><br><span class="line">    struct addrinfo hints,*p,*listp;</span><br><span class="line">    <span class="keyword">int</span> listenfd, optval=<span class="number">1</span>,rc;</span><br><span class="line">    memset(&amp;hints, <span class="number">0</span>, sizeof(struct addrinfo));</span><br><span class="line">    hints.ai_socktype=SOCK_STREAM;</span><br><span class="line">    hints.ai_flags = AI_PASSIVE | AI_ADDRCONFIG;</span><br><span class="line">    hints.ai_flags |= AI_NUMERICSERV;</span><br><span class="line">    //<span class="keyword">socket</span>----&gt;<span class="keyword">bind</span>----&gt;<span class="keyword">listen</span></span><br><span class="line">    getaddrinfo(NULL, port, &amp;hints, &amp;listp);</span><br><span class="line">   // <span class="keyword">if</span>(listp == NULL) </span><br><span class="line">    <span class="keyword">for</span>(p=listp; p; p=p-&gt;ai_next)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>((listenfd=<span class="keyword">socket</span>(p-&gt;ai_family, p-&gt;ai_socktype, p-&gt;ai_protocol)) &lt; <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">       <span class="keyword">if</span>((rc= <span class="keyword">setsockopt</span>(listenfd, SOL_SOCKET, SO_REUSEADDR, &amp; optval, sizeof(<span class="keyword">int</span>))) &lt; <span class="number">0</span>) <span class="keyword">printf</span>(<span class="string">"%s\n"</span>, strerror(errno));</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">bind</span>(listenfd, p-&gt;ai_addr, p-&gt;ai_addrlen) == <span class="number">0</span>)     //<span class="keyword">printf</span>(<span class="string">"%s\n"</span>, strerror(errno)); <span class="regexp">//break</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">close</span>(listenfd);</span><br><span class="line">    &#125;</span><br><span class="line">    freeaddrinfo(listp);</span><br><span class="line">    <span class="keyword">if</span>(!p)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">listen</span>(listenfd, LISTENQ) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">close</span>(listenfd);</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> listenfd;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> listenfd,connfd;</span><br><span class="line">    socklen_t clientlen;</span><br><span class="line">    char hostname[MAXNLINE], port[MAXNLINE];</span><br><span class="line">    struct sockaddr_storage clientaddr;</span><br><span class="line">    <span class="keyword">if</span>(argc&lt;<span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        fprintf(stderr, <span class="string">"usage: %s &lt;port&gt;\n"</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    listenfd=open_listenfd(argv[<span class="number">1</span>]);</span><br><span class="line">    //<span class="keyword">printf</span>(<span class="string">"%d"</span>, listenfd);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        clientlen = sizeof(clientaddr); </span><br><span class="line">        connfd = <span class="keyword">accept</span>(listenfd, (struct sockaddr *)&amp;clientaddr, &amp;clientlen);    <span class="regexp">//</span>等待客户端连接请求 </span><br><span class="line">        getnameinfo((struct sockaddr*)&amp; clientaddr, clientlen, hostname, MAXNLINE, port, MAXNLINE, <span class="number">0</span>);</span><br><span class="line">       // <span class="keyword">printf</span>(<span class="string">"\n%d\n"</span>, connfd);</span><br><span class="line">        <span class="keyword">printf</span>(<span class="string">"Accept connection from (%s %s)\n"</span>, hostname, port);</span><br><span class="line">      //  <span class="keyword">if</span>(connfd==<span class="number">152</span> || connfd ==<span class="number">153</span> || connfd==<span class="number">151</span> || connfd==<span class="number">154</span> || connfd==<span class="number">147</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        doit(connfd);</span><br><span class="line">        <span class="keyword">close</span>(connfd);</span><br><span class="line">        //<span class="keyword">if</span>( <span class="keyword">close</span>(connfd) &lt; <span class="number">0</span>) <span class="keyword">printf</span>(<span class="string">"%s"</span>, strerror(errno));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="doit函数"><a href="#doit函数" class="headerlink" title="doit函数"></a>doit函数</h2><p>&emsp;&emsp;doit函数处理一个HTTP事务，首先读和解析请求行(request line)，注意，我们使用rio_readlineb函数读取请求行。<br>Tiny只支持GET方法，如果客户端请求其他方法，发送一个错误信息。<br>然后将URI解析为一个文件名和一个可能为空的CGI参数字符串，并且设置一个标志表明请求的是静态内容还是动态内容,如果请求的是静态内容，就验证是否为普通文件，有读权限如果请求的是动态内容，就验证是否为可执行文件，如果是，就提供动态内容。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">void doit(<span class="built_in">int</span> fd)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> is_static;</span><br><span class="line">    <span class="keyword">struct</span> stat sbuf;</span><br><span class="line">    <span class="built_in">char</span> buf<span class="literal">[MAXNLINE]</span>, filename<span class="literal">[MAXNLINE]</span>, uri<span class="literal">[MAXNLINE]</span>, verson<span class="literal">[MAXNLINE]</span>;</span><br><span class="line">    <span class="built_in">char</span> <span class="keyword">method</span><span class="literal">[MAXNLINE]</span>, cgiargs<span class="literal">[MAXNLINE]</span>;   </span><br><span class="line">    rio_t rio;</span><br><span class="line"></span><br><span class="line">    rio<span class="constructor">_readinitb(&amp;<span class="params">rio</span>, <span class="params">fd</span>)</span>;        <span class="comment">//fd是与服务器通信的套接字 </span></span><br><span class="line">    rio<span class="constructor">_readlineb(&amp;<span class="params">rio</span>, <span class="params">buf</span>, MAXNLINE)</span>;</span><br><span class="line">    printf(<span class="string">"Request headers:\n"</span>);</span><br><span class="line">    printf(<span class="string">"%s"</span>, buf);</span><br><span class="line">    sscanf(buf, <span class="string">"%s %s %s"</span>, <span class="keyword">method</span>, uri, verson);</span><br><span class="line">    <span class="keyword">if</span>(strcasecmp(<span class="keyword">method</span>, <span class="string">"GET"</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        clienterror(fd, <span class="keyword">method</span>, <span class="string">"501"</span>, <span class="string">"Not implemented"</span>, <span class="string">"Tiny does not implement this method"</span>);</span><br><span class="line">        return ;</span><br><span class="line">    &#125;</span><br><span class="line">    read<span class="constructor">_requesthds(&amp;<span class="params">rio</span>)</span>;       <span class="comment">//读请求头 </span></span><br><span class="line">    is_static = prase<span class="constructor">_uri(<span class="params">uri</span>, <span class="params">filename</span>, <span class="params">cgiargs</span>)</span>;</span><br><span class="line">    <span class="keyword">if</span>(stat(filename, &amp;sbuf) &lt; <span class="number">0</span>)   <span class="comment">//通过文件名获取文件信息 </span></span><br><span class="line">    &#123;</span><br><span class="line">       clienterror(fd, filename, <span class="string">"404"</span>, <span class="string">"Not Found"</span>, <span class="string">"Tiny couldn't find this file"</span>);  <span class="comment">//返回错误信息 </span></span><br><span class="line">        return ; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(is_static==<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!(<span class="constructor">S_ISREG(<span class="params">sbuf</span>.<span class="params">st_mode</span>)</span>) <span class="pattern-match"><span class="operator">||</span>!(sbuf.st<span class="constructor">_mode</span> &amp; <span class="constructor">S_IRUSR</span>))</span></span><br><span class="line"><span class="pattern-match">        &#123;</span></span><br><span class="line"><span class="pattern-match">            clienterror(fd, filename, "403", "<span class="constructor">Not</span> <span class="constructor">Found</span>", "<span class="constructor">Tiny</span> couldn't read this file");  </span></span><br><span class="line"><span class="pattern-match">            return ;    </span></span><br><span class="line"><span class="pattern-match">        &#125;</span></span><br><span class="line"><span class="pattern-match">        serve<span class="constructor">_static(<span class="params">fd</span>, <span class="params">filename</span>, <span class="params">sbuf</span>.<span class="params">st_size</span>)</span>;</span></span><br><span class="line"><span class="pattern-match">    &#125;</span></span><br><span class="line"><span class="pattern-match">    <span class="keyword">else</span></span></span><br><span class="line"><span class="pattern-match">    &#123;</span></span><br><span class="line"><span class="pattern-match">        <span class="keyword">if</span>(!<span class="constructor">S_ISREG(<span class="params">sbuf</span>.<span class="params">st_mode</span>)</span> <span class="operator">||</span> !(<span class="constructor">S_IRUSR</span> &amp; sbuf.st<span class="constructor">_mode</span>))</span></span><br><span class="line"><span class="pattern-match">        &#123;</span></span><br><span class="line"><span class="pattern-match">            clienterror(fd, filename, "403", "<span class="constructor">Forbidden</span>", "<span class="constructor">Tiny</span> couldn't run the <span class="constructor">CGI</span> program");  </span></span><br><span class="line"><span class="pattern-match">            return ;</span></span><br><span class="line"><span class="pattern-match">        &#125;</span></span><br><span class="line"><span class="pattern-match">        serve<span class="constructor">_dynamic(<span class="params">fd</span>, <span class="params">filename</span>, <span class="params">cgiargs</span>)</span>;</span></span><br><span class="line"><span class="pattern-match">     &#125; </span></span><br><span class="line"><span class="pattern-match">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="clienterror函数"><a href="#clienterror函数" class="headerlink" title="clienterror函数"></a>clienterror函数</h2><p>&emsp;&emsp;clienterror函数检查一些明显的错误，并把它报告给客户端。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">void clienterror(<span class="built_in">int</span> fd, <span class="built_in">char</span> *cause, <span class="built_in">char</span> *errnum, <span class="built_in">char</span> *shortmsg, <span class="built_in">char</span> *longmsg)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">char</span> buf<span class="literal">[MAXNLINE]</span>,body<span class="literal">[MAXNLINE]</span>;</span><br><span class="line">    <span class="comment">//build http response body</span></span><br><span class="line">    sprintf(body, <span class="string">"&lt;html&gt;&lt;title&gt;Tiny Error&lt;/title&gt;"</span>);</span><br><span class="line">    sprintf(body, <span class="string">"%s&lt;body bgcolor="</span><span class="string">"ffffff"</span><span class="string">"&gt;\r\n"</span>, body);</span><br><span class="line">    sprintf(body, <span class="string">"%s%s: %s\r\n"</span>, body, errnum, shortmsg);</span><br><span class="line">    sprintf(body, <span class="string">"%s&lt;p&gt;%s: %s\r\n"</span>, body, longmsg, cause);</span><br><span class="line">    sprintf(body, <span class="string">"%s&lt;hr&gt;&lt;em&gt;The Tiny Web server&lt;/em&gt;\r\n"</span>, body);</span><br><span class="line">    <span class="comment">//打印信息 </span></span><br><span class="line">    sprintf(buf, <span class="string">"HTTP/1.0 %s %s\r\n"</span>, errnum, shortmsg);</span><br><span class="line">    rio<span class="constructor">_writen(<span class="params">fd</span>, <span class="params">buf</span>, <span class="params">strlen</span>(<span class="params">buf</span>)</span>);</span><br><span class="line">    sprintf(buf, <span class="string">"Content-type: text/html\r\n"</span>);</span><br><span class="line">    rio<span class="constructor">_writen(<span class="params">fd</span>, <span class="params">buf</span>, <span class="params">strlen</span>(<span class="params">buf</span>)</span>);</span><br><span class="line">    sprintf(buf, <span class="string">"Content-length: %d\r\n\r\n"</span>, (<span class="built_in">int</span>)strlen(body));</span><br><span class="line">    rio<span class="constructor">_writen(<span class="params">fd</span>, <span class="params">buf</span>, <span class="params">strlen</span>(<span class="params">buf</span>)</span>);</span><br><span class="line">    rio<span class="constructor">_writen(<span class="params">fd</span>, <span class="params">body</span>, <span class="params">strlen</span>(<span class="params">body</span>)</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="read-requesthdrs函数"><a href="#read-requesthdrs函数" class="headerlink" title="read_requesthdrs函数"></a>read_requesthdrs函数</h2><p>&emsp;&emsp;Tiny不使用请求报头中的任何信息，仅仅调用 read_requesthdrs函数来读取并忽略这些报头。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">void read<span class="constructor">_requesthds(<span class="params">rio_t</span> <span class="operator">*</span><span class="params">rp</span>)</span>       <span class="comment">//鎶把请求头读出来 </span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">char</span> buf<span class="literal">[MAXNLINE]</span>;</span><br><span class="line">    rio<span class="constructor">_readlineb(<span class="params">rp</span>, <span class="params">buf</span>, MAXNLINE)</span>;</span><br><span class="line">    printf(<span class="string">"%s"</span>, buf);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(strcmp(buf, <span class="string">"\r\n"</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        rio<span class="constructor">_readlineb(<span class="params">rp</span> , <span class="params">buf</span>, MAXNLINE)</span>;</span><br><span class="line">        printf(<span class="string">"%s"</span>, buf);</span><br><span class="line">    &#125;</span><br><span class="line">    return ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="parse-uri函数"><a href="#parse-uri函数" class="headerlink" title="parse_uri函数"></a>parse_uri函数</h2><p>&emsp;&emsp;Tiny假设静态内容的主目录就是当前目录，可执行文件的主目录是 ./cgi-bin/ 任何包含字符串 cgi-bin 的URI都认为是对动态内容的请求。</p><p>&emsp;&emsp;首先将URI解析为一个文件名和一个可选的CGI参数字符串，如果请求的是静态内容，就清除CGI参数串(第6行)，然后将URI转换为一个相对的unix 路径名，例如 ./index.html。</p><p>&emsp;&emsp;如果URI是用’/‘ 结尾的,我们就把默认的文件名加在后面。如果请求的是动态内容，就会抽取所有的CGI参数，并将URI剩下的部分转换为一个相应的unix文件名</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">prase_uri</span><span class="params">(<span class="keyword">char</span> *uri, <span class="keyword">char</span> *filename, <span class="keyword">char</span> *cgiargs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *ptr;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">strstr</span>(uri, <span class="string">"cgi-bin"</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">strcpy</span>(cgiargs, <span class="string">""</span>);</span><br><span class="line">        <span class="built_in">strcpy</span>(filename, <span class="string">"."</span>);</span><br><span class="line">        <span class="built_in">strcat</span>(filename, uri);</span><br><span class="line">        <span class="keyword">if</span>(uri[<span class="built_in">strlen</span>(uri)<span class="number">-1</span>]==<span class="string">'/'</span>) <span class="built_in">strcat</span>(filename, <span class="string">"home.html"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        ptr = index(uri, <span class="string">'?'</span>);</span><br><span class="line">        <span class="keyword">if</span>(ptr)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">strcpy</span>(cgiargs, ptr+<span class="number">1</span>);</span><br><span class="line">            *ptr=<span class="string">'\0'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">strcpy</span>(cgiargs, <span class="string">""</span>);</span><br><span class="line">        <span class="built_in">strcpy</span>(filename, <span class="string">"."</span>);</span><br><span class="line">        <span class="built_in">strcat</span>(filename, uri);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="serve-static函数"><a href="#serve-static函数" class="headerlink" title="serve_static函数"></a>serve_static函数</h2><p>&emsp;&emsp;Tiny提供四种不同的静态内容：HTML文件、无格式的文本文件、GIF编码格式图片、JPEG编码格式图片。serve_static 函数发送一个HTTP响应，其主体包含一个本地文件的内容。</p><p>&emsp;&emsp;首先我们通过检查文件名的后缀来判断文件类型，并且发送响应行和响应报头给客户端。注意用一个空行终止报头，我们使用 unix mmap函数将被请求文件映射到一个虚拟存储器空间，调用mmap将文件srcfd的前filesize个字节映射到一个从地址srcp开始的私有只读虚拟存储器区域。</p><p>&emsp;&emsp;一旦文件映射到存储器，就不再需要它的描述符了，关闭这个文件。rio_writen 函数拷贝从srcp位置开始的filesize个字节(已经被映射到了所请求的文件) 到客户端的已连接描述符。最后释放了映射的虚拟存储器区域，避免潜在的内存泄露。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getfiletype</span><span class="params">(<span class="keyword">char</span> *filename, <span class="keyword">char</span> *filetype)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strstr</span>(filename, <span class="string">".html"</span>))   <span class="built_in">strcpy</span>(filetype, <span class="string">"text/html"</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">strstr</span>(filename, <span class="string">".gif"</span>))   <span class="built_in">strcpy</span>(filetype, <span class="string">"image/gif"</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">strstr</span>(filename, <span class="string">".png"</span>))   <span class="built_in">strcpy</span>(filetype, <span class="string">"image/png"</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">strstr</span>(filename, <span class="string">".jpg"</span>))   <span class="built_in">strcpy</span>(filetype, <span class="string">"image/jpeg"</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">strcpy</span>(filetype, <span class="string">"text/plain"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">serve_static</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">char</span> *filename, <span class="keyword">int</span> filesize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> srcfd;</span><br><span class="line">    <span class="keyword">char</span> *srcp, filetype[MAXNLINE], buf[MAXNLINE];</span><br><span class="line">    <span class="comment">//  发送响应报头给客户端 </span></span><br><span class="line">    getfiletype(filename, filetype);      <span class="comment">//返回静态内容类型 </span></span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">"HTTP/1.0 200 OK\r\n"</span>);</span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">"%sServer: Tiny Web Server\r\n"</span>, buf);</span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">"%sConnection: close\r\n"</span>, buf);</span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">"%sContent-length %d\r\n"</span>, buf, filesize);</span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">"%sContent-type: %s\r\n\r\n"</span>, buf, filetype);</span><br><span class="line">    rio_writen(fd, buf, <span class="built_in">strlen</span>(buf));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Response headers:\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s"</span>, buf);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//  发送响应体给客户端 </span></span><br><span class="line">    srcfd = open(filename, O_RDONLY, <span class="number">0</span>); </span><br><span class="line">    srcp = mmap(<span class="number">0</span>, filesize, PROT_READ, MAP_PRIVATE, srcfd, <span class="number">0</span>);</span><br><span class="line">    close(srcfd);</span><br><span class="line">    rio_writen(fd, srcp, filesize);</span><br><span class="line">    munmap(srcp, filesize);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="serve-dynamic-函数"><a href="#serve-dynamic-函数" class="headerlink" title="serve_dynamic 函数"></a>serve_dynamic 函数</h2><p>&emsp;&emsp;Tiny通过派生一个子进程并在子进程的上下文中运行一个CGI程序，来提供各种类型的动态内容。</p><p>&emsp;&emsp;serve_dynamic函数一开始就向客户端发送一个表明成功的响应行，同时还包括带有信息的server报头。</p><p>&emsp;&emsp;子进程用来自请求URI的CGI参数初始化QUERY_STRING环境变量</p><p>&emsp;&emsp;子进程重定向它的标准输出到已连接文件描述符</p><p>&emsp;&emsp;加载并运行CGI程序，因为CGI程序运行在子进程的上下文中，它能够访问所有在调用execve函数之前就存在的打开文件和环境变量</p><p>&emsp;&emsp;父进程阻塞在对wait的调用中，等待子进程终止的时候，回收操作系统那个分配给子进程的资源</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">void serve<span class="constructor">_dynamic(<span class="params">int</span> <span class="params">fd</span>, <span class="params">char</span> <span class="operator">*</span><span class="params">filename</span>, <span class="params">char</span> <span class="operator">*</span><span class="params">cgiargs</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">char</span> buf<span class="literal">[MAXNLINE]</span>, *emptylist<span class="literal">[]</span>=&#123;NULL&#125;;</span><br><span class="line">    pid_t pid;</span><br><span class="line">    printf(<span class="string">"-----------%s-------------"</span>, cgiargs);</span><br><span class="line">    sprintf(buf, <span class="string">"HTTP/1.0 200 OK\r\n"</span>);</span><br><span class="line">    rio<span class="constructor">_writen(<span class="params">fd</span>, <span class="params">buf</span>, <span class="params">strlen</span>(<span class="params">buf</span>)</span>);</span><br><span class="line">    sprintf(buf, <span class="string">"Server: Tiny Web Server\r\n"</span>);</span><br><span class="line">    rio<span class="constructor">_writen(<span class="params">fd</span>, <span class="params">buf</span>, <span class="params">strlen</span>(<span class="params">buf</span>)</span>);</span><br><span class="line">    pid=fork<span class="literal">()</span>;</span><br><span class="line">    <span class="keyword">if</span>(pid==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        setenv(<span class="string">"QUERY_STRING"</span>, cgiargs, <span class="number">1</span>);   <span class="comment">//改变或者增加环境变量内容，为1则改 </span></span><br><span class="line">        dup2(fd, STDOUT_FILENO);</span><br><span class="line">       <span class="comment">/*</span></span><br><span class="line"><span class="comment">        *         来执行参数filename字符串所代表的文件路径，第二个参数是利</span></span><br><span class="line"><span class="comment">    用数组指针来传递给执行文件，并且需要以空指针(NULL)结束，最后一个参数则为传递给执行文件</span></span><br><span class="line"><span class="comment">    的新环境变量数组。execve()用来执行参数filename字符串所代表的文件路径，第二个参数是利用数组指针来传递给执</span></span><br><span class="line"><span class="comment">  行文件，并且需要以空指针(NULL)结束，最后一个参数则为传递给执行文件的新环境变量数组</span></span><br><span class="line"><span class="comment">  */</span> </span><br><span class="line">        execve(filename, emptylist, environ);</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="keyword">else</span>  wait(NULL);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="rio函数"><a href="#rio函数" class="headerlink" title="rio函数"></a>rio函数</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXNLINE 1024*8</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LISTENQ 1024</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">char</span> **environ;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> rio_fd,rio_cnt;</span><br><span class="line">    <span class="keyword">char</span> rio_buf[MAXNLINE],*rio_bufptr;</span><br><span class="line">&#125; <span class="keyword">rio_t</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">ssize_t</span> rio_writen(<span class="keyword">int</span> fd, <span class="keyword">void</span> *usrbuf, <span class="keyword">size_t</span> n)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">size_t</span> nleft=n;</span><br><span class="line">    <span class="keyword">ssize_t</span> nwritten;</span><br><span class="line">    <span class="keyword">char</span> *bufp=usrbuf;</span><br><span class="line">    <span class="keyword">while</span>(nleft&gt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>((nwritten = write(fd, bufp, nleft)) &lt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(errno == EINTR)</span><br><span class="line">            &#123;</span><br><span class="line">                nwritten=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        nleft-=nwritten;</span><br><span class="line">        bufp+=nwritten;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rio_readinitb</span><span class="params">(<span class="keyword">rio_t</span> *rio, <span class="keyword">int</span> fd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    rio-&gt;rio_fd=fd;</span><br><span class="line">    rio-&gt;rio_cnt=<span class="number">0</span>;</span><br><span class="line">    rio-&gt;rio_bufptr=rio-&gt;rio_buf;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> ssize_t <span class="title">rio_read</span><span class="params">(<span class="keyword">rio_t</span> *rp, <span class="keyword">char</span> *rc, <span class="keyword">size_t</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt;</span><br><span class="line">    <span class="keyword">while</span>(rp-&gt;rio_cnt&lt;=<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        rp-&gt;rio_cnt=read(rp-&gt;rio_fd, rp-&gt;rio_buf, <span class="keyword">sizeof</span>(rp-&gt;rio_buf));</span><br><span class="line">        <span class="keyword">if</span>(rp-&gt;rio_cnt&lt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(errno != EINTR)  <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">//此时为不中断 </span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(rp-&gt;rio_cnt==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> rp-&gt;rio_bufptr=rp-&gt;rio_buf;</span><br><span class="line">    &#125;</span><br><span class="line">    cnt=n;</span><br><span class="line">    <span class="keyword">if</span>(rp-&gt;rio_cnt &lt; n) cnt=rp-&gt;rio_cnt;</span><br><span class="line">    <span class="built_in">memcpy</span>(rc, rp-&gt;rio_bufptr, cnt);</span><br><span class="line">    rp-&gt;rio_bufptr+=cnt;</span><br><span class="line">    rp-&gt;rio_cnt-=cnt;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">ssize_t</span> rio_readlineb(<span class="keyword">rio_t</span> *rp, <span class="keyword">void</span> *usrbuf, <span class="keyword">size_t</span> maxnlen)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">char</span> *buf=usrbuf,c;</span><br><span class="line">    <span class="keyword">int</span> n,rc;</span><br><span class="line">    <span class="keyword">for</span>(n=<span class="number">1</span>; n&lt;maxnlen; ++n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>((rc=rio_read(rp, &amp;c, <span class="number">1</span>))==<span class="number">1</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            *buf++ = c;</span><br><span class="line">            <span class="keyword">if</span>(c == <span class="string">'\n'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                n++;</span><br><span class="line">                <span class="keyword">break</span>;  </span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(rc == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(n==<span class="number">1</span>)    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;   </span><br><span class="line">    *buf=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> n<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;简介： Tiny Web 项目 &lt;/p&gt;
    
    </summary>
    
    
      <category term="csapp" scheme="http://yoursite.com/categories/csapp/"/>
    
    
      <category term="Linux C/C++" scheme="http://yoursite.com/tags/Linux-C-C/"/>
    
      <category term="网络编程" scheme="http://yoursite.com/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
</feed>

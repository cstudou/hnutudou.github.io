<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>线程同步</title>
    <url>/2019/11/07/%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5/</url>
    <content><![CDATA[<p>简介： 如何解决线程的同步问题</p>
<a id="more"></a>
<h1 id="共享变量"><a href="#共享变量" class="headerlink" title="共享变量"></a>共享变量</h1><p>&emsp;&emsp;一个变量v是<strong>同步</strong>的，当且仅当它的一个实例被一个以上的线程引用。<br>&emsp;&emsp;每个线程都有它自己独立的上下文，包括<strong>线程ID、栈、栈指针、PC、条件码和通用目的寄存器值</strong>。每个线程和其他线程共享进程上下文的剩余部分，这包括整个用户虚拟地址空间，它是由制度文本（代码）、读/写数据、堆以及所有的共享库代码和数据区域组成的。在实际的线程内存模型中，寄存器的值虽然是隔离且被保护的，但是在栈中的值并不是这样的（其他线程也可以访问）。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> **ptr;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thread</span><span class="params">(<span class="keyword">void</span> *vargp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> myid=(<span class="keyword">int</span>)vargp;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"[%d]: %s (cnt=%d)\n"</span>, myid, ptr[myid], ++cnt);   <span class="comment">//每个线程都可以访问全局变量 </span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">pthread_t</span> tid;</span><br><span class="line">	<span class="keyword">char</span>* msgs[N]=</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="string">"hello from foo"</span>,</span><br><span class="line">		<span class="string">"hello from bar"</span>	</span><br><span class="line">	&#125;;</span><br><span class="line">	</span><br><span class="line">	ptr = msgs;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;N; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		pthread_create(&amp;tid, <span class="literal">NULL</span>, thread, (<span class="keyword">void</span> *)i);</span><br><span class="line">	&#125;</span><br><span class="line">	pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="用信号量同步线程"><a href="#用信号量同步线程" class="headerlink" title="用信号量同步线程"></a>用信号量同步线程</h1><h2 id="同步不正确的计数器程序"><a href="#同步不正确的计数器程序" class="headerlink" title="同步不正确的计数器程序"></a>同步不正确的计数器程序</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">long</span> cnt=<span class="number">0</span>; <span class="comment">//系统总是重新从它所在的内存读取数据，即使它前面的指令刚刚从该处读取过数据。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thread</span><span class="params">(<span class="keyword">void</span> *vargp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">long</span> i, niters=*((<span class="keyword">long</span> *)vargp);</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;niters; i++)	cnt++;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">long</span> niters=<span class="number">1000000</span>;</span><br><span class="line">	<span class="keyword">pthread_t</span> tid1, tid2;</span><br><span class="line"><span class="comment">//	if(argc != 2)</span></span><br><span class="line"><span class="comment">//	&#123;</span></span><br><span class="line"><span class="comment">//		fprintf(stderr, "usage: %s &lt;niters&gt;\n", argv[0]);</span></span><br><span class="line"><span class="comment">//		return 0;</span></span><br><span class="line"><span class="comment">//	&#125;</span></span><br><span class="line"><span class="comment">//	niters=atoi(argv[1]);   //把字符串转换为整形数,参数为const char *,C++使用时需调用.c_str()</span></span><br><span class="line">	<span class="comment">// 创建一个线程并且等待它们终止</span></span><br><span class="line">	pthread_create(&amp;tid1, <span class="literal">NULL</span>, thread, &amp;niters); </span><br><span class="line">	pthread_create(&amp;tid2, <span class="literal">NULL</span>, thread, &amp;niters);</span><br><span class="line">	pthread_join(tid1, <span class="literal">NULL</span>);</span><br><span class="line">	pthread_join(tid2, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="comment">//检查结果</span></span><br><span class="line">	<span class="keyword">if</span>(cnt != (<span class="number">2</span>*niters))	<span class="built_in">printf</span>(<span class="string">"BOOM! cnt=%ld\n"</span>, cnt);</span><br><span class="line">	<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"OK cnt=%ld\n"</span>, cnt);</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>); </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;运行结果为：<br><img src="https://s2.ax1x.com/2019/11/07/MkaTzV.png" alt=""><br>&emsp;&emsp;可见结果并不像预期的一样时2*niters，这是因为我们没有办法预测操作系统是否将为你的线程选择一个正确的顺序。<br>&emsp;&emsp;汇编代码为：<br><img src="https://s2.ax1x.com/2019/11/07/MkwTDU.png" alt=""><br>&emsp;&emsp;比如按如下指令顺序次序执行，会得到一个错误的值：<br><img src="https://s2.ax1x.com/2019/11/07/Mk03Ps.png" alt=""><br>关于volatile关键字可以参考：<a href="https://blog.csdn.net/ijn842/article/details/81273232" target="_blank" rel="noopener">https://blog.csdn.net/ijn842/article/details/81273232</a></p>
<h3 id="临界区（critical-section）"><a href="#临界区（critical-section）" class="headerlink" title="临界区（critical section）"></a>临界区（critical section）</h3><p>&emsp;&emsp;操作共享变量cnt内容的指令（L，U，S）构成了一个（关于共享变量cnt）的<strong>临界区</strong>，这个临界区不应该和其他线程的临界区交替执行。如果我们想要<strong>拥有对共享变量的互斥访问</strong>，就必须确保每个线程在执行它的临界区的指令时不和其他线程的临界区交替执行。</p>
<h2 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h2><p>&emsp;&emsp;可以利用PV操作来解决临界区问题。</p>
<ul>
<li>P( <strong>s</strong> ): 如果s不为0，那么P将s减1，并且立即返回。如果s为0，那么就挂起这个线程，直到s变为非0，而一个V操作会重启这个线程。</li>
<li>V( <strong>s</strong> ): V操作将s加1。如果有线程阻塞在P操作等待s变为非0，那么V操作会重启这些线程中的一个。V唯一的要求就是必须重启一个正在等待的线程，所有<strong>当多个线程在等待同一信号量时，不能预测V操作要重启哪一个线程</strong>。<br>&emsp;&emsp;PV操作保证了一个程序不可能有一个负值信号量，这个属性称为<strong>信号量不变性</strong>。</li>
</ul>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">#<span class="keyword">include</span> &lt;semaphore.h&gt;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> sem<span class="constructor">_init(<span class="params">sem_t</span> <span class="operator">*</span><span class="params">sem</span>, 0, <span class="params">unsigned</span> <span class="params">int</span> <span class="params">value</span>)</span>;</span><br><span class="line"><span class="comment">//将信号量sem初始化为value</span></span><br><span class="line"><span class="comment">//第二个参数不为0时此信号量在进程间共享，否则只能为当前进程的所有线程共享</span></span><br><span class="line"><span class="built_in">int</span> sem<span class="constructor">_wait(<span class="params">sem_t</span> <span class="operator">*</span><span class="params">s</span>)</span>    <span class="comment">//P(s)</span></span><br><span class="line"><span class="built_in">int</span> sem<span class="constructor">_post(<span class="params">sem_t</span> <span class="operator">*</span><span class="params">s</span>)</span>    <span class="comment">//V(s)</span></span><br></pre></td></tr></table></figure>

<h2 id="同步正确的计数器程序"><a href="#同步正确的计数器程序" class="headerlink" title="同步正确的计数器程序"></a>同步正确的计数器程序</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;semaphore.h&gt; </span></span></span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">long</span> cnt=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">sem_t</span> mutex;      <span class="comment">//申请互斥变量 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">P</span><span class="params">(<span class="keyword">sem_t</span> *s)</span>    <span class="comment">//P操作 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(sem_wait(s)&lt;<span class="number">0</span>)	 <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"sem_wait error: %s\n"</span>, strerror(errno)),<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">V</span><span class="params">(<span class="keyword">sem_t</span> *s)</span>   <span class="comment">//V操作 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(sem_post(s)&lt;<span class="number">0</span>)	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"sem_post error: %s\n"</span>, strerror(errno)),<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thread</span><span class="params">(<span class="keyword">void</span> *vargp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">long</span> niters=(*(<span class="keyword">long</span> *)vargp);</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;niters; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		P(&amp;mutex);        <span class="comment">//进行pv操作， 保护临界区 </span></span><br><span class="line">		cnt++;</span><br><span class="line">		V(&amp;mutex);</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">long</span> niters=<span class="number">1000</span>;</span><br><span class="line">	<span class="keyword">pthread_t</span> tid1,tid2;</span><br><span class="line">	sem_init(&amp;mutex, <span class="number">0</span>, <span class="number">1</span>);   <span class="comment">//将mutex初始化为1 </span></span><br><span class="line">	pthread_create(&amp;tid1, <span class="literal">NULL</span>, thread, &amp;niters);	</span><br><span class="line">	pthread_create(&amp;tid2, <span class="literal">NULL</span>, thread, &amp;niters);	</span><br><span class="line">	pthread_join(tid1, <span class="literal">NULL</span>);</span><br><span class="line">	pthread_join(tid2, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span>(cnt != (<span class="number">2</span>*niters))	<span class="built_in">printf</span>(<span class="string">"BOOM! cnt=%ld\n"</span>, cnt);</span><br><span class="line">	<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"OK cnt=%ld\n"</span>, cnt);</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;利用PV操作，可以做到互斥访问临界区，所以能得到正确的结果</p>
<h2 id="生产者-消费者问题"><a href="#生产者-消费者问题" class="headerlink" title="生产者-消费者问题"></a>生产者-消费者问题</h2>]]></content>
      <categories>
        <category>csapp</category>
      </categories>
      <tags>
        <tag>Linux C/C++</tag>
        <tag>网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title>字符串哈希</title>
    <url>/2019/11/06/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%93%88%E5%B8%8C/</url>
    <content><![CDATA[<p>简介： 字符串前缀哈希法</p>
<a id="more"></a>
<p>&emsp;&emsp;判断一个字符串两段字符是否相等</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//要人品足够好，保证没有冲突现象发生 </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ULL;		<span class="comment">//溢出相当于取模 </span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">100010</span>,P=<span class="number">131</span>;  <span class="comment">//p=131或者13331为经验值 ,若哈希值特别大，则需要取模，对2^64取模为经验值 </span></span><br><span class="line">ULL p[maxn],h[maxn];</span><br><span class="line"><span class="keyword">char</span> str[maxn];</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="function">ULL <span class="title">get</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span>  <span class="comment">//结果溢出即为取模 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> h[r]-h[l<span class="number">-1</span>]*p[r-l+<span class="number">1</span>];           <span class="comment">//公式	高位|--------l-1----相当于乘10的n次-------r|低位  </span></span><br><span class="line">	<span class="comment">//参数为1-l哈希值，1-r哈希值 </span></span><br><span class="line"> &#125; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m&gt;&gt;str+<span class="number">1</span>;</span><br><span class="line">	p[<span class="number">0</span>]=<span class="number">1</span>;          <span class="comment">//p的0次方等于1 </span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		p[i]=p[i<span class="number">-1</span>]*P;             <span class="comment">//预处理p数组，，用于字符串哈希，相当于p进制 </span></span><br><span class="line">		h[i]=h[i<span class="number">-1</span>]*P + str[i];     <span class="comment">//计算哈希值 ，a*p^0 + b*p^2+..... 并且不断取模 </span></span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">while</span>(m--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> l1,r1,l2,r2;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;l1&gt;&gt;r1&gt;&gt;l2&gt;&gt;r2;</span><br><span class="line">		<span class="keyword">if</span>(get(l1,r1)==get(l2,r2))	<span class="built_in">cout</span>&lt;&lt;<span class="string">"Yes"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="string">"No"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法笔记</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>KMP</title>
    <url>/2019/11/06/KMP/</url>
    <content><![CDATA[<p>简介： KMP算法</p>
<a id="more"></a>
<p>&emsp;&emsp;kmp算法时间复杂度：O(m+n)<br>&emsp;&emsp;在某个字符失配时，该字符对应的next 值会告诉你下一步匹配中，模式串应该跳到哪个位置（跳到next [j] 的位置）。此时不必重新开始匹配。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">10010</span>,M=<span class="number">100010</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">char</span> p[N],s[M];</span><br><span class="line"><span class="keyword">int</span> ne[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;p+<span class="number">1</span>&gt;&gt;m&gt;&gt;s+<span class="number">1</span>;</span><br><span class="line">	<span class="comment">//求next的过程， next[1]=0 找前面子集字符串 	</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>,j=<span class="number">0</span>; i&lt;=n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span>(j &amp;&amp; p[i]!=p[j+<span class="number">1</span>])	j=ne[j];</span><br><span class="line">		<span class="keyword">if</span>(p[i]==p[j+<span class="number">1</span>])	j++;</span><br><span class="line">		ne[i]=j;</span><br><span class="line">	 &#125; </span><br><span class="line">	 </span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,j=<span class="number">0</span>; i&lt;=m; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span>(j &amp;&amp; p[j+<span class="number">1</span>]!=s[i])	j=ne[j];    <span class="comment">//没有匹配上，求next</span></span><br><span class="line">		<span class="keyword">if</span>(s[i]==p[j+<span class="number">1</span>]) j++;      <span class="comment">//这个字符匹配，求下一个</span></span><br><span class="line">		<span class="keyword">if</span>(j==n)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;i-n&lt;&lt;<span class="string">" "</span>;      <span class="comment">//完全匹配上</span></span><br><span class="line">			j=ne[j];           <span class="comment">//求解下一个 </span></span><br><span class="line">		 &#125; </span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法笔记</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>最短路径</title>
    <url>/2019/11/06/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/</url>
    <content><![CDATA[<p>简介： 最短路径算法</p>
<a id="more"></a>
<h1 id="Dijkstra-算法"><a href="#Dijkstra-算法" class="headerlink" title="Dijkstra 算法"></a>Dijkstra 算法</h1><p>&emsp;&emsp;时间复杂度O(n²），适用于稠密图。<br>&emsp;&emsp;示例：<br><img src="https://s2.ax1x.com/2019/11/06/Mi30sI.jpg" alt=""></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="built_in">int</span> maxn=<span class="number">510</span>,INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="built_in">int</span> G[maxn][maxn],dis[maxn];            <span class="comment">//G为矩阵，dis为起点到各个点的最短距离</span></span><br><span class="line"><span class="built_in">bool</span> vis[maxn];</span><br><span class="line"><span class="built_in">void</span> dijkstra(<span class="built_in">int</span> s)      <span class="comment">//s为起点 </span></span><br><span class="line">&#123;</span><br><span class="line">	fill(dis, dis+maxn, INF);             <span class="comment">//将距离初始化为INF，即就是无穷大	</span></span><br><span class="line">	d[s]=<span class="number">0</span>;                <span class="comment">//起点到起点的距离为0</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>; i&lt;n; i++)      <span class="comment">//循环n次 </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">int</span> u=<span class="number">-1</span>,mi=INF;         </span><br><span class="line">		<span class="keyword">for</span>(<span class="built_in">int</span> j=<span class="number">1</span>; j&lt;=n; j++)	<span class="comment">//找到为访问顶点中的d[]最小的 </span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(vis[j]==<span class="literal">false</span> &amp;&amp; d[j]&lt;mi)</span><br><span class="line">			&#123;</span><br><span class="line">				u=j;</span><br><span class="line">				mi=d[j];</span><br><span class="line">			&#125; </span><br><span class="line">		&#125;  </span><br><span class="line">		<span class="keyword">if</span>(u==<span class="number">-1</span>)	<span class="keyword">return</span> ;            <span class="comment">//如果找不到小于MI的d[]，说明剩下的顶点与起点s不连通      </span></span><br><span class="line">		vis[u]=<span class="literal">true</span>;          <span class="comment">//标记为访问过 </span></span><br><span class="line">		<span class="keyword">for</span>(<span class="built_in">int</span> v=<span class="number">1</span>; v&lt;=n; v++)</span><br><span class="line">		&#123;       <span class="comment">//如果v没有访问 &amp;&amp; u能到达v &amp;&amp; 以u为中介点能使d[v] 更优</span></span><br><span class="line">			<span class="keyword">if</span>(vis[v]==<span class="literal">false</span> &amp;&amp; G[u][v]!=INF &amp;&amp; d[v]&gt;d[u]+G[u][v])	d[v]=G[u][v]+d[v];    <span class="comment">//优化		</span></span><br><span class="line">		&#125; </span><br><span class="line">	 &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="堆优化版的Dijkstra算法"><a href="#堆优化版的Dijkstra算法" class="headerlink" title="堆优化版的Dijkstra算法"></a>堆优化版的Dijkstra算法</h1><p>&emsp;&emsp;时间复杂度O((m+n)logn)，适用于稀疏图。利用stl中的优先队列来进行优化。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//--------------堆优化</span></span><br><span class="line"><span class="keyword">using</span> PII = pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dij</span><span class="params">(<span class="keyword">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	fill(dis, dis+maxn, INF);</span><br><span class="line">	dis[s]=<span class="number">0</span>;</span><br><span class="line">	priority_queue&lt;PII, <span class="built_in">vector</span>&lt;PII&gt;, greater&lt;PII&gt;&gt; heap;</span><br><span class="line">	heap.push(&#123;<span class="number">0</span>,s&#125;);         <span class="comment">//s到自己的距离为0   //一定要注意要先写距离再写点，，因为堆排序的时候要用距离作为第一尺度 </span></span><br><span class="line">	<span class="keyword">while</span>(heap.size())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">auto</span> t=heap.top();</span><br><span class="line">		heap.pop();</span><br><span class="line">		<span class="keyword">int</span> u=t.second,w=t.first;        <span class="comment">//取出最小的点和该店到源点的最短距离 </span></span><br><span class="line">		<span class="keyword">if</span>(vis[u]) <span class="keyword">continue</span>;              <span class="comment">//可能存在一些冗余边比如2-&gt;3(2);2-&gt;3(4) 后面的被舍弃 </span></span><br><span class="line">		vis[u]=<span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;adj[u].size(); j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> v=adj[u][j].v;</span><br><span class="line">			<span class="keyword">if</span>(vis[v]==<span class="literal">false</span> &amp;&amp; dis[v]&gt;w+adj[u][j].dis)</span><br><span class="line">			&#123;</span><br><span class="line">				dis[v]=w+adj[u][j].dis;</span><br><span class="line">				heap.push(&#123;dis[v],v&#125;);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; </span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="folyd-算法"><a href="#folyd-算法" class="headerlink" title="folyd 算法"></a>folyd 算法</h1><p>&emsp;&emsp;时间复杂度为O(n³)</p>
<figure class="highlight accesslog"><table><tr><td class="code"><pre><span class="line">void floyd()</span><br><span class="line">&#123;</span><br><span class="line">	for(int k=<span class="number">1</span>; k&lt;=n; k++)       //以k为中介，枚举所有顶点 </span><br><span class="line">	&#123;</span><br><span class="line">		for(int i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			for(int j=<span class="number">1</span>; j&lt;=n; j++)</span><br><span class="line">			&#123;</span><br><span class="line">				if(dis<span class="string">[i]</span><span class="string">[k]</span>!=INF &amp;&amp; dis<span class="string">[k]</span><span class="string">[j]</span>!=INF &amp;&amp; dis<span class="string">[i]</span><span class="string">[k]</span>+dis<span class="string">[k]</span><span class="string">[j]</span>&lt;dis<span class="string">[i]</span><span class="string">[j]</span>)</span><br><span class="line">					dis<span class="string">[i]</span><span class="string">[j]</span>=dis<span class="string">[i]</span><span class="string">[k]</span>+dis<span class="string">[k]</span><span class="string">[j]</span>;               //存的时候要把dis<span class="string">[i]</span><span class="string">[i]</span>设置为<span class="number">0</span>，因为自己到自己的距离为<span class="number">0</span> </span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Bellman-算法"><a href="#Bellman-算法" class="headerlink" title="Bellman 算法"></a>Bellman 算法</h1><p>&emsp;&emsp;时间复杂度为O(nm),适用于权值为负的情况</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">100010</span>,INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> v,dis;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;node&gt; adj[maxn];</span><br><span class="line"><span class="keyword">int</span> m,n,d[maxn],vis[maxn];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Bellman</span><span class="params">(<span class="keyword">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	fill(d,d+maxn,INF);</span><br><span class="line">	d[s]=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n<span class="number">-1</span>; i++)   <span class="comment">//n-1次松弛操作   两个点一条边要一次松弛 </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//copy(dis, dis+maxn, ans); //保证不发生串联 如果不加，可能会用更新后的值依次更新后面的节点 ,此时一次只更新一层 </span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> u=<span class="number">1</span>; u&lt;=n; u++)   <span class="comment">//枚举每一条边 </span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;adj[u].size(); j++)   <span class="comment">//如果以u为中介可以使d[v]变小 </span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">int</span> v=adj[u][j].v;</span><br><span class="line">				<span class="keyword">int</span> dis=adj[u][j].dis;</span><br><span class="line">				<span class="keyword">if</span>(d[u]+dis&lt;d[v])	d[v]=d[u]+dis;     <span class="comment">//松弛操作 </span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//if(dis[n] &gt;INF/2)	return false;     //可能会有一条负权边把n号点更新 </span></span><br><span class="line">	<span class="comment">//return true;</span></span><br><span class="line">	<span class="comment">//判断负环</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> u=<span class="number">1</span>; u&lt;=n; u++)     <span class="comment">//如果还能进行松弛操作 </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;adj[u].size(); j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> v=adj[u][j].v;</span><br><span class="line">			<span class="keyword">int</span> dis=adj[u][j].dis;</span><br><span class="line">			<span class="keyword">if</span>(d[u]+dis&lt;d[v])	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="spfa算法"><a href="#spfa算法" class="headerlink" title="spfa算法"></a>spfa算法</h1><p>&emsp;&emsp;一般情况下时间复杂度为O(m)最坏时间复杂度为O(nm),适用于权值为负的情况。对比Bellman算法，spfa只有在松弛操作后才会入队，同样适用于权值为负的情况。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">100010</span>,INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">bool</span> vis[maxn];</span><br><span class="line"><span class="keyword">int</span> n,dis[maxn],num[maxn];         <span class="comment">//num数组记录顶点的入队次数 </span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">SPFA</span><span class="params">(<span class="keyword">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	fill(dis, dis+maxn, INF); </span><br><span class="line">	dis[s]=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">	q.push(s);        <span class="comment">//源点入队</span></span><br><span class="line">	vis[s]=<span class="literal">true</span>;</span><br><span class="line">	num[s]++; <span class="comment">//入队次数加1</span></span><br><span class="line">	<span class="keyword">while</span>(!q.empty())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">auto</span> u=q.front();</span><br><span class="line">		q.pop();</span><br><span class="line">		vis[u]=<span class="literal">false</span>;          <span class="comment">//设置u不在队列</span></span><br><span class="line">		<span class="comment">//遍历所有邻边</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;adj[u].size(); j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> v=adj[u][j].v;</span><br><span class="line">			<span class="keyword">int</span> d=adj[u][j].dis;</span><br><span class="line">			<span class="keyword">if</span>(dis[u]+d &lt; dis[v])</span><br><span class="line">			&#123;</span><br><span class="line">				dis[v]=dis[u]+d;</span><br><span class="line">				<span class="keyword">if</span>(!vis[v])     <span class="comment">//v不在队列 </span></span><br><span class="line">				&#123;</span><br><span class="line">					q.push(v);   <span class="comment">//有松弛操作才入队 </span></span><br><span class="line">					vis[v]=<span class="literal">true</span>;</span><br><span class="line">					num[v]++;</span><br><span class="line">					<span class="keyword">if</span>(num[v]&gt;=n)	<span class="keyword">return</span> <span class="literal">false</span>;      <span class="comment">//有可达负环 </span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		 &#125; </span><br><span class="line">	 &#125; </span><br><span class="line">	 <span class="keyword">return</span> <span class="literal">true</span>; </span><br><span class="line">	 </span><br><span class="line">		</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法笔记</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>echo服务器——基于线程</title>
    <url>/2019/11/06/echo%E6%9C%8D%E5%8A%A1%E5%99%A8%E2%80%94%E2%80%94%E5%9F%BA%E4%BA%8E%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<p>简介： 基于线程的并发编程</p>
<a id="more"></a>
<h1 id="并行方法"><a href="#并行方法" class="headerlink" title="并行方法"></a>并行方法</h1><p>&emsp;&emsp;前面实现的服务器，一次只能处理一个请求，只有当前的请求处理完了，才能继续处理下一个。<br><img src="https://s2.ax1x.com/2019/11/06/MPrLjK.jpg" alt=""><br>&emsp;&emsp;服务器初始化后listen客户端的connect请求，当客户端向服务器发送connect请求后，服务器accept并且开始等待客户端的输入，客户端 1 write之后转为等待响应(call read)，服务器的read接收到内容之后，发送响应(write) 后进入等待(read)，而客户端 1 接收到了响应(ret read)，最后根据用户指令退出(close)。而只有当客户端 1 断开之后，服务器才会处理客户端 2 的请求。我们可以使用并行的策略，同时处理不同客户端发来的请求。</p>
<h2 id="基于进程"><a href="#基于进程" class="headerlink" title="基于进程"></a>基于进程</h2><p>&emsp;&emsp;为每个客户端分离出一个单独的进程，是建立了连接之后才开始并行，连接的建立还是串行的。服务器在 accept 中返回 connfd 并且 fork 一个子进程来处理客户端连接。</p>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul>
<li>每个客户端由独立子进程处理<ul>
<li>必须回收僵尸进程，来避免严重的内存泄露</li>
</ul>
</li>
<li>内核自动管理多个逻辑流</li>
<li>每个进程有其私有的地址空间</li>
<li>不同进程之间不共享数据</li>
<li>父进程和子进程都有 listenfd 和 connfd，所以在父进程中需要关闭 connfd，在子进程中需要关闭 listenfd<ul>
<li>内核会保存每个 socket 的引用计数，在 fork 之后 refcnt(connfd) = 2，所以在父进程需要关闭 connfd，这样在子进程结束后引用计数才会为零</li>
</ul>
</li>
</ul>
<h2 id="基于事件"><a href="#基于事件" class="headerlink" title="基于事件"></a>基于事件</h2><p>&emsp;&emsp;服务器会维护一个 connection 数组，包含若干 connfd，每个输入请求都被当做事件，然后每次从已有的事件中选取一个进行处理。</p>
<h3 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h3><ul>
<li>由程序员手动控制多个逻辑流</li>
<li>所有的逻辑流共享同一个地址空间</li>
<li>这个技术称为 I/O multiplexing</li>
</ul>
<h2 id="基于线程"><a href="#基于线程" class="headerlink" title="基于线程"></a>基于线程</h2><p>&emsp;&emsp;<strong>线程</strong>就是运行在进程上下文中的逻辑流<br>&emsp;&emsp;一个进程则包括线程、代码、数据和上下文。也就是说，线程作为单独可执行的部分，被抽离出来了，一个进程可以有多个线程。<br>&emsp;&emsp;每个线程有自己的线程 id，有自己的逻辑控制流，也有自己的用来保存局部变量的栈（其他线程可以修改）但是会共享所有的代码、数据以及内核上下文。和进程不同的是，线程没有一个明确的树状结构（使用 fork 是有明确父进程子进程区分的）。和进程中『并行』的概念一样，如果两个线程的控制流在时间上有『重叠』（或者说有交叉），那么就是并行的。线程共享代码和数据（进程通常不会），线程开销比较小（创建和回收）。一个线程可以杀死它的任何对等线程，或者等待它的任意对等线程终止，而且每个对等线程能读写相同的共享数据。</p>
<h3 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h3><ul>
<li>内核自动管理多个逻辑流</li>
<li>每个线程共享地址空间</li>
</ul>
<h1 id="Posix-线程"><a href="#Posix-线程" class="headerlink" title="Posix 线程"></a>Posix 线程</h1><p>&emsp;&emsp;Posix线程是在c语言中处理线程的一个标准接口，Pthreads定义了大概60个函数，允许程序创建、杀死、回收线程，与对等线程安全的共享数据，还可以通知对等线程系统状态的变化。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thread</span><span class="params">(<span class="keyword">void</span> *vargp)</span>  <span class="comment">//每个线程例程都以一个通用指针作为输入，返回一个通用指针 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"helo"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">pthread_t</span> tid;      <span class="comment">//存放线程ID </span></span><br><span class="line">	pthread_create(&amp;tid, <span class="literal">NULL</span>, thread, <span class="literal">NULL</span>);    <span class="comment">//创建对等线程，此函数返回时，主线程与对等线程同时运行 </span></span><br><span class="line">	pthread_join(tid, <span class="literal">NULL</span>);   <span class="comment">//子线程合入主线程，主线程阻塞等待子线程结束，然后回收子线程资源。 </span></span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);   <span class="comment">//终止运行在这个进程中的所有进程 </span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h2 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h2><p>&emsp;&emsp;线程通过调用pthread_create函数来创建其他线程:</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">typedef void *(func)(void *);</span><br><span class="line"><span class="built_in">int</span> pthread<span class="constructor">_create(<span class="params">pthread_t</span> <span class="operator">*</span><span class="params">tid</span>, <span class="params">pthread_attr_t</span> <span class="operator">*</span><span class="params">attr</span>, <span class="params">func</span> <span class="operator">*</span><span class="params">f</span>, <span class="params">void</span> <span class="operator">*</span><span class="params">arg</span>)</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;此函数创建一个新线程，并带着一个输入变量args，在新线程的上下文中运行线程例程f。可用attr参数来改变新线程的默认属性。当此函数返回时，tid包含新创建的线程ID，可调用pthread_self函数来获得自己的线程ID:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ptherad_t</span> pthread_self(<span class="keyword">void</span>);</span><br></pre></td></tr></table></figure>
<h2 id="终止线程"><a href="#终止线程" class="headerlink" title="终止线程"></a>终止线程</h2><ul>
<li>顶层线程例程返回时，线程会隐式终止</li>
<li>调用pthread_exit函数，线程显式终止，此时线程占用的资源不会释放<code>void pthread_exit(void *thread_return)</code>参数可以通过pthread_join传递</li>
<li>某个对等线程调用exit函数，该函数终止进程以及与进程相关的所有线程</li>
<li>另一个对等线程通过以当前线程ID为参数调用pthread_cancel</li>
</ul>
<h2 id="回收资源"><a href="#回收资源" class="headerlink" title="回收资源"></a>回收资源</h2><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> pthread<span class="constructor">_join(<span class="params">pthread_t</span> <span class="params">tid</span>, <span class="params">void</span> <span class="operator">**</span><span class="params">thread_return</span>)</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;pthread_join会阻塞，直到线程tid终止，将线程例程返回的通用指针赋值为thread_return指向的位置，然后回收终止线程占用的资源</p>
<h2 id="分离线程"><a href="#分离线程" class="headerlink" title="分离线程"></a>分离线程</h2><p>&emsp;&emsp;在任何一个时间点上，线程是可结合或者分离的。<br>&emsp;&emsp;一个<strong>可结合</strong>线程能<strong>被其他线程收回和杀死</strong>。在被其他线程回收之前，它的<strong>内存资源是不释放</strong>的。<br>&emsp;&emsp;一个<strong>分离</strong>的线程不能被其他线程回收或者杀死，它的<strong>内存资源在它终止时由系统自动释放</strong>。<br>&emsp;&emsp;默认情况下，线程被创建为可结合的，pthread_detach可分离可结合线程tid</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> pthread<span class="constructor">_detach(<span class="params">pthread_t</span> <span class="params">tid</span>)</span>;</span><br></pre></td></tr></table></figure>

<h2 id="初始化线程"><a href="#初始化线程" class="headerlink" title="初始化线程"></a>初始化线程</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pthread_once_t</span> once_control = PTHREAD_ONCE_INIT;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_once</span><span class="params">(<span class="keyword">pthread_once_t</span> *once_control, <span class="keyword">void</span> (*init_routine)(<span class="keyword">void</span>))</span></span>;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;此函数允许你初始化与线程例程相关的状态，once_control是一个全局或者静态变量，总是被初始化为PTHREAD_ONCE。</p>
<h1 id="并发服务器-基于线程"><a href="#并发服务器-基于线程" class="headerlink" title="并发服务器-基于线程"></a>并发服务器-基于线程</h1><p>&emsp;&emsp;主线程不断等待连接请求，然后创建一个对等线程处理该请求。<br>Q：当我们调用pthread_create时，如何将已连接描述符传递给对等线程<br>A：传递一个指向描述符的指针</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"csapp.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">echo</span><span class="params">(<span class="keyword">int</span> connfd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">size_t</span> n;</span><br><span class="line">	<span class="keyword">rio_t</span> rio;</span><br><span class="line">	<span class="keyword">char</span> buf[MAXNLINE];</span><br><span class="line">	rio_readinitb(&amp;rio, connfd);</span><br><span class="line">	<span class="keyword">while</span>((n=rio_readlineb(&amp;rio, buf, MAXNLINE)) != <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"serve received %d bytes\n"</span>, (<span class="keyword">int</span>)n);</span><br><span class="line">		rio_writen(connfd, buf, n);</span><br><span class="line">	&#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thread</span><span class="params">(<span class="keyword">void</span> *vargp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> connfd = *((<span class="keyword">int</span> *)vargp);       <span class="comment">//把描述符取出来</span></span><br><span class="line">	pthread_detach(pthread_self());     <span class="comment">//分离线程，参数为线程ID</span></span><br><span class="line">	<span class="built_in">free</span>(vargp);    <span class="comment">//释放空间</span></span><br><span class="line">	echo(connfd);</span><br><span class="line">	close(connfd);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> listenfd,*connfdp;</span><br><span class="line">	<span class="keyword">socklen_t</span> clientlen;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_storage</span> <span class="title">clientaddr</span>;</span></span><br><span class="line">	<span class="keyword">pthread_t</span> tid;</span><br><span class="line">	<span class="keyword">if</span>(argc != <span class="number">2</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"usage: %s &lt;port&gt;\n"</span>, argv[<span class="number">0</span>]);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	listenfd = open_listenfd(argv[<span class="number">1</span>]);</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		clientlen=<span class="keyword">sizeof</span>(struct sockaddr_storage);</span><br><span class="line">		connfdp = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>));      <span class="comment">//开辟一个int大小的空间存描述符 </span></span><br><span class="line">		*connfdp = accept(listenfd, (struct sockaddr *)&amp; clientaddr, &amp;clientlen);</span><br><span class="line">		pthread_create(&amp;tid, <span class="literal">NULL</span>, thread, connfdp);  <span class="comment">//将指向描述符的指针传递给对等线程</span></span><br><span class="line">		 </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>csapp</category>
      </categories>
      <tags>
        <tag>Linux C/C++</tag>
        <tag>网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title>大整数运算</title>
    <url>/2019/11/04/%E5%A4%A7%E6%95%B4%E6%95%B0%E8%BF%90%E7%AE%97/</url>
    <content><![CDATA[<p>简介： 常用的大整数运算</p>
<a id="more"></a>
<h1 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h1><p>&emsp;&emsp;用string存储数组，将其倒着存，使得最高位在vector的末尾，这是为了方便进位</p>
<h1 id="加法"><a href="#加法" class="headerlink" title="加法"></a>加法</h1><p>&emsp;&emsp;注意最后可能t不为0，要将其存进去</p>
<figure class="highlight mel"><table><tr><td class="code"><pre><span class="line"><span class="keyword">vector</span>&lt;<span class="keyword">int</span>&gt; add(<span class="keyword">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;a, <span class="keyword">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;b)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">vector</span>&lt;<span class="keyword">int</span>&gt; C;</span><br><span class="line">	<span class="keyword">int</span> t=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;a.<span class="keyword">size</span>()||i&lt;b.<span class="keyword">size</span>(); i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(i&lt;a.<span class="keyword">size</span>())	t+=a[i];</span><br><span class="line">		<span class="keyword">if</span>(i&lt;b.<span class="keyword">size</span>())	t+=b[i];</span><br><span class="line">		C.push_back(t%10);</span><br><span class="line">		t/=<span class="number">10</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(t)	C.push_back(t);</span><br><span class="line">	<span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="减法"><a href="#减法" class="headerlink" title="减法"></a>减法</h1><p>&emsp;&emsp;主要存模的时候要先加10再对10取模，因为t可能是负数，在c++中，比如-2%10=-2。<br>&emsp;&emsp;最后得到结果可能含有前导0，要pop_back</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="built_in">int</span>&gt; sub(vector&lt;<span class="built_in">int</span>&gt; &amp;a, vector&lt;<span class="built_in">int</span>&gt; &amp;b)</span><br><span class="line">&#123;</span><br><span class="line">	vector&lt;<span class="built_in">int</span>&gt; C;</span><br><span class="line">	<span class="built_in">int</span> t=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>; i&lt;a.size(); i++)</span><br><span class="line">	&#123;</span><br><span class="line">		t=a[i]-t;     <span class="comment">//要减去借位 </span></span><br><span class="line"> 		<span class="keyword">if</span>(i&lt;b.size())	t-=b[i];</span><br><span class="line">		C.push_back((t+<span class="number">10</span>)%<span class="number">10</span>);</span><br><span class="line">		<span class="keyword">if</span>(t&lt;<span class="number">0</span>)	t=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">else</span>	t=<span class="number">0</span>; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(C.size()&gt;<span class="number">1</span> &amp;&amp; C.back()==<span class="number">0</span>)	C.pop_back();</span><br><span class="line">	<span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="乘法"><a href="#乘法" class="headerlink" title="乘法"></a>乘法</h1><p>&emsp;&emsp;不断相乘取模即可</p>
<figure class="highlight mel"><table><tr><td class="code"><pre><span class="line"><span class="keyword">vector</span>&lt;<span class="keyword">int</span>&gt; mul(<span class="keyword">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;a, <span class="keyword">int</span> b)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">vector</span>&lt;<span class="keyword">int</span>&gt; C;</span><br><span class="line">	<span class="keyword">int</span> t=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;a.<span class="keyword">size</span>()||t; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(i&lt;a.<span class="keyword">size</span>())	t+=b*a[i];</span><br><span class="line">		C.push_back(t%10);</span><br><span class="line">		t/=<span class="number">10</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="除法"><a href="#除法" class="headerlink" title="除法"></a>除法</h1><p>&emsp;&emsp;此时需要倒着遍历，因为除法运算需要从最高为开始除，最后需要把结果倒置并去除前置0。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="built_in">int</span>&gt; div(vector&lt;<span class="built_in">int</span>&gt; &amp;a, <span class="built_in">int</span> b, <span class="built_in">int</span> &amp;r)</span><br><span class="line">&#123;</span><br><span class="line">	vector&lt;<span class="built_in">int</span>&gt; C;</span><br><span class="line">	r=<span class="number">0</span>;</span><br><span class="line">	for(<span class="built_in">int</span> i=a.size<span class="literal">()</span>-<span class="number">1</span>; i&gt;=<span class="number">0</span>; --i)</span><br><span class="line">	&#123;</span><br><span class="line">		r=r*<span class="number">10</span>+a<span class="literal">[<span class="identifier">i</span>]</span>;</span><br><span class="line">		<span class="module-access"><span class="module"><span class="identifier">C</span>.</span></span>push<span class="constructor">_back(<span class="params">r</span><span class="operator">/</span><span class="params">b</span>)</span>;</span><br><span class="line">		r=r%b;</span><br><span class="line">	&#125;</span><br><span class="line">	reverse(<span class="module-access"><span class="module"><span class="identifier">C</span>.</span></span><span class="keyword">begin</span><span class="literal">()</span>, <span class="module-access"><span class="module"><span class="identifier">C</span>.</span></span><span class="keyword">end</span><span class="literal">()</span>);</span><br><span class="line">	<span class="keyword">while</span>(<span class="module-access"><span class="module"><span class="identifier">C</span>.</span></span>size<span class="literal">()</span>&gt;<span class="number">1</span><span class="operator"> &amp;&amp; </span><span class="module-access"><span class="module"><span class="identifier">C</span>.</span></span>back<span class="literal">()</span>==<span class="number">0</span>)	<span class="module-access"><span class="module"><span class="identifier">C</span>.</span></span>pop<span class="constructor">_back()</span>;</span><br><span class="line">	return C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法笔记</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>排序算法</title>
    <url>/2019/11/04/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>简介： 常用的排序算法</p>
<a id="more"></a>
<h1 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h1><p>&emsp;&emsp;每次从未排序序列中选最小的一个数插入到前面已排序序列</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*          选择排序   1&lt;=i&lt;=n</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">#<span class="keyword">if</span> <span class="number">0</span></span><br><span class="line"><span class="built_in">int</span> A&#123;maxn&#125;, n; </span><br><span class="line"><span class="built_in">void</span> SelectSort()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">1</span>; i&lt;=n; ++i)        <span class="comment">//进行n趟操作 </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">int</span> k=i;</span><br><span class="line">		<span class="keyword">for</span>(<span class="built_in">int</span> j=i; j&lt;=n; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(A[k]&gt;A[j])             <span class="comment">//比前面大，记录下来 </span></span><br><span class="line">			&#123;</span><br><span class="line">				k=j;</span><br><span class="line">			&#125; </span><br><span class="line">		&#125;</span><br><span class="line">		swap(A[k], A[i]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h1><p>&emsp;&emsp;遍历数组，将遍历到的值插入前面已排序序列中</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*          插入排序   1&lt;=i&lt;=n</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> A[maxn], n;</span><br><span class="line"><span class="built_in">void</span> InsertSort()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">2</span>; i&lt;=n; ++i)        <span class="comment">//进行n-1趟查找 </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">int</span> temp=A[i],j=i;	</span><br><span class="line">		<span class="keyword">while</span>(A[j<span class="number">-1</span>]&gt;temp &amp;&amp; j&gt;<span class="number">1</span>)   <span class="comment">//只要temp小于前面一个元素 </span></span><br><span class="line">		&#123;</span><br><span class="line">			A[j]=A[j<span class="number">-1</span>];           <span class="comment">//覆盖</span></span><br><span class="line">			j--; </span><br><span class="line">		&#125;</span><br><span class="line">		A[j]=temp;         <span class="comment">//插入 </span></span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><p>&emsp;&emsp;冒n-1趟，每次把最小的/最大的冒泡的顶端</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*          冒泡排序   0&lt;i&lt;n</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> A[maxn], n;</span><br><span class="line"><span class="built_in">void</span> BubbleSort()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>; i&lt;n<span class="number">-1</span>; ++i)          <span class="comment">//n-1次排序 </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">bool</span> flag =<span class="literal">false</span>;          <span class="comment">//只要某一趟没有交换元素，则说明排序完成 </span></span><br><span class="line">		<span class="keyword">for</span>(<span class="built_in">int</span> j=<span class="number">0</span>; j&lt;n-i<span class="number">-1</span>; ++j)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(A[j+<span class="number">1</span>] &lt; A[j])</span><br><span class="line">			&#123;</span><br><span class="line">				swap(A[j], A[j+<span class="number">1</span>]);</span><br><span class="line">				flag=<span class="literal">true</span>;        <span class="comment">//交换了元素 </span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;	</span><br><span class="line">		<span class="keyword">if</span>(!flag)	<span class="keyword">break</span>; </span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><p>&emsp;&emsp;把区间分为若干等份，每次取n等份排序，到最后一次的时候序列就为有序序列</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*          归并排序   0&lt;i&lt;n         </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">void</span> merge(<span class="built_in">int</span> s[], <span class="built_in">int</span> l, <span class="built_in">int</span> r)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(l&gt;=r)	<span class="keyword">return</span> ;   <span class="comment">//当l=r时没必要再排序 </span></span><br><span class="line">	<span class="built_in">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	merge(s,l,mid);</span><br><span class="line">	merge(s,mid+<span class="number">1</span>,r);</span><br><span class="line">	<span class="built_in">int</span> k=<span class="number">0</span>,i=l,j=mid+<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(i&lt;=mid &amp;&amp; j&lt;=r)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(s[i]&lt;s[j])	temp[k++]=s[i++];</span><br><span class="line">		<span class="keyword">else</span>	temp[k++]=s[j++];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(i&lt;=mid)	temp[k++]=s[i++];</span><br><span class="line">	<span class="keyword">while</span>(j&lt;=r)	temp[k++]=s[j++];</span><br><span class="line">	<span class="keyword">for</span>(<span class="built_in">int</span> i=l,j=<span class="number">0</span>; i&lt;=r; i++,j++)	s[i]=temp[j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><p>&emsp;&emsp;每次选取一个主元，一次排序后主元左边的数都小于等于它，右边的数都大于等于它</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*          快速排序   0&lt;i&lt;n         </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">void quick<span class="constructor">_sort(<span class="params">int</span> <span class="params">q</span>[], <span class="params">int</span> <span class="params">l</span>, <span class="params">int</span> <span class="params">r</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&gt;=r)    return ;<span class="comment">//只有一个数不用再排序</span></span><br><span class="line">    <span class="built_in">int</span> i = l-<span class="number">1</span>,j = r+<span class="number">1</span>,x = q<span class="literal">[<span class="identifier">l</span>+<span class="identifier">r</span>&gt;&gt;<span class="number">1</span>]</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; j) <span class="comment">//最后i和j会相差1</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">do</span> i++; <span class="keyword">while</span>(q<span class="literal">[<span class="identifier">i</span>]</span> &lt; x);</span><br><span class="line">        <span class="keyword">do</span> j--; <span class="keyword">while</span>(q<span class="literal">[<span class="identifier">j</span>]</span> &gt; x);</span><br><span class="line">        <span class="keyword">if</span>(i&lt;j) swap(q<span class="literal">[<span class="identifier">i</span>]</span>, q<span class="literal">[<span class="identifier">j</span>]</span>);     <span class="comment">//因为最后确定位置的数不知道在哪，所以两边都要递归</span></span><br><span class="line">    &#125;</span><br><span class="line">    quick<span class="constructor">_sort(<span class="params">q</span>, <span class="params">l</span>, <span class="params">j</span>)</span>;               <span class="comment">//不用i的原因是，比如 1，2两个数的情况会出错 分为两边，一边小于等于一边大于等于 --------j-i-1----------- </span></span><br><span class="line">                                <span class="comment">//可以这样改：用i的时候x不能为左边界，用j的时候x不能为有边界，改q[l+r&gt;&gt;1]即可</span></span><br><span class="line">    quick<span class="constructor">_sort(<span class="params">q</span>, <span class="params">j</span>+1, <span class="params">r</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h1><p>&emsp;&emsp;类似于数，每次都用down或者up操作不断上升/下降，直到整个堆有序，此时每个父节点都大于/小于它的子节点</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">100010</span>;</span><br><span class="line"><span class="keyword">int</span> heap[maxn],size;</span><br><span class="line"><span class="keyword">int</span> m,n;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">down</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> t=u;</span><br><span class="line">	<span class="keyword">if</span>(u*<span class="number">2</span>&lt;=size &amp;&amp; heap[u*<span class="number">2</span>]&lt;heap[t])     	t=u*<span class="number">2</span>;  <span class="comment">//有左儿子并且小于它 </span></span><br><span class="line">	<span class="keyword">if</span>(u*<span class="number">2</span>+<span class="number">1</span>&lt;=size &amp;&amp; heap[u*<span class="number">2</span>+<span class="number">1</span>]&lt;heap[t])	t=u*<span class="number">2</span>+<span class="number">1</span>; <span class="comment">//有右儿子并且小于它 </span></span><br><span class="line">	<span class="keyword">if</span>(u!=t)</span><br><span class="line">	&#123;</span><br><span class="line">		swap(heap[t], heap[u]);</span><br><span class="line">		down(t);            <span class="comment">//递归dowm下去 </span></span><br><span class="line">	 &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">up</span><span class="params">(<span class="keyword">int</span> u)</span>   <span class="comment">//插入使用 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(u/<span class="number">2</span> &amp;&amp; heap[u/<span class="number">2</span>]&gt;heap[u])  <span class="comment">//有祖先并且祖先比它大 </span></span><br><span class="line">	&#123;</span><br><span class="line">		swap(heap[u], heap[u/<span class="number">2</span>]);</span><br><span class="line">		u/=<span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)	<span class="built_in">cin</span>&gt;&gt;heap[i];</span><br><span class="line">	size=n;        <span class="comment">//size指向最后一个元素 </span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=n/<span class="number">2</span>; i; --i)	down(i);          <span class="comment">//利用二叉树性质，最后一个父节点开始down </span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=<span class="number">6</span>; i++)	<span class="built_in">cout</span>&lt;&lt;heap[i]&lt;&lt;<span class="string">' '</span>;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">while</span>(m--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;heap[<span class="number">1</span>]&lt;&lt;<span class="string">" "</span>; </span><br><span class="line">		heap[<span class="number">1</span>]=heap[size];      <span class="comment">//删掉堆顶元素 </span></span><br><span class="line">		size--;    <span class="comment">//删掉元素</span></span><br><span class="line">		down(<span class="number">1</span>); </span><br><span class="line">	 &#125; 	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法笔记</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>查找算法</title>
    <url>/2019/11/04/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>简介： 常用的查找算法</p>
<a id="more"></a>
<h1 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h1><p>&emsp;&emsp;每次去中点mid，然后将区间分为两部分</p>
<figure class="highlight excel"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">*			二分查找  区间为【<span class="built_in">left</span>，<span class="built_in">right</span>】，均为闭区间，传入的初始值为【<span class="number">0</span>，<span class="built_in">n</span>-<span class="number">1</span>】 </span><br><span class="line">*/ </span><br><span class="line"><span class="built_in">int</span> BinarySearch(<span class="built_in">int</span> A[], <span class="built_in">int</span> <span class="built_in">left</span>, <span class="built_in">int</span> <span class="built_in">right</span>, <span class="built_in">int</span> x)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">int</span> <span class="built_in">mid</span>;</span><br><span class="line">	while(<span class="built_in">left</span>&lt;=<span class="built_in">right</span>)             //此处为&lt;= </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">mid</span>=(<span class="built_in">left</span>+<span class="built_in">right</span>)/<span class="number">2</span>;</span><br><span class="line">		<span class="built_in">if</span>(A[<span class="built_in">mid</span>]==x)</span><br><span class="line">		&#123;</span><br><span class="line">			return <span class="built_in">mid</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		else <span class="built_in">if</span>(A[<span class="built_in">mid</span>]&gt;x)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">right</span>=<span class="built_in">mid</span>-<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		else</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">left</span>=<span class="built_in">mid</span>+<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return -<span class="number">1</span>;              //查找失败 </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="二分查找-将区间分为-left-mid-1-mid-right"><a href="#二分查找-将区间分为-left-mid-1-mid-right" class="headerlink" title="二分查找(将区间分为[left,mid-1],[mid, right])"></a>二分查找(将区间分为[left,mid-1],[mid, right])</h1><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 区间[l, r]被划分成[l, mid - 1]和[mid, r]时使用</span></span><br><span class="line"><span class="built_in">int</span> bsearch_1(<span class="built_in">int</span> l, <span class="built_in">int</span> r)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">while</span>(l&lt;r)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">int</span> mid=l+r+<span class="number">1</span>&gt;&gt;<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(check(mid))	l=mid;</span><br><span class="line">		<span class="keyword">else</span> r=mid<span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="二分查找-将区间分为-left-mid-mid-1-right"><a href="#二分查找-将区间分为-left-mid-mid-1-right" class="headerlink" title="二分查找(将区间分为[left, mid],[mid+1, right])"></a>二分查找(将区间分为[left, mid],[mid+1, right])</h1><p>&emsp;&emsp;此时计算mid时需要取left+right&gt;&gt;1。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用</span></span><br><span class="line"><span class="built_in">int</span> bsearch_1(<span class="built_in">int</span> l, <span class="built_in">int</span> r)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">while</span>(l&lt;r)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(check(mid))	r=mid;</span><br><span class="line">		<span class="keyword">else</span> l=mid+<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="浮点数二分"><a href="#浮点数二分" class="headerlink" title="浮点数二分"></a>浮点数二分</h1><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//浮点数二分</span></span><br><span class="line"><span class="built_in">double</span> bsearch_1(<span class="built_in">double</span> l, <span class="built_in">double</span> r)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">const</span> <span class="built_in">double</span> eps=<span class="number">1e-8</span>;</span><br><span class="line">	<span class="keyword">while</span>(r-l&gt;eps)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">double</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(check(mid))	r=mid;</span><br><span class="line">		<span class="keyword">else</span>	l=mid;	</span><br><span class="line">	&#125;	</span><br><span class="line">	<span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法笔记</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>echo服务器</title>
    <url>/2019/11/04/echo%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
    <content><![CDATA[<p>简介： echo客户端&amp;服务器</p>
<a id="more"></a>
<h1 id="echo客户端"><a href="#echo客户端" class="headerlink" title="echo客户端"></a>echo客户端</h1><h2 id="main函数-amp-open-clientfd函数"><a href="#main函数-amp-open-clientfd函数" class="headerlink" title="main函数 &amp; open_clientfd函数"></a>main函数 &amp; open_clientfd函数</h2><p>&emsp;&emsp;echo客户端输入两个参数，一个是服务器的ip，一个是服务器的端口，将ip与端口传入open_clientfd函数获取一个已连接描述符。在和服务器连接以后，客户端应该进入一个循环，反复从标准输入读取文本行，发送文本行给服务器，从服务器读取回送的行，并输出结果到标准输出。当fgets在标准输入上遇到EOF时，或者因为用户在键盘上输入ctrl+D，或者在遇到一个重定向的输入文件中用尽了所有的文本行时，循环截止。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">open_clientfd</span><span class="params">(<span class="keyword">char</span> *hostname, <span class="keyword">char</span> *port)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> clientfd;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">addrinfo</span> *<span class="title">p</span>,*<span class="title">listp</span>,<span class="title">hints</span>;</span></span><br><span class="line">	<span class="built_in">memset</span>(&amp;hints, <span class="number">0</span>, <span class="keyword">sizeof</span>(struct addrinfo));</span><br><span class="line">	hints.ai_socktype = SOCK_STREAM;</span><br><span class="line">	hints.ai_flags = AI_NUMERICSERV | AI_ADDRCONFIG | AI_PASSIVE;</span><br><span class="line">	<span class="comment">//ai_addrconfig 只有当主机配置为ipv4时，getaddrinfo返回ipv4</span></span><br><span class="line">	<span class="comment">//ai_passive 使得getaddrinfo默认返回套接字地址</span></span><br><span class="line">	<span class="comment">//ai_numericserv 强制第二个参数service默认为端口号 </span></span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	getaddrinfo(hostname, port, &amp;hints, &amp;listp);</span><br><span class="line">	<span class="keyword">for</span>(p=listp; p; p=p-&gt;ai_next)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>((clientfd = socket(p-&gt;ai_family, p-&gt;ai_socktype, p-&gt;ai_protocol)) &lt; <span class="number">0</span>)	<span class="keyword">continue</span>;</span><br><span class="line">		<span class="comment">// 通过connect建立与服务器的连接</span></span><br><span class="line">		<span class="comment">// int connect(int clientfd, const struct sockaddr *addr, socklen_t adddrlen)</span></span><br><span class="line">		<span class="keyword">if</span>(connect(clientfd, p-&gt;ai_addr, p-&gt;ai_addrlen) != <span class="number">-1</span>)	<span class="keyword">break</span>;</span><br><span class="line">		close(clientfd); </span><br><span class="line">	&#125;</span><br><span class="line">	freeaddrinfo(listp);</span><br><span class="line">	<span class="keyword">if</span>(!p)	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> clientfd;      <span class="comment">//客户端不需要监听 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> clientfd;</span><br><span class="line">	<span class="keyword">char</span> *host, *port, buf[MAXNLINE];</span><br><span class="line">	<span class="keyword">rio_t</span> rio;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(argc != <span class="number">3</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"usage: %s &lt;host&gt; &lt;port&gt;\n"</span>, argv[<span class="number">0</span>]);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;		</span><br><span class="line">	&#125;	</span><br><span class="line">	host = argv[<span class="number">1</span>], port = argv[<span class="number">2</span>];</span><br><span class="line">	clientfd = open_clientfd(host, port);	</span><br><span class="line">	rio_readinitb(&amp;rio, clientfd);</span><br><span class="line">	<span class="keyword">while</span>(fgets(buf, MAXNLINE, <span class="built_in">stdin</span>) != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		rio_writen(clientfd, buf, <span class="built_in">strlen</span>(buf));</span><br><span class="line">		rio_readlineb(&amp;rio, buf, MAXNLINE);  <span class="comment">//服务器写回来再让客户端读 </span></span><br><span class="line">		<span class="built_in">fputs</span>(buf, <span class="built_in">stdout</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	close(clientfd);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="rio函数"><a href="#rio函数" class="headerlink" title="rio函数"></a>rio函数</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LISTENQ 1024</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RIOBUFSIZE 1024*8</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXNLINE 1024*8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> rio_fd,rio_cnt;</span><br><span class="line">	<span class="keyword">char</span> rio_buf[RIOBUFSIZE], *rio_bufptr;</span><br><span class="line">&#125;<span class="keyword">rio_t</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">ssize_t</span> rio_writen(<span class="keyword">int</span> fd, <span class="keyword">void</span> *usrbuf, <span class="keyword">size_t</span> n)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">size_t</span> nleft=n;</span><br><span class="line">	<span class="keyword">size_t</span> nwritten;</span><br><span class="line">	<span class="keyword">char</span> *buf = usrbuf;</span><br><span class="line">	<span class="keyword">while</span>(nleft &gt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>((nwritten = write(fd, buf, nleft)) &lt;= <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(errno == EINTR)	nwritten=<span class="number">0</span>;      <span class="comment">//中断了 </span></span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		nleft -= nwritten;</span><br><span class="line">		buf += nwritten;</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> n;	</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">ssize_t</span> rio_read(<span class="keyword">rio_t</span> *rp, <span class="keyword">char</span> *rc, <span class="keyword">size_t</span> n)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> cnt;</span><br><span class="line">	<span class="keyword">while</span>(rp-&gt;rio_cnt &lt;= <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		rp-&gt;rio_cnt=read(rp-&gt;rio_fd, rp-&gt;rio_buf, <span class="keyword">sizeof</span>(rp-&gt;rio_buf));</span><br><span class="line">		<span class="keyword">if</span>(rp-&gt;rio_cnt &lt; <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(errno != EINTR)	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(rp-&gt;rio_cnt == <span class="number">0</span>)	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">else</span> rp-&gt;rio_bufptr = rp-&gt;rio_buf;</span><br><span class="line">	&#125;</span><br><span class="line">	cnt = n;</span><br><span class="line">	<span class="keyword">if</span>(rp-&gt;rio_cnt &lt; n)	cnt=rp-&gt;rio_cnt;</span><br><span class="line">	<span class="built_in">memcpy</span>(rc, rp-&gt;rio_bufptr, cnt);</span><br><span class="line">	rp-&gt;rio_bufptr+=cnt;</span><br><span class="line">	rp-&gt;rio_cnt-=cnt;</span><br><span class="line">	<span class="keyword">return</span> cnt;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">ssize_t</span> rio_readlineb(<span class="keyword">rio_t</span> *rio, <span class="keyword">void</span> *usrbuf, <span class="keyword">size_t</span> maxlen)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">char</span> *buf=usrbuf, c;</span><br><span class="line">	<span class="keyword">int</span> n,rc;</span><br><span class="line">	<span class="keyword">for</span>(n=<span class="number">1</span>; n&lt;maxlen; n++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>((rc = rio_read(rio, &amp;c, <span class="number">1</span>)) == <span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			*buf++ = c;</span><br><span class="line">			<span class="keyword">if</span>(c==<span class="string">'\n'</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				n++;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(rc == <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(n==<span class="number">1</span>)	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	*buf = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> n<span class="number">-1</span>;</span><br><span class="line">		</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rio_readinitb</span><span class="params">(<span class="keyword">rio_t</span> *rio, <span class="keyword">int</span> fd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	rio-&gt;rio_fd=fd;</span><br><span class="line">	rio-&gt;rio_cnt=<span class="number">0</span>;</span><br><span class="line">	rio-&gt;rio_bufptr=rio-&gt;rio_buf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="echo服务器-普通版"><a href="#echo服务器-普通版" class="headerlink" title="echo服务器(普通版)"></a>echo服务器(普通版)</h1><h2 id="main函数-amp-open-listenfd函数"><a href="#main函数-amp-open-listenfd函数" class="headerlink" title="main函数 &amp; open_listenfd函数"></a>main函数 &amp; open_listenfd函数</h2><p>&emsp;&emsp;服务器主程序，打开监听描述符，进入循环，等待一个来自客户端的连接请求，输出已连接的客户端域名和IP地址，并调用echo函数为这个客户端服务，在echo程序返回之后，主程序关闭已连接的描述符，一旦客户端和服务器都关闭了他们各自的描述符，连接终止。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">open_listenfd</span><span class="params">(<span class="keyword">char</span> *port)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">addrinfo</span> <span class="title">hints</span>,*<span class="title">p</span>,*<span class="title">listp</span>;</span></span><br><span class="line">    <span class="keyword">int</span> listenfd, optval=<span class="number">1</span>,rc;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;hints, <span class="number">0</span>, <span class="keyword">sizeof</span>(struct addrinfo));</span><br><span class="line">    hints.ai_socktype=SOCK_STREAM;</span><br><span class="line">    hints.ai_flags = AI_PASSIVE | AI_ADDRCONFIG;</span><br><span class="line">    hints.ai_flags |= AI_NUMERICSERV;</span><br><span class="line">    <span class="comment">//socket----&gt;bind----&gt;listen</span></span><br><span class="line">    getaddrinfo(<span class="literal">NULL</span>, port, &amp;hints, &amp;listp);</span><br><span class="line">   <span class="comment">// if(listp == NULL) </span></span><br><span class="line">    <span class="keyword">for</span>(p=listp; p; p=p-&gt;ai_next)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>((listenfd=socket(p-&gt;ai_family, p-&gt;ai_socktype, p-&gt;ai_protocol)) &lt; <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">       <span class="keyword">if</span>((rc= setsockopt(listenfd, SOL_SOCKET, SO_REUSEADDR, &amp; optval, <span class="keyword">sizeof</span>(<span class="keyword">int</span>))) &lt; <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, strerror(errno));</span><br><span class="line">        <span class="keyword">if</span>(bind(listenfd, p-&gt;ai_addr, p-&gt;ai_addrlen) == <span class="number">0</span>)     <span class="comment">//printf("%s\n", strerror(errno)); //break;</span></span><br><span class="line">        		<span class="keyword">break</span>;</span><br><span class="line">		close(listenfd);</span><br><span class="line">    &#125;</span><br><span class="line">    freeaddrinfo(listp);</span><br><span class="line">    <span class="keyword">if</span>(!p)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(listen(listenfd, LISTENQ) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        close(listenfd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> listenfd;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> listenfd, connfd;</span><br><span class="line">	<span class="keyword">socklen_t</span> clientlen;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_storage</span> <span class="title">clientaddr</span>;</span></span><br><span class="line">	<span class="keyword">char</span> client_hostname[MAXNLINE], client_port[MAXNLINE];</span><br><span class="line">	<span class="keyword">if</span>(argc != <span class="number">2</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"usage: %s &lt;port&gt;\n"</span>, argv[<span class="number">0</span>]);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;	</span><br><span class="line">	&#125;	</span><br><span class="line">	listenfd = open_listenfd(argv[<span class="number">1</span>]);</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		clientlen = <span class="keyword">sizeof</span>(clientaddr);</span><br><span class="line">		connfd = accept(listenfd, (struct sockaddr *)&amp;clientaddr, &amp;clientlen);</span><br><span class="line">		getnameinfo((struct sockaddr *)&amp;clientaddr, clientlen, client_hostnmae, MAXNLINE, client_port, MAXNLINE, <span class="number">0</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Connected to (%s %s)\n"</span>, client_hostname, client_port);</span><br><span class="line">		echo(connfd);</span><br><span class="line">		close(connfd);</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="echo函数"><a href="#echo函数" class="headerlink" title="echo函数"></a>echo函数</h2><p>&emsp;&emsp;服务器调用echo函数读取从客户端传来的数据，读完以后再写回客户端让客户端读取输出。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">void echo(<span class="built_in">int</span> connfd)</span><br><span class="line">&#123;</span><br><span class="line">	size_t n;</span><br><span class="line">	<span class="built_in">char</span> buf<span class="literal">[MAXNLINE]</span>;</span><br><span class="line">	rio_t rio;</span><br><span class="line">	rio<span class="constructor">_readinitb(&amp;<span class="params">rio</span>, <span class="params">connfd</span>)</span>;</span><br><span class="line">	<span class="keyword">while</span>((n=rio<span class="constructor">_readlineb(&amp;<span class="params">rio</span>, <span class="params">buf</span>, MAXNLINE)</span>) != <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		printf(<span class="string">"serve received %d bytes\n"</span>, (<span class="built_in">int</span>)n);</span><br><span class="line">		rio<span class="constructor">_writen(<span class="params">connfd</span>, <span class="params">buf</span>, <span class="params">n</span>)</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="echo服务器-基于进程并发"><a href="#echo服务器-基于进程并发" class="headerlink" title="echo服务器(基于进程并发)"></a>echo服务器(基于进程并发)</h1><h2 id="main函数"><a href="#main函数" class="headerlink" title="main函数"></a>main函数</h2><p>&emsp;&emsp;利用SIGCHLD信号，在一个进程终止或者停止时，将SIGCHLD信号发送给其父进程，按系统默认将忽略此信号。建立连接后，创建一个子进程，再子进程中进行操作，最后由父进程回收子进程资源。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> listenfd, connfd;</span><br><span class="line">	<span class="keyword">socklen_t</span> clientlen;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_storage</span> <span class="title">clientaddr</span>;</span></span><br><span class="line">	<span class="keyword">if</span>(argc != <span class="number">2</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"usage: %s &lt;port&gt;\n"</span>, argv[<span class="number">0</span>]);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	listenfd = open_listenfd(argv[<span class="number">1</span>]);</span><br><span class="line">	signal(SIGCHLD, sigchld_handler);  <span class="comment">//signal（参数1，参数2） 参数1：我们要进行处理的信号。参数2：我们处理的方式</span></span><br><span class="line">	<span class="comment">//  在一个进程终止或者停止时，将SIGCHLD信号发送给其父进程，按系统默认将忽略此信号</span></span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		clientlen = <span class="keyword">sizeof</span>(struct sockaddr_storage);</span><br><span class="line">		connfd = accept(listenfd, (struct sockaddr *)&amp; clientaddr, &amp;clientlen);</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(fork() == <span class="number">0</span>)     <span class="comment">//子进程 </span></span><br><span class="line">		&#123;</span><br><span class="line">			close(listenfd);       <span class="comment">//关闭副本中的监听描述符 </span></span><br><span class="line">			echo(connfd);</span><br><span class="line">			close(connfd);</span><br><span class="line">			<span class="built_in">exit</span>(<span class="number">0</span>); </span><br><span class="line">		&#125;</span><br><span class="line">		close(connfd);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="sigchld-handler函数"><a href="#sigchld-handler函数" class="headerlink" title="sigchld_handler函数"></a>sigchld_handler函数</h2><p>&emsp;&emsp;当能回收到子进程时，就一直循环，若退出，说明子进程以及全部回收完毕。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">void</span> sigchld_handler(<span class="built_in">int</span> sig)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">while</span>(waitpid(<span class="number">-1</span>, <span class="number">0</span>, WNOHANG) &gt; <span class="number">0</span>) ;        <span class="comment">//-1表示回收任意子进程 </span></span><br><span class="line">	<span class="comment">//正常返回回收id，，没有回收返回0，，出错返回-1</span></span><br><span class="line">	<span class="keyword">return</span> ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="echo函数-1"><a href="#echo函数-1" class="headerlink" title="echo函数"></a>echo函数</h2><p>&emsp;&emsp;服务器调用echo函数读取从客户端传来的数据，读完以后再写回客户端让客户端读取输出。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">void echo(<span class="built_in">int</span> connfd)</span><br><span class="line">&#123;</span><br><span class="line">	size_t n;</span><br><span class="line">	<span class="built_in">char</span> buf<span class="literal">[MAXNLINE]</span>;</span><br><span class="line">	rio_t rio;</span><br><span class="line">	rio<span class="constructor">_readinitb(&amp;<span class="params">rio</span>, <span class="params">connfd</span>)</span>;</span><br><span class="line">	<span class="keyword">while</span>((n=rio<span class="constructor">_readlineb(&amp;<span class="params">rio</span>, <span class="params">buf</span>, MAXNLINE)</span>) != <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		printf(<span class="string">"serve received %d bytes\n"</span>, (<span class="built_in">int</span>)n);</span><br><span class="line">		rio<span class="constructor">_writen(<span class="params">connfd</span>, <span class="params">buf</span>, <span class="params">n</span>)</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="echo服务器-基于I-O多路复用"><a href="#echo服务器-基于I-O多路复用" class="headerlink" title="echo服务器(基于I/O多路复用)"></a>echo服务器(基于I/O多路复用)</h1><h2 id="main函数-1"><a href="#main函数-1" class="headerlink" title="main函数"></a>main函数</h2><p>&emsp;&emsp;利用一个read_set，其类似与一个数组，初始时使FD_SET把已连接描述符位和STDIN_FILENO位置为1，调用select函数，若FD_ISSET为true，则证明是客户端输入/服务端输入，此时再进行下一步操作,其中select函数在sys/select.h中。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> main(<span class="built_in">int</span> argc, <span class="built_in">char</span> **argv)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">int</span> listenfd, connfd;</span><br><span class="line">	socklen_t clientlen;</span><br><span class="line">	<span class="keyword">struct</span> sockaddr_storage clientaddr;</span><br><span class="line">	fd_set read_set, ready_set;</span><br><span class="line">	<span class="keyword">if</span>(argc!=<span class="number">2</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		fprintf(stderr, <span class="string">"usage: %s &lt;port&gt;\n"</span>, argv<span class="literal">[<span class="number">0</span>]</span>);</span><br><span class="line">		exit(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	listenfd = <span class="keyword">open</span><span class="constructor">_listen(<span class="params">argv</span>[1])</span>;</span><br><span class="line">	<span class="constructor">FD_ZERO(&amp;<span class="params">read_set</span>)</span></span><br><span class="line">	<span class="comment">// stdin类型为 FILE*</span></span><br><span class="line">    <span class="comment">//   STDIN_FILENO类型为 int</span></span><br><span class="line">    <span class="comment">// STDIN_FILENO    0    -----  STDOUT_FILENO   1  -----  STDERR_FILENO   2</span></span><br><span class="line">	<span class="constructor">FD_SET(STDIN_FILENO, &amp;<span class="params">read_set</span>)</span>;</span><br><span class="line">	<span class="constructor">FD_SET(LISTENFD, &amp;<span class="params">readset</span>)</span>;          <span class="comment">//把listenfd与标准输入位置为1</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		ready_set = read_set;</span><br><span class="line">		select(listenfd+<span class="number">1</span>, &amp;ready_set, NULL, NULL, NULL);	</span><br><span class="line">		<span class="keyword">if</span>(<span class="constructor">FD_ISSET(STDIN_FILENO, &amp;<span class="params">ready_set</span>)</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			command<span class="literal">()</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(<span class="constructor">FD_ISSET(<span class="params">listenfd</span>, &amp;<span class="params">ready_set</span>)</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			clientlen=sizeof(<span class="keyword">struct</span> sockaddr_storage);</span><br><span class="line">			connfd=accept(listenfd, (<span class="keyword">struct</span> sockaddr*)&amp; clientaddr, &amp;clientlen);</span><br><span class="line">			echo(connfd);</span><br><span class="line">			close(connfd);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="command函数"><a href="#command函数" class="headerlink" title="command函数"></a>command函数</h2><p>&emsp;&emsp;若为服务端输入，调用command函数，读取终端输入的字符串。</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">void command()   <span class="regexp">//</span>当STDIN_FILENO为<span class="number">1</span>时，会读取输入 </span><br><span class="line">&#123;</span><br><span class="line">	char buf[MAXNLINE];</span><br><span class="line">	<span class="keyword">if</span>(fgets(buf, MAXNLINE, stdin) != NULL)</span><br><span class="line">	&#123;</span><br><span class="line">		printf(<span class="string">"%s"</span>, buf);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>	<span class="keyword">exit</span>(<span class="number">0</span>);       <span class="regexp">//</span>EOF,什么都没有读到 </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="echo函数-2"><a href="#echo函数-2" class="headerlink" title="echo函数"></a>echo函数</h2><p>&emsp;&emsp;服务器调用echo函数读取从客户端传来的数据，读完以后再写回客户端让客户端读取输出。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">void echo(<span class="built_in">int</span> connfd)</span><br><span class="line">&#123;</span><br><span class="line">	size_t n;</span><br><span class="line">	<span class="built_in">char</span> buf<span class="literal">[MAXNLINE]</span>;</span><br><span class="line">	rio_t rio;</span><br><span class="line">	rio<span class="constructor">_readinitb(&amp;<span class="params">rio</span>, <span class="params">connfd</span>)</span>;</span><br><span class="line">	<span class="keyword">while</span>((n=rio<span class="constructor">_readlineb(&amp;<span class="params">rio</span>, <span class="params">buf</span>, MAXNLINE)</span>) != <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		printf(<span class="string">"serve received %d bytes\n"</span>, (<span class="built_in">int</span>)n);</span><br><span class="line">		rio<span class="constructor">_writen(<span class="params">connfd</span>, <span class="params">buf</span>, <span class="params">n</span>)</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="echo服务器-基于I-O多路复用且适用于并发事件"><a href="#echo服务器-基于I-O多路复用且适用于并发事件" class="headerlink" title="echo服务器(基于I/O多路复用且适用于并发事件)"></a>echo服务器(基于I/O多路复用且适用于并发事件)</h1><h2 id="状态机"><a href="#状态机" class="headerlink" title="状态机"></a>状态机</h2><p>&emsp;&emsp;状态机就是一组状态、输入时间、和转移，其中转移是将状态和输入事件映射到状态。<br><img src="https://s2.ax1x.com/2019/11/06/MPa00A.png" alt=""></p>
<h2 id="pool-结构体"><a href="#pool-结构体" class="headerlink" title="pool 结构体"></a>pool 结构体</h2><p>&emsp;&emsp;pool结构体中维护着客户端的集合，当一个连接请求到达时，服务器打开连接，将该客户端添加到池中。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span>  maxfd;   <span class="comment">//read_set最大的描述符 </span></span><br><span class="line">	fd_set read_set,ready_set;  <span class="comment">//描述符集合 </span></span><br><span class="line">	<span class="keyword">int</span> nready, maxi;        <span class="comment">//nready表示就绪的描述符数 ，maxi表示新加入到pool中的clientfd下标（到clientfd数组的最大索引） </span></span><br><span class="line">	<span class="keyword">int</span> clientfd[FD_SETSIZE];  <span class="comment">//活动的描述符的集合 </span></span><br><span class="line">	<span class="keyword">rio_t</span> clientrio[FD_SETSIZE];   <span class="comment">//存取缓存集合 </span></span><br><span class="line">&#125;pool;          <span class="comment">//线程池</span></span><br></pre></td></tr></table></figure>

<h2 id="init-pool-函数"><a href="#init-pool-函数" class="headerlink" title="init_pool 函数"></a>init_pool 函数</h2><p>&emsp;&emsp;初始化pool,clientfd数组表示已连接描述符的集合<br>其中整数-1表示一个可用的槽位。初始时，已连接描述符集合是空的，而且，监听描述符是select读集合中唯一的描述符。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">void init<span class="constructor">_pool(<span class="params">int</span> <span class="params">listenfd</span>, <span class="params">pool</span> <span class="operator">*</span><span class="params">p</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 初始化，此时没有任何已连接描述符</span></span><br><span class="line">	<span class="built_in">int</span> i;</span><br><span class="line">	p-&gt;maxi = -<span class="number">1</span>;</span><br><span class="line">	for(i=<span class="number">0</span>; i&lt;FD_SETSIZE; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		p-&gt;clientfd<span class="literal">[<span class="identifier">i</span>]</span>=-<span class="number">1</span>;      <span class="comment">//没有已连接描述符	</span></span><br><span class="line">	&#125; </span><br><span class="line">	<span class="comment">//初始化，listenfd是read_set唯一的成员</span></span><br><span class="line">	p-&gt;maxfd = listenfd;</span><br><span class="line">	<span class="constructor">FD_ZERO(&amp;<span class="params">p</span>-&gt;<span class="params">read_set</span>)</span>;</span><br><span class="line">	<span class="constructor">FD_SET(<span class="params">listenfd</span>, &amp;<span class="params">p</span>-&gt;<span class="params">read_set</span>)</span>;</span><br></pre></td></tr></table></figure>
<h2 id="main-函数"><a href="#main-函数" class="headerlink" title="main 函数"></a>main 函数</h2><p>&emsp;&emsp;每次都更新新的ready_set，调用select返回准备好的描述符个数，其中只有客户端发起了连接对应的描述符才会就位，超时则会返回0。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> main(<span class="built_in">int</span> argc, <span class="built_in">char</span> **argv)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">int</span> listenfd,connfd;</span><br><span class="line">	socklen_t clientlen;</span><br><span class="line">	<span class="keyword">struct</span> sockaddr_storage clientaddr;</span><br><span class="line">	static pool pool;</span><br><span class="line">	<span class="keyword">if</span>(argc != <span class="number">2</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		fprintf(stderr, <span class="string">"usage: %s &lt;port&gt;\n"</span>, argv<span class="literal">[<span class="number">0</span>]</span>);</span><br><span class="line">		return <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	listenfd = <span class="keyword">open</span><span class="constructor">_listenfd(<span class="params">argv</span>[1])</span>;</span><br><span class="line">	init<span class="constructor">_pool(<span class="params">listenfd</span>, &amp;<span class="params">pool</span>)</span>;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		pool.ready_set=pool.read_set;</span><br><span class="line">		pool.nready=select(pool.maxfd+<span class="number">1</span>, &amp;pool.ready_set, NULL, NULL, NULL);</span><br><span class="line">		<span class="keyword">if</span>(<span class="constructor">FD_ISSET(<span class="params">listenfd</span>, &amp;<span class="params">pool</span>.<span class="params">ready_set</span>)</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			clientlen = sizeof(<span class="keyword">struct</span> sockaddr);</span><br><span class="line">			connfd = accept(listenfd, (<span class="keyword">struct</span> sockaddr*)&amp;clientaddr, &amp;clientlen);</span><br><span class="line">			add<span class="constructor">_client(<span class="params">connfd</span>, &amp;<span class="params">pool</span>)</span>;   <span class="comment">//创建一个新的状态机 </span></span><br><span class="line">		&#125;</span><br><span class="line">		check<span class="constructor">_clients(&amp;<span class="params">pool</span>)</span>;  <span class="comment">//回送输入行，从而执行状态转移，并且当客户端完成文本行发送时，要删除这个状态机 </span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="add-client-函数"><a href="#add-client-函数" class="headerlink" title="add_client 函数"></a>add_client 函数</h2><p>&emsp;&emsp;add_client函数添加一个新客户端到活动客户端池中，在clientfd数组中找到空位后服务器将这个已连接描述符添加到数组中，并初始rio读缓冲区，这样就能使用这个描述符调用rio_readlineb函数，然后将已连接描述符放入select读集合，并更新池中的一些全局属性。</p>
<figure class="highlight xl"><table><tr><td class="code"><pre><span class="line">void add_client(int connfd, pool *p)</span><br><span class="line">&#123;</span><br><span class="line">	int i;</span><br><span class="line">	<span class="function"><span class="title">p</span>-&gt;</span>nready--;          <span class="comment">//就绪的描述符数减一void add_client(int connfd, pool *p)</span></span><br><span class="line">&#123;</span><br><span class="line">	int i;</span><br><span class="line">	<span class="function"><span class="title">p</span>-&gt;</span>nready--;          <span class="comment">//就绪的描述符数减一 </span></span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;FD_SETSIZE; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="function"><span class="title">if</span>(p-&gt;</span>clientfd[i] &lt; <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="function"><span class="title">p</span>-&gt;</span>clientfd[i]=connfd;         <span class="comment">//找到一个空位 </span></span><br><span class="line">			<span class="function"><span class="title">rio_readinitb</span>(&amp;p-&gt;</span>clientrio[i], connfd); </span><br><span class="line">			<span class="comment">//把此描述符加入描述符列表</span></span><br><span class="line">			FD_SET(<span class="function"><span class="title">connfd</span>, &amp;p-&gt;</span>read_set);</span><br><span class="line">			<span class="comment">//更新最大的描述符 和 新加入到pool中的描述符索引</span></span><br><span class="line">			<span class="function"><span class="title">if</span>(connfd &gt; p-&gt;</span>maxfd)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="function"><span class="title">p</span>-&gt;</span>maxfd=connfd;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="function"><span class="title">if</span>(i &gt; p-&gt;</span>maxi)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="function"><span class="title">p</span>-&gt;</span>maxi=i;</span><br><span class="line">			&#125;</span><br><span class="line">			break;          <span class="comment">//更新完退出 </span></span><br><span class="line">		&#125;	</span><br><span class="line">	&#125;	</span><br><span class="line">	<span class="keyword">if</span>(i == FD_SETSIZE)</span><br><span class="line">	&#123;</span><br><span class="line">		fprintf(stderr, <span class="string">"add_client error: Too many clients\n"</span>);	</span><br><span class="line">	&#125; </span><br><span class="line">&#125; </span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;FD_SETSIZE; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="function"><span class="title">if</span>(p-&gt;</span>clientfd[i] &lt; <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="function"><span class="title">p</span>-&gt;</span>clientfd[i]=connfd;         <span class="comment">//找到一个空位 </span></span><br><span class="line">			<span class="function"><span class="title">rio_readinitb</span>(&amp;p-&gt;</span>clientrio[i], connfd); </span><br><span class="line">			<span class="comment">//把此描述符加入描述符列表</span></span><br><span class="line">			FD_SET(<span class="function"><span class="title">connfd</span>, &amp;p-&gt;</span>read_set);</span><br><span class="line">			<span class="comment">//更新最大的描述符 和 新加入到pool中的描述符索引</span></span><br><span class="line">			<span class="function"><span class="title">if</span>(connfd &gt; p-&gt;</span>maxfd)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="function"><span class="title">p</span>-&gt;</span>maxfd=connfd;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="function"><span class="title">if</span>(i &gt; p-&gt;</span>maxi)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="function"><span class="title">p</span>-&gt;</span>maxi=i;</span><br><span class="line">			&#125;</span><br><span class="line">			break;          <span class="comment">//更新完退出 </span></span><br><span class="line">		&#125;	</span><br><span class="line">	&#125;	</span><br><span class="line">	<span class="keyword">if</span>(i == FD_SETSIZE)</span><br><span class="line">	&#123;</span><br><span class="line">		fprintf(stderr, <span class="string">"add_client error: Too many clients\n"</span>);	</span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="check-clients-函数"><a href="#check-clients-函数" class="headerlink" title="check_clients 函数"></a>check_clients 函数</h2><p>&emsp;&emsp;回送来自每个准备好的已连接描述符的一个文本行，如果读到了EOF，则关闭该描述符。</p>
<figure class="highlight xl"><table><tr><td class="code"><pre><span class="line">void check_clients(pool *p)        <span class="comment">//服务准备好的客户端连接 (开始操作)</span></span><br><span class="line">&#123;</span><br><span class="line">	int i,connfd,n;</span><br><span class="line">	char buf[MAXNLINE];</span><br><span class="line">	rio_t rio;</span><br><span class="line">	<span class="function"><span class="title">for</span>(i=0; (i&lt;=p-&gt;</span><span class="function"><span class="title">maxi</span>) &amp;&amp; (p-&gt;</span>nready&gt;<span class="number">0</span>); i++)  <span class="comment">//在存值的范围内查找 </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="function"><span class="title">connfd</span> = p-&gt;</span>clientfd[i];</span><br><span class="line">		<span class="function"><span class="title">rio</span> = p-&gt;</span>clientrio[i];</span><br><span class="line">		<span class="function"><span class="title">if</span>(connfd &gt; 0 &amp;&amp; (FD_ISSET(connfd, &amp;p-&gt;</span>ready_set)))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="function"><span class="title">p</span>-&gt;</span>nready--;      <span class="comment">//开始服务</span></span><br><span class="line">			<span class="keyword">if</span>((n=rio_readlineb(&amp;rio, buf, MAXNLINE)) &gt; <span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				byte_cnt += n;  <span class="comment">//读到了n个字符</span></span><br><span class="line">				printf(<span class="string">"Server received %d (%d total) bytes on fd %d\n"</span>, n, byte_cnt, connfd);</span><br><span class="line">				rio_writen(connfd, buf, n); </span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// EOF时从池中删除描述符</span></span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				close(connfd);   <span class="comment">//关闭连接端 </span></span><br><span class="line">				FD_CLR(<span class="function"><span class="title">connfd</span>, &amp;p-&gt;</span>read_set);   <span class="comment">//清除描述符 </span></span><br><span class="line">				<span class="function"><span class="title">p</span>-&gt;</span>clientfd[i] = -<span class="number">1</span>;</span><br><span class="line">			 &#125; </span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h2 id="I-O多路复用优劣"><a href="#I-O多路复用优劣" class="headerlink" title="I/O多路复用优劣"></a>I/O多路复用优劣</h2><p>优点：<br>&emsp;&emsp;比基于进程的设计给了程序员更多的对程序行为的控制。<br>&emsp;&emsp;基于I/O多路复用的事件驱动服务器运行在单一进程上下文中，因此每个逻辑流都能访问进程的全部地址空间，使得共享数据变得容易。<br>缺点：<br>&emsp;&emsp;编码复杂。。。</p>
]]></content>
      <categories>
        <category>csapp</category>
      </categories>
      <tags>
        <tag>Linux C/C++</tag>
        <tag>网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title>Tiny Web</title>
    <url>/2019/11/04/Tiny%20Web/</url>
    <content><![CDATA[<p>简介： Tiny Web 项目 </p>
<a id="more"></a>


<h1 id="客户端-服务器编程模型"><a href="#客户端-服务器编程模型" class="headerlink" title="客户端-服务器编程模型"></a>客户端-服务器编程模型</h1><p>&emsp;&emsp;客户端-服务器编程模型是一个典型的进程间通信模型。客户端进程和服务器进程通常分处两个不同的主机，如下图所示，客户端发送请求给服务器，服务器从本地资源库中查找需要的资源，然后发送响应给客户端，最后客户端（通常是浏览器）处理这个响应，把结果显示在浏览器上。<br><img src="https://cy-pic.kuaizhan.com/g3/16/84/727b-027a-4fe5-885c-5e3c480ca81200?sign=3d85ce18f45e8dd3544935e1884fddaa&t=1572860741" alt=""></p>
<p>&emsp;&emsp;这个过程看起来很简单，但是我们需要深入具体的实现细节。我们知道，TCP是基于连接的，需要先建立连接才能互相通信。在Linux中，socket为我们提供了方便的解决方案。每一对网络连接称为一个socket对，包括两个端点的socket地址，表示如下：<strong>(cliaddr : cliport, servaddr : servport)</strong></p>
<h1 id="C-S流程图"><a href="#C-S流程图" class="headerlink" title="C/S流程图"></a>C/S流程图</h1><p><img src="https://cy-pic.kuaizhan.com/g3/f0/06/7e7f-cec2-42d4-bf82-0b6eb453137992?sign=5af41daccf2b93eeda432cd7ede0a2b4&t=1572860706" alt=""><br>&emsp;&emsp;服务器调用socket函数获取一个socket，然后调用bind函数绑定本机的IP地址和端口，再调用listen函数开启监听，最后调用accept函数等待直到有客户端发起连接。</p>
<p>&emsp;&emsp;另一方面，客户端调用socket函数获取一个socket，然后调用connect函数向指定服务器发起连接请求，当连接成功或出现错误后返回。若连接成功，服务器端的accept函数也会成功返回，返回另一个已连接的socket（不是最初调用socket函数得到的socket），该socket可以直接用于与客户端通信。而服务器最初的那个socket可以继续循环调用accept函数，等待下一次连接的到来。</p>
<p>&emsp;&emsp;连接成功后，无论是客户端还是服务器，只要向socket读写数据就可以实现与对方socket的通信。图中rio_readlineb和rio_written是作者封装的I/O读写函数，与Linux系统提供的read和write作用基本相同。</p>
<p>&emsp;&emsp;客户端关闭连接时会发送一个EOF到服务器，服务器读取后关闭连接，进入下一个循环。这里面用到的所有Linux网络编程接口都定义在&lt;sys/socket.h&gt;头文件中。</p>
<h1 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h1><h2 id="HTTP-请求"><a href="#HTTP-请求" class="headerlink" title="HTTP 请求"></a>HTTP 请求</h2><p>&emsp;&emsp;一个HTTP请求：一个请求行(request line) 后面跟随0个或多个请求报头(request header), 再跟随一个空的文本行来终止报头。</p>
<p>&emsp;&emsp;请求行： <code>&lt;method&gt; &lt;uri&gt; &lt;version&gt;</code></p>
<p>&emsp;&emsp;请求报头：<code>&lt;header name&gt; : &lt;header data&gt;</code> 为服务器提供了额外的信息，例如浏览器的版本类型</p>
<h2 id="HTTP响应"><a href="#HTTP响应" class="headerlink" title="HTTP响应"></a>HTTP响应</h2><p>&emsp;&emsp;一个HTTP响应：一个响应行(response line) 后面跟随0个或多个响应报头(response header)，再跟随一个空的文本行来终止报头，最后跟随一个响应主体(response body)。</p>
<h1 id="服务动态内容"><a href="#服务动态内容" class="headerlink" title="服务动态内容"></a>服务动态内容</h1><h2 id="客户端如何将程序参数传递给服务器"><a href="#客户端如何将程序参数传递给服务器" class="headerlink" title="客户端如何将程序参数传递给服务器"></a>客户端如何将程序参数传递给服务器</h2><p>&emsp;&emsp;GET请求的参数在URI中传递，“?”字符分隔了文件名和参数，每个参数都用一个”&amp;”分隔开，参数中不允许有空格，必须用字符串“%20”来表示。</p>
<h2 id="服务器如何将参数传递给子进程"><a href="#服务器如何将参数传递给子进程" class="headerlink" title="服务器如何将参数传递给子进程"></a>服务器如何将参数传递给子进程</h2><pre><code>GET /cgi-bin/adder?123&amp;456 HTTP/1.1</code></pre><p>&emsp;&emsp;它调用 fork 来创建一个子进程，并调用 execve 在子进程的上下文中执行 /cgi-bin/adder 程序。</p>
<p>&emsp;&emsp;在调用 execve 之前，子进程将CGI环境变量 QUERY_STRING 设置为”123&amp;456”， adder 程序在运行时可以用unix getenv 函数来引用它。</p>
<h2 id="服务器如何将其他信息传递给子进程"><a href="#服务器如何将其他信息传递给子进程" class="headerlink" title="服务器如何将其他信息传递给子进程"></a>服务器如何将其他信息传递给子进程</h2><p><img src="https://cy-pic.kuaizhan.com/g3/78/d7/0e85-0be1-4da3-92d9-3a12a4f9e57d06?sign=f02b8de39d7be9b21cb411eb7c2e9667&t=1572863982" alt=""></p>
<h2 id="子进程将它的输出发送到哪里"><a href="#子进程将它的输出发送到哪里" class="headerlink" title="子进程将它的输出发送到哪里"></a>子进程将它的输出发送到哪里</h2><p>&emsp;&emsp;一个CGI程序将它的动态内容发送到标准输出，在子进程加载并运行CGI程序之前，它使用UNIX dup2 函数将它标准输出重定向到和客户端相关连的已连接描述符。因此，任何CGI程序写到标准输出的东西都会直接到达客户端。</p>
<h1 id="Tiny-Web服务器代码分析"><a href="#Tiny-Web服务器代码分析" class="headerlink" title="Tiny Web服务器代码分析"></a>Tiny Web服务器代码分析</h1><h2 id="main函数-amp-open-listenfd函数"><a href="#main函数-amp-open-listenfd函数" class="headerlink" title="main函数 &amp; open_listenfd函数"></a>main函数 &amp; open_listenfd函数</h2><p>&emsp;&emsp;Tiny是一个迭代服务器，监听在命令行中传递来的端口上的连接请求，在通过调用 open_listenfd 函数打开一个监听套接字以后，执行无限服务器循环，不断接受连接请求，执行事务，并关闭连接它的那一端。</p>
<figure class="highlight perl"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> open_listenfd(char *port)</span><br><span class="line">&#123;</span><br><span class="line">    struct addrinfo hints,*p,*listp;</span><br><span class="line">    <span class="keyword">int</span> listenfd, optval=<span class="number">1</span>,rc;</span><br><span class="line">    memset(&amp;hints, <span class="number">0</span>, sizeof(struct addrinfo));</span><br><span class="line">    hints.ai_socktype=SOCK_STREAM;</span><br><span class="line">    hints.ai_flags = AI_PASSIVE | AI_ADDRCONFIG;</span><br><span class="line">    hints.ai_flags |= AI_NUMERICSERV;</span><br><span class="line">    //<span class="keyword">socket</span>----&gt;<span class="keyword">bind</span>----&gt;<span class="keyword">listen</span></span><br><span class="line">    getaddrinfo(NULL, port, &amp;hints, &amp;listp);</span><br><span class="line">   // <span class="keyword">if</span>(listp == NULL) </span><br><span class="line">    <span class="keyword">for</span>(p=listp; p; p=p-&gt;ai_next)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>((listenfd=<span class="keyword">socket</span>(p-&gt;ai_family, p-&gt;ai_socktype, p-&gt;ai_protocol)) &lt; <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">       <span class="keyword">if</span>((rc= <span class="keyword">setsockopt</span>(listenfd, SOL_SOCKET, SO_REUSEADDR, &amp; optval, sizeof(<span class="keyword">int</span>))) &lt; <span class="number">0</span>) <span class="keyword">printf</span>(<span class="string">"%s\n"</span>, strerror(errno));</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">bind</span>(listenfd, p-&gt;ai_addr, p-&gt;ai_addrlen) == <span class="number">0</span>)     //<span class="keyword">printf</span>(<span class="string">"%s\n"</span>, strerror(errno)); <span class="regexp">//break</span>;</span><br><span class="line">        		<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">close</span>(listenfd);</span><br><span class="line">    &#125;</span><br><span class="line">    freeaddrinfo(listp);</span><br><span class="line">    <span class="keyword">if</span>(!p)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">listen</span>(listenfd, LISTENQ) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">close</span>(listenfd);</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> listenfd;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> listenfd,connfd;</span><br><span class="line">    socklen_t clientlen;</span><br><span class="line">    char hostname[MAXNLINE], port[MAXNLINE];</span><br><span class="line">    struct sockaddr_storage clientaddr;</span><br><span class="line">    <span class="keyword">if</span>(argc&lt;<span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        fprintf(stderr, <span class="string">"usage: %s &lt;port&gt;\n"</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    listenfd=open_listenfd(argv[<span class="number">1</span>]);</span><br><span class="line">    //<span class="keyword">printf</span>(<span class="string">"%d"</span>, listenfd);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        clientlen = sizeof(clientaddr); </span><br><span class="line">        connfd = <span class="keyword">accept</span>(listenfd, (struct sockaddr *)&amp;clientaddr, &amp;clientlen);    <span class="regexp">//</span>等待客户端连接请求 </span><br><span class="line">        getnameinfo((struct sockaddr*)&amp; clientaddr, clientlen, hostname, MAXNLINE, port, MAXNLINE, <span class="number">0</span>);</span><br><span class="line">       // <span class="keyword">printf</span>(<span class="string">"\n%d\n"</span>, connfd);</span><br><span class="line">        <span class="keyword">printf</span>(<span class="string">"Accept connection from (%s %s)\n"</span>, hostname, port);</span><br><span class="line">      //  <span class="keyword">if</span>(connfd==<span class="number">152</span> || connfd ==<span class="number">153</span> || connfd==<span class="number">151</span> || connfd==<span class="number">154</span> || connfd==<span class="number">147</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        doit(connfd);</span><br><span class="line">        <span class="keyword">close</span>(connfd);</span><br><span class="line">        //<span class="keyword">if</span>( <span class="keyword">close</span>(connfd) &lt; <span class="number">0</span>) <span class="keyword">printf</span>(<span class="string">"%s"</span>, strerror(errno));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="doit函数"><a href="#doit函数" class="headerlink" title="doit函数"></a>doit函数</h2><p>&emsp;&emsp;doit函数处理一个HTTP事务，首先读和解析请求行(request line)，注意，我们使用rio_readlineb函数读取请求行。<br>Tiny只支持GET方法，如果客户端请求其他方法，发送一个错误信息。<br>然后将URI解析为一个文件名和一个可能为空的CGI参数字符串，并且设置一个标志表明请求的是静态内容还是动态内容,如果请求的是静态内容，就验证是否为普通文件，有读权限如果请求的是动态内容，就验证是否为可执行文件，如果是，就提供动态内容。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">void doit(<span class="built_in">int</span> fd)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> is_static;</span><br><span class="line">    <span class="keyword">struct</span> stat sbuf;</span><br><span class="line">    <span class="built_in">char</span> buf<span class="literal">[MAXNLINE]</span>, filename<span class="literal">[MAXNLINE]</span>, uri<span class="literal">[MAXNLINE]</span>, verson<span class="literal">[MAXNLINE]</span>;</span><br><span class="line">    <span class="built_in">char</span> <span class="keyword">method</span><span class="literal">[MAXNLINE]</span>, cgiargs<span class="literal">[MAXNLINE]</span>;   </span><br><span class="line">    rio_t rio;</span><br><span class="line"></span><br><span class="line">    rio<span class="constructor">_readinitb(&amp;<span class="params">rio</span>, <span class="params">fd</span>)</span>;        <span class="comment">//fd是与服务器通信的套接字 </span></span><br><span class="line">    rio<span class="constructor">_readlineb(&amp;<span class="params">rio</span>, <span class="params">buf</span>, MAXNLINE)</span>;</span><br><span class="line">    printf(<span class="string">"Request headers:\n"</span>);</span><br><span class="line">    printf(<span class="string">"%s"</span>, buf);</span><br><span class="line">    sscanf(buf, <span class="string">"%s %s %s"</span>, <span class="keyword">method</span>, uri, verson);</span><br><span class="line">    <span class="keyword">if</span>(strcasecmp(<span class="keyword">method</span>, <span class="string">"GET"</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        clienterror(fd, <span class="keyword">method</span>, <span class="string">"501"</span>, <span class="string">"Not implemented"</span>, <span class="string">"Tiny does not implement this method"</span>);</span><br><span class="line">        return ;</span><br><span class="line">    &#125;</span><br><span class="line">    read<span class="constructor">_requesthds(&amp;<span class="params">rio</span>)</span>;       <span class="comment">//读请求头 </span></span><br><span class="line">    is_static = prase<span class="constructor">_uri(<span class="params">uri</span>, <span class="params">filename</span>, <span class="params">cgiargs</span>)</span>;</span><br><span class="line">    <span class="keyword">if</span>(stat(filename, &amp;sbuf) &lt; <span class="number">0</span>)   <span class="comment">//通过文件名获取文件信息 </span></span><br><span class="line">    &#123;</span><br><span class="line">       clienterror(fd, filename, <span class="string">"404"</span>, <span class="string">"Not Found"</span>, <span class="string">"Tiny couldn't find this file"</span>);  <span class="comment">//返回错误信息 </span></span><br><span class="line">        return ; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(is_static==<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!(<span class="constructor">S_ISREG(<span class="params">sbuf</span>.<span class="params">st_mode</span>)</span>) <span class="pattern-match"><span class="operator">||</span>!(sbuf.st<span class="constructor">_mode</span> &amp; <span class="constructor">S_IRUSR</span>))</span></span><br><span class="line"><span class="pattern-match">        &#123;</span></span><br><span class="line"><span class="pattern-match">            clienterror(fd, filename, "403", "<span class="constructor">Not</span> <span class="constructor">Found</span>", "<span class="constructor">Tiny</span> couldn't read this file");  </span></span><br><span class="line"><span class="pattern-match">            return ;    </span></span><br><span class="line"><span class="pattern-match">        &#125;</span></span><br><span class="line"><span class="pattern-match">        serve<span class="constructor">_static(<span class="params">fd</span>, <span class="params">filename</span>, <span class="params">sbuf</span>.<span class="params">st_size</span>)</span>;</span></span><br><span class="line"><span class="pattern-match">    &#125;</span></span><br><span class="line"><span class="pattern-match">    <span class="keyword">else</span></span></span><br><span class="line"><span class="pattern-match">    &#123;</span></span><br><span class="line"><span class="pattern-match">        <span class="keyword">if</span>(!<span class="constructor">S_ISREG(<span class="params">sbuf</span>.<span class="params">st_mode</span>)</span> <span class="operator">||</span> !(<span class="constructor">S_IRUSR</span> &amp; sbuf.st<span class="constructor">_mode</span>))</span></span><br><span class="line"><span class="pattern-match">        &#123;</span></span><br><span class="line"><span class="pattern-match">            clienterror(fd, filename, "403", "<span class="constructor">Forbidden</span>", "<span class="constructor">Tiny</span> couldn't run the <span class="constructor">CGI</span> program");  </span></span><br><span class="line"><span class="pattern-match">            return ;</span></span><br><span class="line"><span class="pattern-match">        &#125;</span></span><br><span class="line"><span class="pattern-match">        serve<span class="constructor">_dynamic(<span class="params">fd</span>, <span class="params">filename</span>, <span class="params">cgiargs</span>)</span>;</span></span><br><span class="line"><span class="pattern-match">     &#125; </span></span><br><span class="line"><span class="pattern-match">&#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="clienterror函数"><a href="#clienterror函数" class="headerlink" title="clienterror函数"></a>clienterror函数</h2><p>&emsp;&emsp;clienterror函数检查一些明显的错误，并把它报告给客户端。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">void clienterror(<span class="built_in">int</span> fd, <span class="built_in">char</span> *cause, <span class="built_in">char</span> *errnum, <span class="built_in">char</span> *shortmsg, <span class="built_in">char</span> *longmsg)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">char</span> buf<span class="literal">[MAXNLINE]</span>,body<span class="literal">[MAXNLINE]</span>;</span><br><span class="line">    <span class="comment">//build http response body</span></span><br><span class="line">    sprintf(body, <span class="string">"&lt;html&gt;&lt;title&gt;Tiny Error&lt;/title&gt;"</span>);</span><br><span class="line">    sprintf(body, <span class="string">"%s&lt;body bgcolor="</span><span class="string">"ffffff"</span><span class="string">"&gt;\r\n"</span>, body);</span><br><span class="line">    sprintf(body, <span class="string">"%s%s: %s\r\n"</span>, body, errnum, shortmsg);</span><br><span class="line">    sprintf(body, <span class="string">"%s&lt;p&gt;%s: %s\r\n"</span>, body, longmsg, cause);</span><br><span class="line">    sprintf(body, <span class="string">"%s&lt;hr&gt;&lt;em&gt;The Tiny Web server&lt;/em&gt;\r\n"</span>, body);</span><br><span class="line">    <span class="comment">//打印信息 </span></span><br><span class="line">    sprintf(buf, <span class="string">"HTTP/1.0 %s %s\r\n"</span>, errnum, shortmsg);</span><br><span class="line">    rio<span class="constructor">_writen(<span class="params">fd</span>, <span class="params">buf</span>, <span class="params">strlen</span>(<span class="params">buf</span>)</span>);</span><br><span class="line">    sprintf(buf, <span class="string">"Content-type: text/html\r\n"</span>);</span><br><span class="line">    rio<span class="constructor">_writen(<span class="params">fd</span>, <span class="params">buf</span>, <span class="params">strlen</span>(<span class="params">buf</span>)</span>);</span><br><span class="line">    sprintf(buf, <span class="string">"Content-length: %d\r\n\r\n"</span>, (<span class="built_in">int</span>)strlen(body));</span><br><span class="line">    rio<span class="constructor">_writen(<span class="params">fd</span>, <span class="params">buf</span>, <span class="params">strlen</span>(<span class="params">buf</span>)</span>);</span><br><span class="line">    rio<span class="constructor">_writen(<span class="params">fd</span>, <span class="params">body</span>, <span class="params">strlen</span>(<span class="params">body</span>)</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="read-requesthdrs函数"><a href="#read-requesthdrs函数" class="headerlink" title="read_requesthdrs函数"></a>read_requesthdrs函数</h2><p>&emsp;&emsp;Tiny不使用请求报头中的任何信息，仅仅调用 read_requesthdrs函数来读取并忽略这些报头。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">void read<span class="constructor">_requesthds(<span class="params">rio_t</span> <span class="operator">*</span><span class="params">rp</span>)</span>       <span class="comment">//鎶把请求头读出来 </span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">char</span> buf<span class="literal">[MAXNLINE]</span>;</span><br><span class="line">    rio<span class="constructor">_readlineb(<span class="params">rp</span>, <span class="params">buf</span>, MAXNLINE)</span>;</span><br><span class="line">    printf(<span class="string">"%s"</span>, buf);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(strcmp(buf, <span class="string">"\r\n"</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        rio<span class="constructor">_readlineb(<span class="params">rp</span> , <span class="params">buf</span>, MAXNLINE)</span>;</span><br><span class="line">        printf(<span class="string">"%s"</span>, buf);</span><br><span class="line">    &#125;</span><br><span class="line">    return ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="parse-uri函数"><a href="#parse-uri函数" class="headerlink" title="parse_uri函数"></a>parse_uri函数</h2><p>&emsp;&emsp;Tiny假设静态内容的主目录就是当前目录，可执行文件的主目录是 ./cgi-bin/ 任何包含字符串 cgi-bin 的URI都认为是对动态内容的请求。</p>
<p>&emsp;&emsp;首先将URI解析为一个文件名和一个可选的CGI参数字符串，如果请求的是静态内容，就清除CGI参数串(第6行)，然后将URI转换为一个相对的unix 路径名，例如 ./index.html。</p>
<p>&emsp;&emsp;如果URI是用’/‘ 结尾的,我们就把默认的文件名加在后面。如果请求的是动态内容，就会抽取所有的CGI参数，并将URI剩下的部分转换为一个相应的unix文件名</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">prase_uri</span><span class="params">(<span class="keyword">char</span> *uri, <span class="keyword">char</span> *filename, <span class="keyword">char</span> *cgiargs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *ptr;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">strstr</span>(uri, <span class="string">"cgi-bin"</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">strcpy</span>(cgiargs, <span class="string">""</span>);</span><br><span class="line">        <span class="built_in">strcpy</span>(filename, <span class="string">"."</span>);</span><br><span class="line">        <span class="built_in">strcat</span>(filename, uri);</span><br><span class="line">        <span class="keyword">if</span>(uri[<span class="built_in">strlen</span>(uri)<span class="number">-1</span>]==<span class="string">'/'</span>) <span class="built_in">strcat</span>(filename, <span class="string">"home.html"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        ptr = index(uri, <span class="string">'?'</span>);</span><br><span class="line">        <span class="keyword">if</span>(ptr)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">strcpy</span>(cgiargs, ptr+<span class="number">1</span>);</span><br><span class="line">            *ptr=<span class="string">'\0'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">strcpy</span>(cgiargs, <span class="string">""</span>);</span><br><span class="line">        <span class="built_in">strcpy</span>(filename, <span class="string">"."</span>);</span><br><span class="line">        <span class="built_in">strcat</span>(filename, uri);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="serve-static函数"><a href="#serve-static函数" class="headerlink" title="serve_static函数"></a>serve_static函数</h2><p>&emsp;&emsp;Tiny提供四种不同的静态内容：HTML文件、无格式的文本文件、GIF编码格式图片、JPEG编码格式图片。serve_static 函数发送一个HTTP响应，其主体包含一个本地文件的内容。</p>
<p>&emsp;&emsp;首先我们通过检查文件名的后缀来判断文件类型，并且发送响应行和响应报头给客户端。注意用一个空行终止报头，我们使用 unix mmap函数将被请求文件映射到一个虚拟存储器空间，调用mmap将文件srcfd的前filesize个字节映射到一个从地址srcp开始的私有只读虚拟存储器区域。</p>
<p>&emsp;&emsp;一旦文件映射到存储器，就不再需要它的描述符了，关闭这个文件。rio_writen 函数拷贝从srcp位置开始的filesize个字节(已经被映射到了所请求的文件) 到客户端的已连接描述符。最后释放了映射的虚拟存储器区域，避免潜在的内存泄露。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getfiletype</span><span class="params">(<span class="keyword">char</span> *filename, <span class="keyword">char</span> *filetype)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strstr</span>(filename, <span class="string">".html"</span>))   <span class="built_in">strcpy</span>(filetype, <span class="string">"text/html"</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">strstr</span>(filename, <span class="string">".gif"</span>))   <span class="built_in">strcpy</span>(filetype, <span class="string">"image/gif"</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">strstr</span>(filename, <span class="string">".png"</span>))   <span class="built_in">strcpy</span>(filetype, <span class="string">"image/png"</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">strstr</span>(filename, <span class="string">".jpg"</span>))   <span class="built_in">strcpy</span>(filetype, <span class="string">"image/jpeg"</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">strcpy</span>(filetype, <span class="string">"text/plain"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">serve_static</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">char</span> *filename, <span class="keyword">int</span> filesize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> srcfd;</span><br><span class="line">    <span class="keyword">char</span> *srcp, filetype[MAXNLINE], buf[MAXNLINE];</span><br><span class="line">    <span class="comment">//  发送响应报头给客户端 </span></span><br><span class="line">    getfiletype(filename, filetype);      <span class="comment">//返回静态内容类型 </span></span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">"HTTP/1.0 200 OK\r\n"</span>);</span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">"%sServer: Tiny Web Server\r\n"</span>, buf);</span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">"%sConnection: close\r\n"</span>, buf);</span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">"%sContent-length %d\r\n"</span>, buf, filesize);</span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">"%sContent-type: %s\r\n\r\n"</span>, buf, filetype);</span><br><span class="line">    rio_writen(fd, buf, <span class="built_in">strlen</span>(buf));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Response headers:\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s"</span>, buf);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//  发送响应体给客户端 </span></span><br><span class="line">    srcfd = open(filename, O_RDONLY, <span class="number">0</span>); </span><br><span class="line">    srcp = mmap(<span class="number">0</span>, filesize, PROT_READ, MAP_PRIVATE, srcfd, <span class="number">0</span>);</span><br><span class="line">    close(srcfd);</span><br><span class="line">    rio_writen(fd, srcp, filesize);</span><br><span class="line">    munmap(srcp, filesize);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="serve-dynamic-函数"><a href="#serve-dynamic-函数" class="headerlink" title="serve_dynamic 函数"></a>serve_dynamic 函数</h2><p>&emsp;&emsp;Tiny通过派生一个子进程并在子进程的上下文中运行一个CGI程序，来提供各种类型的动态内容。</p>
<p>&emsp;&emsp;serve_dynamic函数一开始就向客户端发送一个表明成功的响应行，同时还包括带有信息的server报头。</p>
<p>&emsp;&emsp;子进程用来自请求URI的CGI参数初始化QUERY_STRING环境变量</p>
<p>&emsp;&emsp;子进程重定向它的标准输出到已连接文件描述符</p>
<p>&emsp;&emsp;加载并运行CGI程序，因为CGI程序运行在子进程的上下文中，它能够访问所有在调用execve函数之前就存在的打开文件和环境变量</p>
<p>&emsp;&emsp;父进程阻塞在对wait的调用中，等待子进程终止的时候，回收操作系统那个分配给子进程的资源</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">void serve<span class="constructor">_dynamic(<span class="params">int</span> <span class="params">fd</span>, <span class="params">char</span> <span class="operator">*</span><span class="params">filename</span>, <span class="params">char</span> <span class="operator">*</span><span class="params">cgiargs</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">char</span> buf<span class="literal">[MAXNLINE]</span>, *emptylist<span class="literal">[]</span>=&#123;NULL&#125;;</span><br><span class="line">    pid_t pid;</span><br><span class="line">    printf(<span class="string">"-----------%s-------------"</span>, cgiargs);</span><br><span class="line">    sprintf(buf, <span class="string">"HTTP/1.0 200 OK\r\n"</span>);</span><br><span class="line">    rio<span class="constructor">_writen(<span class="params">fd</span>, <span class="params">buf</span>, <span class="params">strlen</span>(<span class="params">buf</span>)</span>);</span><br><span class="line">    sprintf(buf, <span class="string">"Server: Tiny Web Server\r\n"</span>);</span><br><span class="line">    rio<span class="constructor">_writen(<span class="params">fd</span>, <span class="params">buf</span>, <span class="params">strlen</span>(<span class="params">buf</span>)</span>);</span><br><span class="line">    pid=fork<span class="literal">()</span>;</span><br><span class="line">    <span class="keyword">if</span>(pid==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        setenv(<span class="string">"QUERY_STRING"</span>, cgiargs, <span class="number">1</span>);   <span class="comment">//改变或者增加环境变量内容，为1则改 </span></span><br><span class="line">        dup2(fd, STDOUT_FILENO);</span><br><span class="line">       <span class="comment">/*</span></span><br><span class="line"><span class="comment">        *         来执行参数filename字符串所代表的文件路径，第二个参数是利</span></span><br><span class="line"><span class="comment">		    用数组指针来传递给执行文件，并且需要以空指针(NULL)结束，最后一个参数则为传递给执行文件</span></span><br><span class="line"><span class="comment">			    的新环境变量数组。execve()用来执行参数filename字符串所代表的文件路径，第二个参数是利用数组指针来传递给执</span></span><br><span class="line"><span class="comment">			  行文件，并且需要以空指针(NULL)结束，最后一个参数则为传递给执行文件的新环境变量数组</span></span><br><span class="line"><span class="comment">			  */</span> </span><br><span class="line">        execve(filename, emptylist, environ);</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="keyword">else</span>  wait(NULL);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="rio函数"><a href="#rio函数" class="headerlink" title="rio函数"></a>rio函数</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXNLINE 1024*8</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LISTENQ 1024</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">char</span> **environ;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> rio_fd,rio_cnt;</span><br><span class="line">    <span class="keyword">char</span> rio_buf[MAXNLINE],*rio_bufptr;</span><br><span class="line">&#125; <span class="keyword">rio_t</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">ssize_t</span> rio_writen(<span class="keyword">int</span> fd, <span class="keyword">void</span> *usrbuf, <span class="keyword">size_t</span> n)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">size_t</span> nleft=n;</span><br><span class="line">    <span class="keyword">ssize_t</span> nwritten;</span><br><span class="line">    <span class="keyword">char</span> *bufp=usrbuf;</span><br><span class="line">    <span class="keyword">while</span>(nleft&gt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>((nwritten = write(fd, bufp, nleft)) &lt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(errno == EINTR)</span><br><span class="line">            &#123;</span><br><span class="line">                nwritten=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        nleft-=nwritten;</span><br><span class="line">        bufp+=nwritten;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rio_readinitb</span><span class="params">(<span class="keyword">rio_t</span> *rio, <span class="keyword">int</span> fd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    rio-&gt;rio_fd=fd;</span><br><span class="line">    rio-&gt;rio_cnt=<span class="number">0</span>;</span><br><span class="line">    rio-&gt;rio_bufptr=rio-&gt;rio_buf;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> ssize_t <span class="title">rio_read</span><span class="params">(<span class="keyword">rio_t</span> *rp, <span class="keyword">char</span> *rc, <span class="keyword">size_t</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt;</span><br><span class="line">    <span class="keyword">while</span>(rp-&gt;rio_cnt&lt;=<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        rp-&gt;rio_cnt=read(rp-&gt;rio_fd, rp-&gt;rio_buf, <span class="keyword">sizeof</span>(rp-&gt;rio_buf));</span><br><span class="line">        <span class="keyword">if</span>(rp-&gt;rio_cnt&lt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(errno != EINTR)  <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">//此时为不中断 </span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(rp-&gt;rio_cnt==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> rp-&gt;rio_bufptr=rp-&gt;rio_buf;</span><br><span class="line">    &#125;</span><br><span class="line">    cnt=n;</span><br><span class="line">    <span class="keyword">if</span>(rp-&gt;rio_cnt &lt; n) cnt=rp-&gt;rio_cnt;</span><br><span class="line">    <span class="built_in">memcpy</span>(rc, rp-&gt;rio_bufptr, cnt);</span><br><span class="line">    rp-&gt;rio_bufptr+=cnt;</span><br><span class="line">    rp-&gt;rio_cnt-=cnt;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">ssize_t</span> rio_readlineb(<span class="keyword">rio_t</span> *rp, <span class="keyword">void</span> *usrbuf, <span class="keyword">size_t</span> maxnlen)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">char</span> *buf=usrbuf,c;</span><br><span class="line">    <span class="keyword">int</span> n,rc;</span><br><span class="line">    <span class="keyword">for</span>(n=<span class="number">1</span>; n&lt;maxnlen; ++n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>((rc=rio_read(rp, &amp;c, <span class="number">1</span>))==<span class="number">1</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            *buf++ = c;</span><br><span class="line">            <span class="keyword">if</span>(c == <span class="string">'\n'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                n++;</span><br><span class="line">                <span class="keyword">break</span>;  </span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(rc == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(n==<span class="number">1</span>)    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;   </span><br><span class="line">    *buf=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> n<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>csapp</category>
      </categories>
      <tags>
        <tag>Linux C/C++</tag>
        <tag>网络编程</tag>
      </tags>
  </entry>
</search>

<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>空间配置器</title>
    <url>/2019/12/07/%E7%A9%BA%E9%97%B4%E9%85%8D%E7%BD%AE%E5%99%A8/</url>
    <content><![CDATA[<p>简介： sql模板空间适配器</p>
<a id="more"></a>
<h1 id="自定义版本"><a href="#自定义版本" class="headerlink" title="自定义版本"></a>自定义版本</h1><h2 id="sql-h"><a href="#sql-h" class="headerlink" title="sql.h"></a>sql.h</h2><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">#pragma once</span><br><span class="line">#include &lt;new&gt;</span><br><span class="line">#include &lt;cstddef&gt;  <span class="comment">//for ptrdiff_t, size_t</span></span><br><span class="line">#include &lt;cstdlib&gt;</span><br><span class="line">#include &lt;climits&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="symbol">JJ</span></span><br><span class="line">&#123;</span><br><span class="line">	template &lt;<span class="keyword">class</span> <span class="symbol">T</span>&gt;</span><br><span class="line">	<span class="symbol">inline</span> <span class="symbol">T</span>* <span class="symbol">_allocate</span>(<span class="symbol">ptrdiff_t</span> <span class="symbol">size, <span class="symbol">T</span></span>*)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//ptrdiff_t是C/C++标准库中定义的一个与机器相关的数据类型。ptrdiff_t类型变量通常用来保存两个指针减法操作的结果。</span></span><br><span class="line">		std::set_new_handler(NULL);</span><br><span class="line">		<span class="comment">//set_new_handler函数的作用是设置new_p指向的函数为new操作或new[]操作失败时调用的处理函数。</span></span><br><span class="line">		<span class="comment">//若参数是一个空指针，处理函数将被重置为默认值（将会执行抛出bad_alloc异常）</span></span><br><span class="line">		T* tmp = (T*)(::operator new((size_t)(size * sizeof(T))));</span><br><span class="line">		<span class="comment">/******</span></span><br><span class="line"><span class="comment">			当我们在C++中使用new 和delete时，其实执行的是全局的::operator new和::operator delete</span></span><br><span class="line"><span class="comment">			对于new来说，有new和::new之分，前者位于std</span></span><br><span class="line"><span class="comment">			operator new()：指对new的重载形式，它是一个函数，并不是运算符</span></span><br><span class="line"><span class="comment">			全局重载是void* ::operator new(size_t size)，在类中重载形式 void* A::operator new(size_t size)</span></span><br><span class="line"><span class="comment">			分配内存这一操作就是由operator new(size_t)来完成的，如果类A重载了operator new，那么将调用A::operator new(size_t )，如果没有重载，就调用::operator new(size_t )</span></span><br><span class="line"><span class="comment">		****/</span></span><br><span class="line">		<span class="keyword">if</span> (tmp == <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			std::cerr &lt;&lt; <span class="string">"out of memory"</span> &lt;&lt; std::endl;</span><br><span class="line">			exit(<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> tmp;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	template &lt;<span class="keyword">class</span> <span class="symbol">T</span>&gt;</span><br><span class="line">	<span class="symbol">inline</span> <span class="symbol">void</span> <span class="symbol">_deallocate</span>(<span class="symbol">T</span>* <span class="symbol">buffer</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		::operator delete(buffer);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	template &lt;<span class="keyword">class</span> <span class="symbol">T1, <span class="symbol">class</span></span> <span class="symbol">T2</span>&gt;</span><br><span class="line">	<span class="symbol">inline</span> <span class="symbol">void</span> <span class="symbol">_construct</span>(<span class="symbol">T1</span>* <span class="symbol">p, <span class="symbol">const</span></span> <span class="symbol">T2</span>&amp; <span class="symbol">value</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//这个操作叫做placement new，就是在指针p所指向的内存空间创建一个T1类型的对象，</span></span><br><span class="line">		<span class="comment">//但是对象的内容是从T2类型的对象转换过来的（调用了T1的构造函数，T1::T1(value)）</span></span><br><span class="line">		new(p) T1(value);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	template &lt;<span class="keyword">class</span> <span class="symbol">T</span>&gt;</span><br><span class="line">	<span class="symbol">inline</span> <span class="symbol">void</span> <span class="symbol">_destroy</span>(<span class="symbol">T</span>* <span class="symbol">ptr</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		ptr-&gt;~T();</span><br><span class="line">	&#125;</span><br><span class="line">	template &lt;<span class="keyword">class</span> <span class="symbol">T</span>&gt;</span><br><span class="line">	<span class="symbol">class</span> <span class="symbol">allocator</span></span><br><span class="line">	&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="keyword">typedef</span> T 			value_type;</span><br><span class="line">		<span class="keyword">typedef</span> T* pointer;</span><br><span class="line">		<span class="keyword">typedef</span> <span class="keyword">const</span> T* const_pointer;</span><br><span class="line">		<span class="keyword">typedef</span> T&amp; <span class="built_in">ref</span>erence;</span><br><span class="line">		<span class="keyword">typedef</span> <span class="keyword">const</span> T&amp; const_reference;</span><br><span class="line">		<span class="keyword">typedef</span> size_t 		size_type;</span><br><span class="line">		<span class="keyword">typedef</span> ptrdiff_t	difference_type;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 加入拷贝构造函数</span></span><br><span class="line">		allocator() = <span class="keyword">default</span>;</span><br><span class="line">		template &lt;<span class="keyword">class</span> <span class="symbol">U</span>&gt;   //<span class="symbol">Add</span> <span class="symbol">new</span></span><br><span class="line">		<span class="symbol">allocator</span>(<span class="symbol">const</span> <span class="symbol">allocator</span>&lt;<span class="symbol">U</span>&gt;&amp; <span class="symbol">c</span>) &#123; &#125;</span><br><span class="line">		<span class="comment">//允许一种类型的对象的分配器为另一种类型的对象分配存储的结构。</span></span><br><span class="line">		template &lt;<span class="keyword">class</span> <span class="symbol">U</span>&gt;</span><br><span class="line">		<span class="symbol">struct</span> <span class="symbol">rebind</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">typedef</span> allocator&lt;U&gt; other;</span><br><span class="line">		&#125;;</span><br><span class="line">		<span class="comment">//配置空间，足以存储n个T对象。第二参数是个提示。实现上可能会利用它来增进区域性，或完全忽略之。</span></span><br><span class="line">		pointer allocate(size_type n, <span class="keyword">const</span> <span class="built_in">void</span>* hint = <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> _allocate((difference_type)n, (pointer)<span class="number">0</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//归还先前配置的空间</span></span><br><span class="line">		<span class="built_in">void</span> deallocate(pointer p, size_type n)</span><br><span class="line">		&#123;</span><br><span class="line">			_deallocate(p);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//等同于new((void *)p) T(x)</span></span><br><span class="line">		<span class="built_in">void</span> construct(pointer p, <span class="keyword">const</span> T&amp; value)</span><br><span class="line">		&#123;</span><br><span class="line">			_construct(p, value);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">void</span> destroy(pointer p)</span><br><span class="line">		&#123;</span><br><span class="line">			_destroy(p);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//返回某个对象的地址。算式a.address(x)等同于&amp;x</span></span><br><span class="line">		pointer address(<span class="built_in">ref</span>erence x)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> (pointer)&amp;x;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//返回某个const对象的地址。算式a.address(x)等同于&amp;x</span></span><br><span class="line">		const_pointer const_address(const_reference x)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> (const_reference)&amp;x;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//返回可成功配置的最大量</span></span><br><span class="line">		size_type max_size() <span class="keyword">const</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> size_type(UINT_MAX / sizeof(T));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="sql-cpp"><a href="#sql-cpp" class="headerlink" title="sql.cpp"></a>sql.cpp</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stl.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ia[<span class="number">5</span>] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> &#125;;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> i;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>, JJ::allocator&lt;<span class="keyword">int</span>&gt; &gt; iv(ia, ia + <span class="number">5</span>);</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; iv.size(); i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; iv[i] &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="具备次配置力的-SGI-空间配置器"><a href="#具备次配置力的-SGI-空间配置器" class="headerlink" title="具备次配置力的 SGI 空间配置器"></a>具备次配置力的 SGI 空间配置器</h1><p>&emsp;&emsp;SGI 的配置器与众不同，也与标准规范不同，其名称是 alloc，而不是 allocator，而且不接受任何参数。SGI 也有定义一个符合部分标准、名为 allocator 的配置器，但 SGI 自己从未用过它，也不建议我们使用，主要原因是效率不佳，只是对 ::operator new 和 ::operator delete 的简单包装。</p>
<h2 id="SGI特殊的空间配置器-std-alloc"><a href="#SGI特殊的空间配置器-std-alloc" class="headerlink" title="SGI特殊的空间配置器 std::alloc"></a>SGI特殊的空间配置器 std::alloc</h2><p>&emsp;&emsp;STL allocator 决定将 内存配置/释放 和对象构造/析构 两个阶段的操作区分开来，分别由如下函数来实现</p>
<figure class="highlight lasso"><table><tr><td class="code"><pre><span class="line">alloc<span class="type">::allocator</span>()          <span class="comment">//内存配置</span></span><br><span class="line">alloc<span class="type">::deallocator</span>()        <span class="comment">//内存配置</span></span><br><span class="line"></span><br><span class="line"><span class="type">::construcct</span>()              <span class="comment">//对象构造</span></span><br><span class="line"><span class="type">::destroy</span>()                 <span class="comment">//对象析构</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;SGI <code>&lt;memory&gt;</code>内含以下两个文件</p>
<figure class="highlight autoit"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stl_alloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stl_construct.h&gt;</span></span></span><br><span class="line">	构造用的construct()与析构用的destroy()</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.ax1x.com/2019/12/07/QN9XrQ.png" alt=""></p>
<h3 id="构造和析构的基本工具：construct-和-destroy"><a href="#构造和析构的基本工具：construct-和-destroy" class="headerlink" title="构造和析构的基本工具：construct() 和 destroy()"></a>构造和析构的基本工具：construct() 和 destroy()</h3><p>&emsp;&emsp;</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">#include &lt;new.h&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 placement new 构造对象，调用构造函数 T1::T1(value);</span></span><br><span class="line">template &lt;<span class="keyword">class</span> <span class="symbol">T1, <span class="symbol">class</span></span> <span class="symbol">T2</span>&gt;</span><br><span class="line"><span class="symbol">inline</span> <span class="symbol">void</span> <span class="symbol">construct</span>(<span class="symbol">T1</span>* <span class="symbol">p, <span class="symbol">const</span></span> <span class="symbol">T2</span>&amp; <span class="symbol">value</span>) &#123;</span><br><span class="line">	new (p) T1(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接受一个指针的 destroy 函数</span></span><br><span class="line">template &lt;<span class="keyword">class</span> <span class="symbol">T</span>&gt;</span><br><span class="line"><span class="symbol">inline</span> <span class="symbol">void</span> <span class="symbol">destroy</span>(<span class="symbol">T</span>* <span class="symbol">pointer</span>) &#123;</span><br><span class="line">	pointer-&gt;~T();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接受两个迭代器，使用 value_type() 获得迭代器所指对象的数值型别</span></span><br><span class="line">template &lt;<span class="keyword">class</span> <span class="symbol">ForwardIterator</span>&gt;</span><br><span class="line"><span class="symbol">inline</span> <span class="symbol">void</span> <span class="symbol">destroy</span>(<span class="symbol">ForwardIterator</span> <span class="symbol">first, <span class="symbol">ForwardIterator</span></span> <span class="symbol">last</span>) &#123;</span><br><span class="line">	__destroy(first, last, value_type(first));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 __type_traits&lt;&gt; 判断该类型析构函数是否为 trivial</span></span><br><span class="line">template &lt;<span class="keyword">class</span> <span class="symbol">ForwardIterator, <span class="symbol">class</span></span> <span class="symbol">T</span>&gt;</span><br><span class="line"><span class="symbol">inline</span> <span class="symbol">void</span> <span class="symbol">__destroy</span>(<span class="symbol">ForwardIterator</span> <span class="symbol">first, <span class="symbol">ForwardIterator</span></span> <span class="symbol">last, <span class="symbol">T</span></span>*) &#123;</span><br><span class="line">	<span class="keyword">typedef</span> typename __type_traits&lt;T&gt;::has_trivial_destructor trivial_destructor;</span><br><span class="line">	<span class="comment">//https://blog.csdn.net/vanturman/article/details/80269081</span></span><br><span class="line">	<span class="comment">//__type_traits是萃取型别的特性</span></span><br><span class="line">	__destroy_aux(first, last, trivial_destructor());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象析构函数为 trivial，什么都不用做</span></span><br><span class="line"><span class="comment">//通过函数trivial_destructor()确定型别来执行更高效的函数. 而且重载函数的选择实在编译时期就确定了. __false_type和__true_type 是参数推导.\</span></span><br><span class="line">template &lt;<span class="keyword">class</span> <span class="symbol">ForwardIterator</span>&gt;</span><br><span class="line"><span class="symbol">inline</span> <span class="symbol">void</span> <span class="symbol">__destroy_aux</span>(<span class="symbol">ForwardIterator, <span class="symbol">ForwardIterator</span>, <span class="symbol">__true_type</span></span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象析构函数为 non-trivial，这时需要对迭代器范围内的每一个元素分别调用 destroy()</span></span><br><span class="line">template &lt;<span class="keyword">class</span> <span class="symbol">ForwardIterator</span>&gt;</span><br><span class="line"><span class="symbol">inline</span> <span class="symbol">void</span></span><br><span class="line"><span class="symbol">__destroy_aux</span>(<span class="symbol">ForwardIterator</span> <span class="symbol">first, <span class="symbol">ForwardIterator</span></span> <span class="symbol">last, <span class="symbol">__false_type</span></span>) &#123;</span><br><span class="line">	<span class="keyword">for</span> (; first &lt; last; ++first)</span><br><span class="line">		destroy(&amp;*first);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果用户不定义析构函数，而是用系统自带的，</span></span><br><span class="line"><span class="comment">//则说明，析构函数基本没有什么用（但默认会被调用）我们称之为trivial destructor。</span></span><br><span class="line"><span class="comment">//反之，如果特定定义了析构函数，则说明需要在释放空间之前做一些事情，</span></span><br><span class="line"><span class="comment">//则这个析构函数称为non-trivial destructor。</span></span><br><span class="line"><span class="comment">// destroy() 针对 char* 和 wchar* 的特化版</span></span><br><span class="line">inline <span class="built_in">void</span> destroy(char*, char*) &#123;&#125;</span><br><span class="line"><span class="comment">//wchar_t数据类型一般为16位或32位</span></span><br><span class="line">inline <span class="built_in">void</span> destroy(wchar_t*, wchar_t*) &#123;&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.ax1x.com/2019/12/08/Qa8336.png" alt=""></p>
<h3 id="空间的配置与释放"><a href="#空间的配置与释放" class="headerlink" title="空间的配置与释放"></a>空间的配置与释放</h3><p>&emsp;&emsp;考虑到小型区块可能造成内存碎片问题，SGI 设计了双层配置器，第一级配置器直接使用 malloc 和 free，第二级配置器视情况不同采用不同的配置器：</p>
<ul>
<li>当配置区块超过128 byte 时，视为足够大，调用第一级配置器</li>
<li>当配置区块小于128 byte 时，视为过小，采用内存池的方式配置内存</li>
</ul>
<p>只开放第一级配置器还是同时开发第二级配置器取决于 __USE_MALLOC 是否被定义。无论 alloc 被定义为哪一级配置器，SGI 再为它包装一个接口如下：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">template &lt;class T, class Alloc&gt;</span><br><span class="line">class simple_alloc</span><br><span class="line">&#123;</span><br><span class="line"><span class="attribute">public:</span></span><br><span class="line">	static T* allocate(size_t n)</span><br><span class="line">	&#123;</span><br><span class="line">		return n == 0 ? 0 : Alloc::allocate(n * sizeof(T));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	static T* allocate(void)</span><br><span class="line">	&#123;</span><br><span class="line">		return (T*)Alloc::allocate(sizeof(T));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	static void deallocate(T* p, size_t n)</span><br><span class="line">	&#123;</span><br><span class="line">		if (n != 0)</span><br><span class="line">		&#123;</span><br><span class="line">			Alloc::deallocate(p, n * sizeof(T));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	static void deallocate(T* p)</span><br><span class="line">	&#123;</span><br><span class="line">		Alloc::deallocate(p, sizeof(T));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.ax1x.com/2019/12/09/QwzT6f.jpg" alt=""><br>EXAMPLE:</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">template &lt;<span class="keyword">class</span> <span class="symbol">T, <span class="symbol">class</span></span> <span class="symbol">Alloc</span> = <span class="symbol">alloc</span>&gt; //<span class="symbol">alloc</span>是第一级/第二级配置器</span><br><span class="line"><span class="symbol">class</span> <span class="symbol">vector</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">typedef</span> simple_alloc&lt;T, Alloc&gt; data_allocator;</span><br><span class="line">	data_allocator(n);   <span class="comment">//配置n个元素</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="第一级配置器-malloc-alloc-template"><a href="#第一级配置器-malloc-alloc-template" class="headerlink" title="第一级配置器 __malloc_alloc_template"></a>第一级配置器 __malloc_alloc_template</h3><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;new&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __THROW_BAD_ALLOC</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> !defined(__THORW_BAD_ALLOC)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __THROW_BAD_ALLOC cerr&lt;&lt;<span class="meta-string">"out of memory"</span>&lt;&lt;endl; exit(1)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> inst&gt;</span><br><span class="line">class __malloc_alloc_template</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="comment">// 以下都是函数指针，用来处理内存不足的情况</span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">void</span>* oom_malloc(size_t);</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">void</span>* oom_realloc(<span class="keyword">void</span>*, size_t);</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">void</span>(*__malloc_alloc_oom_handler)();</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">void</span>* allocate(size_t n)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">void</span>* result = malloc(n);  <span class="comment">//第一级配置器直接使用malloc</span></span><br><span class="line">		<span class="built_in">if</span> (result == NULL)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//无法满足需求就用oom_malloc</span></span><br><span class="line">			result = oom_malloc(n);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">return</span> result;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">void</span> deallocate(<span class="keyword">void</span>* p, size_t <span class="comment">/* n */</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		free(p);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">void</span> reallocate(<span class="keyword">void</span>* p, size_t <span class="comment">/* old_sz */</span>, size_t new_sz)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">void</span>* result = realloc(p, new_sz);</span><br><span class="line">		<span class="built_in">if</span> (result == NULL)</span><br><span class="line">		&#123;</span><br><span class="line">			result = oom_malloc(p, new_sz);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">return</span> result;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">auto</span> set_malloc_handler(<span class="keyword">void</span> (*f)()) -&gt; <span class="keyword">void</span> (*)()   <span class="comment">//错误信息处理函数</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//void (*old)() = __malloc_alloc_oom_handler;</span></span><br><span class="line">		<span class="keyword">auto</span> old = __malloc_alloc_oom_handler;</span><br><span class="line">		__malloc_alloc_oom_handler = f;</span><br><span class="line">		<span class="built_in">return</span> old;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//错误处理函数初值为0，等待设置</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __STL_STATIC_TEMPLATE_MEMBER_BUG</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> inst&gt;</span><br><span class="line"><span class="keyword">void</span> (*__malloc_alloc_template&lt;inst&gt;::__malloc_alloc_oom_handler)() = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> inst&gt;</span><br><span class="line"><span class="keyword">void</span>* __malloc_alloc_template&lt;inst&gt;::oom_malloc(size_t n)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">void</span> (*my_malloc_handler)();</span><br><span class="line">	<span class="keyword">void</span>* result;</span><br><span class="line">	<span class="built_in">for</span> (;;)</span><br><span class="line">	&#123;</span><br><span class="line">		my_malloc_handler = __malloc_alloc_oom_handler;</span><br><span class="line">		<span class="built_in">if</span> (my_malloc_handler == <span class="number">0</span>)   <span class="comment">//没有定义错误信息处理函数</span></span><br><span class="line">		&#123;</span><br><span class="line">			__THROW_BAD_ALLOC;  <span class="comment">//使用define定义</span></span><br><span class="line">		&#125;</span><br><span class="line">		(*my_malloc_handler)();   <span class="comment">//调用处理例程，企图释放内存</span></span><br><span class="line">		result = malloc(n);   <span class="comment">//再次尝试配置内存</span></span><br><span class="line">		<span class="built_in">if</span> (result) <span class="built_in">return</span>(result);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> inst&gt;</span><br><span class="line"><span class="keyword">void</span>* __malloc_alloc_template&lt;inst&gt;::oom_realloc(<span class="keyword">void</span> *p, size_t n)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">void</span> (*my_malloc_handler)();</span><br><span class="line">	<span class="keyword">void</span>* result;</span><br><span class="line">	<span class="built_in">for</span> (;;)</span><br><span class="line">	&#123;</span><br><span class="line">		my_malloc_handler = __malloc_alloc_oom_handler;</span><br><span class="line">		<span class="built_in">if</span> (my_malloc_handler == <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			__THROW_BAD_ALLOC;</span><br><span class="line">		&#125;</span><br><span class="line">		(*my_malloc_handler)();</span><br><span class="line">		result = realloc(p, n);</span><br><span class="line">		<span class="built_in">if</span> (result) <span class="built_in">return</span>(result);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> __malloc_alloc_template&lt;<span class="number">0</span>&gt; malloc_alloc;</span><br><span class="line"><span class="keyword">typedef</span> malloc_alloc alloc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> my_new_handler()</span><br><span class="line">&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">"out of memory"</span> &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//to do , delete some memory.</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span><br><span class="line">&#123;</span><br><span class="line">	malloc_alloc::set_malloc_handler(my_new_handler);</span><br><span class="line">	<span class="keyword">int</span>* p = (<span class="keyword">int</span>*)malloc_alloc::allocate((<span class="keyword">long</span> <span class="keyword">long</span>)<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * <span class="number">10</span>);</span><br><span class="line">	*p = <span class="number">100</span>;</span><br><span class="line">	cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">	malloc_alloc::deallocate(p, <span class="number">0</span>);</span><br><span class="line">	<span class="built_in">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第二级配置器-default-alloc-template"><a href="#第二级配置器-default-alloc-template" class="headerlink" title="第二级配置器 __default_alloc_template"></a>第二级配置器 __default_alloc_template</h3><p>&emsp;&emsp;当区块小于128bytes时，以内存池(memory pool)管理，此法称为次层配置：每次配置一大块内存，并维护对应之自由链表，下次若再有相同大小的内存需求，就直接从自由链表中取出。如果客端释放小额内存区块，就由配置器回收到自由链表。（配置器负责配置也负责回收）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> &#123;__ALIGN = <span class="number">8</span>&#125;;  <span class="comment">//小型区块的上调边界</span></span><br><span class="line"><span class="keyword">enum</span> &#123;__MAX_BYTES = <span class="number">128</span>&#125;; <span class="comment">//小型区块的上界</span></span><br><span class="line"><span class="keyword">enum</span> &#123;__NFREELISTS = __MAX_BYTES/__ALIGN&#125;;  <span class="comment">//free-list个数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二级配置器</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">bool</span> threads, <span class="keyword">int</span> inst&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> __<span class="title">default_alloc_template</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="function"><span class="keyword">static</span> size_t <span class="title">ROUND_UP</span><span class="params">(<span class="keyword">size_t</span> bytes)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> ((bytes)+__ALIGN - <span class="number">1</span>) &amp; ~(__ALIGN - <span class="number">1</span>);</span><br><span class="line">		<span class="comment">//https://www.it610.com/article/4741877.htm</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">union</span> obj</span><br><span class="line">	&#123;</span><br><span class="line">		obj* free_list_link;</span><br><span class="line">		<span class="keyword">char</span> client_data[<span class="number">1</span>];</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">static</span> obj* <span class="keyword">volatile</span> free_list[__NFREELISTS];   <span class="comment">//一共有多少块</span></span><br><span class="line">	<span class="function"><span class="keyword">static</span> size_t <span class="title">FREELIST_INDEX</span><span class="params">(<span class="keyword">size_t</span> bytes)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> ((bytes)+__ALIGN - <span class="number">1</span>) / (__ALIGN - <span class="number">1</span>);  <span class="comment">//在多少块</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">refill</span><span class="params">(<span class="keyword">size_t</span> n)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">char</span>* <span class="title">chunk_alloc</span><span class="params">(<span class="keyword">size_t</span> size, <span class="keyword">int</span>&amp; nobjs)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//内存池子</span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">char</span>* start_free;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">char</span>* end_free;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">size_t</span> heap_size;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">allocate</span><span class="params">(<span class="keyword">size_t</span> n)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"调用alloc函数申请"</span> &lt;&lt; n &lt;&lt; <span class="string">"大小空间\n"</span>;</span><br><span class="line">		obj* <span class="keyword">volatile</span>* my_free_list;</span><br><span class="line">		obj* result;</span><br><span class="line">		<span class="keyword">if</span> (n &gt; (<span class="keyword">size_t</span>)__MAX_BYTES)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="string">"大于128直接调malloc\n"</span>;</span><br><span class="line">			<span class="comment">//return malloc_alloc::allocate(n);</span></span><br><span class="line">		&#125;</span><br><span class="line">		my_free_list = FREELIST_INDEX(n) + free_list;</span><br><span class="line">		result = *my_free_list;</span><br><span class="line">		<span class="keyword">if</span> (result == <span class="literal">NULL</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="string">"没有可用free_list,refill函数填充链表\n"</span>;</span><br><span class="line">			<span class="keyword">void</span>* r = refill(ROUND_UP(n));</span><br><span class="line">			<span class="keyword">return</span> r;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"有可用的free_list直接使用\n"</span>;</span><br><span class="line">		*my_free_list = result-&gt;free_list_link;</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deallocate</span><span class="params">(<span class="keyword">void</span>* p, <span class="keyword">size_t</span> n)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		obj* q = (obj*)p;</span><br><span class="line">		obj* <span class="keyword">volatile</span>* my_free_list;</span><br><span class="line">		<span class="keyword">if</span> (n &gt; (<span class="keyword">size_t</span>)__MAX_BYTES)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">"调用第一级配置器大小为"</span> &lt;&lt; n &lt;&lt; <span class="string">"内存free回收\n"</span>;</span><br><span class="line">		<span class="comment">//	malloc_alloc::deallocate(p, n);</span></span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">"调用第二级配置器回收大小为"</span> &lt;&lt; n &lt;&lt; <span class="string">"内存\n"</span>;</span><br><span class="line">		my_free_list = FREELIST_INDEX(n) + free_list;</span><br><span class="line">		q-&gt;free_list_link = *my_free_list;</span><br><span class="line">		*my_free_list = q;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">reallocate</span><span class="params">(<span class="keyword">void</span>* p, <span class="keyword">size_t</span> old_sz, <span class="keyword">size_t</span> new_sz)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">void</span>* result;</span><br><span class="line">		<span class="keyword">size_t</span> copy_sz;</span><br><span class="line">		<span class="keyword">if</span> (old_sz &gt; (<span class="keyword">size_t</span>)__MAX_BYTES &amp;&amp; new_sz &gt; (<span class="keyword">size_t</span>)__MAX_BYTES)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="built_in">realloc</span>(p, new_sz);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (ROUND_UP(old_sz) == ROUND_UP(new_sz))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> p;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		result = allocate(new_sz);</span><br><span class="line">		copy_sz = new_sz &gt; old_sz ? old_sz : new_sz;</span><br><span class="line">		<span class="built_in">memcpy</span>(result, p, copy_sz);</span><br><span class="line">		deallocate(p, old_sz);</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">size_t</span> left()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">"内存池剩余"</span> &lt;&lt; end_free - start_free &lt;&lt; <span class="string">"大小空间\n"</span>;</span><br><span class="line">		<span class="keyword">return</span> end_free - start_free;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">bool</span> threads, <span class="keyword">int</span> inst&gt;</span><br><span class="line"><span class="keyword">char</span>* __default_alloc_template&lt;threads, inst&gt;::start_free = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">bool</span> threads, <span class="keyword">int</span> inst&gt;</span><br><span class="line"><span class="keyword">char</span>* __default_alloc_template&lt;threads, inst&gt;::end_free = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">bool</span> threads, <span class="keyword">int</span> inst&gt;</span><br><span class="line"><span class="keyword">size_t</span> __default_alloc_template&lt;threads, inst&gt;::heap_size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">bool</span> threads, <span class="keyword">int</span> inst&gt;</span><br><span class="line"><span class="keyword">typename</span> __default_alloc_template&lt;threads,inst&gt;::obj* <span class="keyword">volatile</span></span><br><span class="line">__default_alloc_template&lt;threads, inst&gt;::free_list[__NFREELISTS] = </span><br><span class="line">&#123; <span class="literal">NULL</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span> &#125;;</span><br><span class="line"><span class="comment">//还未分配内存</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">bool</span> threads, <span class="keyword">int</span> inst&gt;</span><br><span class="line"><span class="keyword">char</span>* __default_alloc_template&lt;threads, inst&gt;::chunk_alloc(<span class="keyword">size_t</span> size, <span class="keyword">int</span>&amp; nobjs)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"进入chunk_alloc函数申请"</span> &lt;&lt; size * nobjs &lt;&lt; <span class="string">"大小内存"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">char</span>* result;</span><br><span class="line">	<span class="keyword">size_t</span> total_bytes = size * nobjs; <span class="comment">//要申请的总共空间</span></span><br><span class="line">	<span class="keyword">size_t</span> bytes_left = end_free - start_free; <span class="comment">//内存池剩余空间</span></span><br><span class="line">	<span class="keyword">if</span> (bytes_left &gt;= total_bytes) <span class="comment">//容量满足</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"内存池剩余空间足够多"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		result = start_free;</span><br><span class="line">		start_free += total_bytes;</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (bytes_left &gt;= size) <span class="comment">// 内存池剩余空间不能完全满足需求量，但能提供一个（以上）的区块</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"内存池空间不够，但还可以提供一个或一个以上的区块空间"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		nobjs = bytes_left / size;  <span class="comment">//能供应多少块</span></span><br><span class="line">		total_bytes = size * nobjs;  <span class="comment">//更新后的申请空间</span></span><br><span class="line">		result = start_free;</span><br><span class="line">		start_free += total_bytes;</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>    <span class="comment">// 内存池剩余空间一个区块都无法提供</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"一个区块都无法提供"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">size_t</span> bytes_to_get = <span class="number">2</span> * total_bytes + ROUND_UP(heap_size &gt;&gt; <span class="number">4</span>);</span><br><span class="line">		<span class="keyword">if</span> (bytes_left &gt; <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//内存池还有一些零头，先赔给适当的free_list</span></span><br><span class="line">			<span class="comment">//首先寻找适当的free list</span></span><br><span class="line">			obj* <span class="keyword">volatile</span>* my_free_list = free_list + FREELIST_INDEX(bytes_left);</span><br><span class="line"></span><br><span class="line">			((obj*)start_free)-&gt;free_list_link = *my_free_list;  <span class="comment">//指向下一个obj，头插法</span></span><br><span class="line">			*my_free_list = (obj*)start_free;</span><br><span class="line">		&#125;</span><br><span class="line">		start_free = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(bytes_to_get);<span class="comment">// 申请堆内存，补充内存池</span></span><br><span class="line">		<span class="keyword">if</span> (start_free == <span class="literal">NULL</span>)   <span class="comment">//分配失败</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> i;</span><br><span class="line">			obj* <span class="keyword">volatile</span>* my_free_list, * p;</span><br><span class="line">			<span class="keyword">for</span> (i = size; i &lt;= __MAX_BYTES; i += __ALIGN)</span><br><span class="line">			&#123;</span><br><span class="line">				my_free_list = free_list + FREELIST_INDEX(i);   <span class="comment">//找到位置 free_list是指针数组</span></span><br><span class="line">				p = *my_free_list;</span><br><span class="line">				<span class="keyword">if</span> (p != <span class="literal">NULL</span>)  <span class="comment">//还有可以分配的区块</span></span><br><span class="line">				&#123;</span><br><span class="line">					*my_free_list = p-&gt;free_list_link;  <span class="comment">//指向下一个区块</span></span><br><span class="line">					start_free = (<span class="keyword">char</span>*)p;</span><br><span class="line">					end_free = start_free + i;   <span class="comment">//把该区块合并入内存池</span></span><br><span class="line">					<span class="keyword">return</span> chunk_alloc(size, nobjs);</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line">			end_free = <span class="number">0</span>; <span class="comment">// 出现意外，无内存可用</span></span><br><span class="line">			<span class="comment">//start_free = (char*)malloc_alloc::allocate(bytes_to_get); // 抛出异常或者内存不足的情况获得改善</span></span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">		heap_size += bytes_to_get;</span><br><span class="line">		end_free = start_free + bytes_to_get;</span><br><span class="line">		<span class="keyword">return</span> chunk_alloc(size, nobjs);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 重新填充 refill，当free list中没有可用区块时，调用refill，为free list重新填充空间</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">bool</span> threads, <span class="keyword">int</span> inst&gt;</span><br><span class="line"><span class="keyword">void</span>* __default_alloc_template&lt;threads, inst&gt;::refill(<span class="keyword">size_t</span> n)</span><br><span class="line">&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span> nobjs = <span class="number">20</span>;    <span class="comment">//填充20块</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"从内存池调"</span> &lt;&lt; n * nobjs &lt;&lt; <span class="string">"内存\n"</span>;</span><br><span class="line">	<span class="comment">// 调用 chunk_alloc，尝试取得 njobs 个区块作为 free_list 的新节点</span></span><br><span class="line">	<span class="comment">// nobjs为引用</span></span><br><span class="line">	<span class="keyword">char</span>* chunk = chunk_alloc(n, nobjs);</span><br><span class="line">	obj* <span class="keyword">volatile</span>* my_free_list;</span><br><span class="line">	obj* result;</span><br><span class="line">	obj* current_obj, * next_obj;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="comment">// 只获得一个区块</span></span><br><span class="line">	<span class="keyword">if</span> (nobjs == <span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> chunk;</span><br><span class="line">	&#125;</span><br><span class="line">	my_free_list = free_list + FREELIST_INDEX(n);</span><br><span class="line">	result = (obj*)chunk;</span><br><span class="line">	<span class="comment">//引导free list指向新配置的空间(取自内存池)</span></span><br><span class="line">	*my_free_list = next_obj = (obj*)(chunk + n);</span><br><span class="line">	<span class="comment">//free list的各节点连接起来</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span>; ; i++) <span class="comment">//从1开始，0个返回给了客端</span></span><br><span class="line">	&#123;</span><br><span class="line">		current_obj = next_obj;</span><br><span class="line">		next_obj = (obj*)((<span class="keyword">char</span> *)next_obj + n);</span><br><span class="line">		<span class="keyword">if</span> (nobjs - <span class="number">1</span> == i)  <span class="comment">//nobjs是动态调整的</span></span><br><span class="line">		&#123;</span><br><span class="line">			current_obj-&gt;free_list_link = <span class="number">0</span>;  <span class="comment">//把空间维护进链表</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			current_obj-&gt;free_list_link = next_obj;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	__default_alloc_template&lt;<span class="literal">true</span>, <span class="number">99</span>&gt; a;</span><br><span class="line">	<span class="keyword">void</span>* p = a.allocate(<span class="number">8</span>);</span><br><span class="line">	a.left();</span><br><span class="line">	<span class="keyword">void</span>* h = a.allocate(<span class="number">64</span>);</span><br><span class="line">	a.left();</span><br><span class="line">	a.deallocate(h, <span class="number">64</span>);</span><br><span class="line">	a.left();</span><br><span class="line">	<span class="keyword">void</span>* n = a.allocate(<span class="number">8</span>);</span><br><span class="line">	a.left();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.ax1x.com/2019/12/16/Q5mcon.png" alt=""><br><img src="https://s2.ax1x.com/2019/12/16/Q5nVl8.png" alt=""></p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>SQL源码剖析</tag>
      </tags>
  </entry>
  <entry>
    <title>C++随机数</title>
    <url>/2019/11/19/C-%E9%9A%8F%E6%9C%BA%E6%95%B0/</url>
    <content><![CDATA[<p>简介： C++如何生成随机数</p>
<a id="more"></a>
<h1 id="随机数引擎"><a href="#随机数引擎" class="headerlink" title="随机数引擎"></a>随机数引擎</h1><p>&emsp;&emsp;头文件<code>&lt;random&gt;</code><br>&emsp;&emsp;定义一个<code>default_random_engine</code>对象，调用它就能获得随机数</p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">default_random_engine e<span class="comment">;</span></span><br><span class="line">cout&lt;&lt;e()<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p><img src="https://s1.ax1x.com/2019/11/19/M2TXY8.jpg" alt=""></p>
<h1 id="分布类型"><a href="#分布类型" class="headerlink" title="分布类型"></a>分布类型</h1><p>&emsp;&emsp;使用分布类型可以的到某一个范围内的随机数</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">uniform_int_distribution&lt;unsigned&gt; u(<span class="number">0</span>,<span class="number">9</span>);</span><br><span class="line">cout&lt;&lt;u(e);</span><br><span class="line"><span class="comment">//生成均匀分布的unsigned类型的【0，9】之间的值</span></span><br></pre></td></tr></table></figure>

<h1 id="设置随机数种子"><a href="#设置随机数种子" class="headerlink" title="设置随机数种子"></a>设置随机数种子</h1><figure class="highlight isbl"><table><tr><td class="code"><pre><span class="line"><span class="variable">default_random_engine</span> <span class="function"><span class="title">e</span>(<span class="title"><span class="built_in">time</span></span>(<span class="variable"><span class="literal">NULL</span></span>));</span></span><br><span class="line"><span class="function"><span class="variable">e.seed</span>(<span class="title"><span class="built_in">time</span></span>(<span class="variable"><span class="literal">NULL</span></span>));</span></span><br></pre></td></tr></table></figure>

<h1 id="生成随机实数"><a href="#生成随机实数" class="headerlink" title="生成随机实数"></a>生成随机实数</h1><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">uniform_real_distribution&lt;<span class="built_in">double</span>&gt; u(<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">cout&lt;&lt;u(e);</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;空尖括号默认代表为double</p>
<h1 id="生成非均匀分布的随机数"><a href="#生成非均匀分布的随机数" class="headerlink" title="生成非均匀分布的随机数"></a>生成非均匀分布的随机数</h1><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">default_random_engine e;</span><br><span class="line">normal_distribution&lt;&gt; n(<span class="number">4</span>,<span class="number">1.5</span>);   <span class="comment">//均值为4，标准差为1.5</span></span><br></pre></td></tr></table></figure>

<h1 id="bernoulli-distribution类"><a href="#bernoulli-distribution类" class="headerlink" title="bernoulli_distribution类"></a>bernoulli_distribution类</h1><p>&emsp;&emsp;总是返回一个bool值，概率分别为0.5</p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">default_random_engine e<span class="comment">;</span></span><br><span class="line">bernoulli_distribution b<span class="comment">;</span></span><br><span class="line">cout&lt;&lt;b(e)<span class="comment">;</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>二分图</title>
    <url>/2019/11/18/%E4%BA%8C%E5%88%86%E5%9B%BE/</url>
    <content><![CDATA[<p>简介： 用染色法判断二分图</p>
<a id="more"></a>
<h1 id="二分图"><a href="#二分图" class="headerlink" title="二分图"></a>二分图</h1><p>&emsp;&emsp;二部图又叫二分图，是图论中的一种特殊模型。设G=(V,E)是一个无向图，如果顶点V可分割为两个互不相交的子集(A,B)，并且图中的每条边（i，j）所关联的两个顶点i和j分别属于这两个不同的顶点集(i in A,j in B)，则称图G为一个二分图。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//二分图：简单来说，如果图中点可以被分为两组,图中不含奇数环 </span></span><br><span class="line"><span class="comment">//对所有的点染色，相邻两个点的颜色一定不一样 </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">200020</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,color[maxn];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; adj[maxn];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	color[u]=c;   <span class="comment">//对这一个点染色</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;adj[u].size(); i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> v=adj[u][i];</span><br><span class="line">		<span class="keyword">if</span>(!color[v])       <span class="comment">//v点也没有染色 </span></span><br><span class="line">		&#123; </span><br><span class="line">			<span class="keyword">if</span>(!dfs(v, <span class="number">3</span>-c))	<span class="keyword">return</span> <span class="literal">false</span>;     <span class="comment">//染色失败，只能染成1和2 </span></span><br><span class="line">		&#125;	</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(color[v]==c)	<span class="keyword">return</span> <span class="literal">false</span>;     <span class="comment">//一条边两个点不能是相同的颜色 </span></span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	<span class="keyword">while</span>(m--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> x,y;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;x&gt;&gt;y;</span><br><span class="line">		adj[x].push_back(y);</span><br><span class="line">		adj[y].push_back(x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">bool</span> flag=<span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(!color[i])   <span class="comment">//如果还没有染色 </span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(!dfs(i,<span class="number">1</span>))		<span class="comment">//如果有冲突 </span></span><br><span class="line">			&#123;</span><br><span class="line">				flag=<span class="literal">false</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(flag)	<span class="built_in">cout</span>&lt;&lt;<span class="string">"Yes"</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="string">"No"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法笔记</category>
      </categories>
  </entry>
  <entry>
    <title>文件I/O</title>
    <url>/2019/11/17/%E6%96%87%E4%BB%B6I-O/</url>
    <content><![CDATA[<p>简介： APUE第三章-文件I/O</p>
<a id="more"></a>
<h1 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a>文件描述符</h1><p>对内核而言，所有打开的文件都通过文件描述符引用，当打开一个现有文件或者创建一个新文件时，内核会向进程返回文件描述符。</p>
<p>UNIX系统shell把文件描述符0与标准输入关联，文件描述符1与标准输出关联，文件描述符2与标准错误管理。0，1，2分别用STDIN_FILENO,STDOUT_FILENO,STDERR_FILENO表示（头文件为<code>&lt;unistd.h&gt;</code>）。</p>
<h1 id="函数open与openat"><a href="#函数open与openat" class="headerlink" title="函数open与openat"></a>函数open与openat</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">open</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">int</span> oflag, ...<span class="comment">/*mode_t mode*/</span>)</span></span>;</span><br><span class="line"><span class="comment">//对于open，只有新创建文件时，最后的权限位才被声明</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">openat</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">int</span> oflag, ...<span class="comment">/*mode_t mode*/</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p>参数path：要打开或者创建的文件名<br>参数oflag:<br>&emsp;&emsp;O_RDONLY&emsp;&emsp;只读打开<br>&emsp;&emsp;O_WRONLY&emsp;&emsp;只写打开<br>&emsp;&emsp;O_RDWR&emsp;&emsp;读、写打开<br>&emsp;&emsp;O_EXEC&emsp;&emsp;只执行打开<br>&emsp;&emsp;O_SEARCH&emsp;&emsp;只搜索打开（应用于目录）<br>以上五个参数必须指定一个<br>&emsp;&emsp;O_APPEND&emsp;&emsp;每次写都追加到文件末尾<br>&emsp;&emsp;O_CREAT&emsp;&emsp;若文件不存在则创建，使用open时必须指定权限位<br>&emsp;&emsp;O_TRUNC&emsp;&emsp;若文件存在，而且为只写或读写成功打开，则将其长度截断为0<br>以上参数为可选<br>&emsp;&emsp;两函数返回的文件描述符一定是最小的未用描述符数值<br>&emsp;&emsp;区别：</p>
<ul>
<li>path指定绝对路径名，此时fd可被忽略，openat相当于open</li>
<li>path制定相对路径名，fd指出相对路径名在文件系统中的开始地址</li>
<li>path制定相对路径名，fd具有特殊值AT_FDCWD，此时路径名在当前工作目录中获取</li>
</ul>
<h1 id="函数creat"><a href="#函数creat" class="headerlink" title="函数creat"></a>函数creat</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">creat</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">mode_t</span> mode)</span></span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;此函数等价于</p>
<figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">open(<span class="name">apth</span>, O_WRONLT | O_CREAT | OTRUNC, mode)</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;creat只以只写方式打开所创建的文件</p>
<h1 id="函数close"><a href="#函数close" class="headerlink" title="函数close"></a>函数close</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">close</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;关闭一个打开的文件，关闭文件时还会释放加载该文件上的所有记录锁</p>
<h1 id="函数lseek"><a href="#函数lseek" class="headerlink" title="函数lseek"></a>函数lseek</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">off_t</span> lseek(<span class="keyword">int</span> fd, <span class="keyword">off_t</span> offset, <span class="keyword">int</span> whence);</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;每个打开文件都有一个与其关联的文件偏移量（通常为非负整数），当打开一个文件时，除非制定O_APPEND选项，复杂偏移量设置为0<br>&emsp;&emsp;offset参数：与参数whence的值有关</p>
<ul>
<li>whence是SEEK_SET，则将该文件的偏移量设置为距文件开始offset字节处</li>
<li>whence是SEEK_CUR,则将该文件的偏移量设置为当前值加offset，offset可正可负</li>
<li>whence是SEEK_END，则将该文件的偏移量值设置为文件长度加offset，offset可正可负</li>
</ul>
<p>&emsp;&emsp;若lseek成功执行，则返回新的文件偏移量，如果文件描述符指向的是一个管道、FIFO、或者网络套接字，则lseek返回-1，并将errno设置为ESPIPE。<br>&emsp;&emsp;lseek仅将文件偏移量记录在内核中，它并不引起任何I/O操作。文件偏移量可以大于当前长度，在这种情况下，对该文件的下一次写将加长该文件，并在文件中构成一个空洞。<strong>文件中的空洞并不要求在磁盘上占用存储区</strong>。当定位到超出文件尾端之后写时，对于新写的数据需要分配磁盘块，但是对于源文件尾端和新开始写位置之间的部分不需要分配磁盘块。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_MODE   (S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH) </span></span><br><span class="line"><span class="keyword">char</span> buf1[]=<span class="string">"abcdefghij"</span>; </span><br><span class="line"><span class="keyword">char</span> buf2[]=<span class="string">"ABCDEFGHIJ"</span>; </span><br><span class="line">     </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">     <span class="keyword">int</span> fd; </span><br><span class="line">     <span class="keyword">if</span>((fd=creat(<span class="string">"file.hole"</span>, FILE_MODE)) &lt; <span class="number">0</span>) </span><br><span class="line">     &#123; </span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"creat error"</span>); </span><br><span class="line">     &#125; </span><br><span class="line">     <span class="keyword">if</span>(write(fd, buf1, <span class="number">10</span>) != <span class="number">10</span>) </span><br><span class="line">     &#123; </span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"buf1 write error"</span>); </span><br><span class="line">     &#125; </span><br><span class="line">     <span class="keyword">if</span>(lseek(fd, <span class="number">16384</span>, SEEK_SET) == <span class="number">-1</span>) </span><br><span class="line">     &#123; </span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"lseek error"</span>);</span><br><span class="line">     &#125; </span><br><span class="line">     <span class="keyword">if</span>(srite(fd, buf2, <span class="number">10</span>)!=<span class="number">10</span>) </span><br><span class="line">     &#123; </span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"buf2 write error"</span>); </span><br><span class="line">     &#125; </span><br><span class="line">     <span class="built_in">exit</span>(<span class="number">0</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.ax1x.com/2019/11/18/M6Zqdf.png" alt=""><br>有空洞的文件占8个磁盘块</p>
<h1 id="函数read"><a href="#函数read" class="headerlink" title="函数read"></a>函数read</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ssize_t</span> read(<span class="keyword">int</span> fd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> nbytes);</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;如果read成功，则返回读到的字节数，如果已经到达文件的末尾，返回0；<br>&emsp;&emsp;实际读取字节数少于要求读取字节数：</p>
<ul>
<li>读普通文件时，在读到要求字节数之前已达到了文件尾端</li>
<li>当从终端设备读时，通常一次最多读一行</li>
<li>当从网络读时，网络中的缓冲机制可能造成返回值小于所需数量</li>
<li>当从管道或者FIFO读时，若管道包含字节数少于所需数量，那么read只返回实际可用字节数</li>
<li>当从某些面向记录的设备（如磁带）读时，一次最多返回一个记录</li>
<li>当一信号造成中断，而已经读取了部分数据量时<br>&emsp;&emsp;读操作从文件当前偏移量处开始，在成功返回之前，该偏移量将增加实际读到的字节数</li>
</ul>
<h1 id="函数write"><a href="#函数write" class="headerlink" title="函数write"></a>函数write</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="keyword">ssize_t</span> write(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> nbytes);</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;若成功，返回已写字节数；若出错，返回-1<br>&emsp;&emsp;出错的一个常见原因是磁盘已写满，或者超过了一个给定进程的文件长度限制</p>
<h1 id="文件共享"><a href="#文件共享" class="headerlink" title="文件共享"></a>文件共享</h1><p>&emsp;&emsp;内核使用三种数据结构表示打开文件</p>
<ul>
<li>每个进程在进程表中都有一个记录项，记录项中包含一张打开的文件描述符表，每个文件描述符占用一项。与每个文件描述符相关联的是：<br>&emsp;&emsp;1. 文件描述符标值<br>&emsp;&emsp;2. 指向一个文件表项的指针</li>
<li>内核为所有打开文件维持一张文件表，每个文件表项包含<br>&emsp;&emsp;1. 文件状态标值<br>&emsp;&emsp;2. 当前文件偏移量<br>&emsp;&emsp;3. 指向该文件v节点表项的指针</li>
<li>每个打开文件都有一个v（v-node）节点结构，v节点包含了文件类型和对此文件进行各种操作函数的指针。对于大多数文件，v节点还包含了该文件的i节点（索引节点），i节点包含了文件的所有者、文件长度、指向文件实际数据块在磁盘上所在的位置的指针等。<br><img src="https://s2.ax1x.com/2019/11/18/M6lTVs.png" alt=""></li>
</ul>
<p>&emsp;&emsp;若两个独立进程各自打开同意文件，则有如下关系：<br><img src="https://s2.ax1x.com/2019/11/18/M63zNR.png" alt=""></p>
<ul>
<li>在完成每个write后，在文件表项中的当前文件偏移量处增加所写入的字节数</li>
<li>如果用O_APPEND标志打开一个文件，则相应的标值也被设置到文件表项的文件状态标志中</li>
<li>若一个文件用lseek定位到文件当前的尾端，则文件表项中的当前文件偏移量首先会被设置为i节点表象中的文件长度。</li>
</ul>
<h1 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a>原子操作</h1><p>&emsp;&emsp;<strong>原子操作</strong>指的是由多步组成的一个操作。如果该操作原子地执行，则要么执行完所有的步骤，要么一步也不执行，不可能只执行所有步骤的一个子集。<br>&emsp;&emsp;UNIX系统提供了一种源自操作方法，即在打开文件时设置O_APPEND标志</p>
<h2 id="函数pread与pwrite"><a href="#函数pread与pwrite" class="headerlink" title="函数pread与pwrite"></a>函数pread与pwrite</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ssize_t</span> pread(<span class="keyword">int</span> fd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> bytes, <span class="keyword">off_t</span> offset);</span><br><span class="line"><span class="comment">//返回值：读到字节数，若已到文件尾，返回0；出错返回-1</span></span><br><span class="line"><span class="keyword">ssize_t</span> pwrite(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> nbytes, <span class="keyword">off_t</span> offset);</span><br><span class="line"><span class="comment">//返回值：若成功返回已写字节数；出错返回-1</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;调用pread相当于调用lseek后调用read，但区别如下</p>
<ul>
<li>调用pread时，无法中断其定位和读操作</li>
<li>不能更新当前文件偏移量<br>&emsp;&emsp;调用pwrite类似</li>
</ul>
<h1 id="函数dup与dup2"><a href="#函数dup与dup2" class="headerlink" title="函数dup与dup2"></a>函数dup与dup2</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dup</span><span class="params">(fd)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dup2</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> fd2)</span></span>;</span><br><span class="line">/两函数的返回值：成功返回新的文件描述符；出错返回<span class="number">-1</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;两函数都可以用来复制一个现有的文件描述符<br>&emsp;&emsp;由dup返回的新文件描述符一定是当前可用文件描述符中的最小数值。<br>&emsp;&emsp;对于dup2，可以用fd2指定新描述符值。若fd2已经打开，则先将其关闭。若fd等于fd2，则dup2返回fd2，而不关闭它。目的是将旧的文件描述符fd复制给新的文件描述符fd2.dup2所复制的文件描述符与原来的文件描述符共享各种文件状态。共享所有的锁定，读写位置和各项权限或flags等等。</p>
<h1 id="函数sync、fsync和fdatasync"><a href="#函数sync、fsync和fdatasync" class="headerlink" title="函数sync、fsync和fdatasync"></a>函数sync、fsync和fdatasync</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fsync</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fdatasync</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sync</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;sync只是将所有修改过的块排入写队列，然后就返回，并不等待实际写磁盘操作结束。系统守护进程会周期性的调用sync。<br>&emsp;&emsp;fsync函数只对文件描述符fd指定的一个文件起作用，并且等待写磁盘操作结束后才返回<br>&emsp;&emsp;fdatasync函数类似于fsync，但它只影响文件的数据部分。除数据外，fsync还会更新文件的属性</p>
<h1 id="函数fcntl"><a href="#函数fcntl" class="headerlink" title="函数fcntl"></a>函数fcntl</h1><p>&emsp;&emsp;fcntl函数可以改变已经打开的文件属性，使用fcntl，我们只需要知道打开文件的描述符，就可以修改描述符的属性。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fcntl</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> cmd, ...<span class="comment">/* int arg*/</span>)</span></span>;</span><br><span class="line"><span class="comment">//返回值：若成功则依赖于cmd， 若出错返回-1</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;功能：</p>
<ul>
<li>复制一个已有的描述符 （cmd=F_DUPFD 或 F_DUPFD_CLOEXEC）</li>
<li>获取/设置文件描述符标志（cmd=F_GETFD 或 F_SETFD）</li>
<li>获取/设置文件状态标志（cmd=F_GETFL 或 F_SETFL）</li>
<li>获取/设置异步I/O所有权（cmd=F_GETOWN 或 F_SETOWN）</li>
<li>获取/设置记录锁（cmd=F_GETLK、F_SETLK 或 F_SETLKW）<br><img src="https://s1.ax1x.com/2019/11/19/MgOYuQ.jpg" alt=""><br><img src="https://s1.ax1x.com/2019/11/19/MgOtBj.png" alt=""></li>
</ul>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">#<span class="keyword">include</span> &lt;fcntl.h&gt;</span><br><span class="line"></span><br><span class="line">void set<span class="constructor">_fl(<span class="params">int</span> <span class="params">fd</span>, <span class="params">int</span> <span class="params">flags</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">int</span> <span class="keyword">val</span>;</span><br><span class="line">	<span class="keyword">if</span>((<span class="keyword">val</span>=fcntl(fd, F_GETFL, <span class="number">0</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">		err<span class="constructor">_sys(<span class="string">"fcntl F_GETFL error"</span>)</span>;</span><br><span class="line">	<span class="keyword">val</span> <span class="pattern-match">|= flags;   <span class="operator">/</span><span class="operator">/</span>设置新的文件属性</span></span><br><span class="line"><span class="pattern-match">	<span class="keyword">if</span>(fcntl(fd, <span class="constructor">F_SETFL</span>, <span class="keyword">val</span>) &lt; 0)</span></span><br><span class="line"><span class="pattern-match">		err<span class="constructor">_sys(<span class="string">"fcntl F_SETFL error"</span>)</span>;</span></span><br><span class="line"><span class="pattern-match">&#125;</span></span><br></pre></td></tr></table></figure>

<h1 id="函数ioctl"><a href="#函数ioctl" class="headerlink" title="函数ioctl"></a>函数ioctl</h1><figure class="highlight autoit"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/iocntl.h&gt;</span></span></span><br><span class="line"><span class="built_in">int</span> ioctl(<span class="built_in">int</span> fd, <span class="built_in">int</span> request, ...)<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;ioctl函数一直是I/O操作的杂物箱，许多不能用其他函数表示的I/O操作通常可以用ioctl表示。每个设备驱动程序可以定义它自己专用的一组ioctl命令</p>
]]></content>
      <categories>
        <category>APUE</category>
      </categories>
      <tags>
        <tag>Linux C/C++</tag>
        <tag>APUE</tag>
      </tags>
  </entry>
  <entry>
    <title>线程安全</title>
    <url>/2019/11/16/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/</url>
    <content><![CDATA[<p>简介： 并发问题-线程安全</p>
<a id="more"></a>
<p>#线程安全：<br>&emsp;&emsp;线程安全：当一个函数被多个并发线程反复调用时，它会一直产生正确的结果，则这个函数是线程安全的。<br>&emsp;&emsp;不安全函数类：</p>
<ul>
<li>不保护共享变量的函数</li>
<li>保持跨越多个调用的状态的函数</li>
<li>返回静态变量的指针的函数</li>
<li>调用线程不安全函数的函数</li>
</ul>
<h1 id="可重入函数"><a href="#可重入函数" class="headerlink" title="可重入函数"></a>可重入函数</h1><p>&emsp;&emsp;可重入函数性质：当它们被多个线程调用时，不会引用任何共享数据。<br><img src="https://s2.ax1x.com/2019/11/16/MwqPiR.jpg" alt=""><br>&emsp;&emsp;显式可重入：所有数据引用都是本地的自动栈变量（没有引用静态或者全局变量）<br>&emsp;&emsp;隐式可重入：显式可重入函数中有一些参数是引用传递的，但其不是指向共享变量的指针<br>&emsp;&emsp;标准 C 库中的函数都是线程安全的（如 malloc, free, printf, scanf），大多数 Unix 的系统调用也都是线程安全的</p>
<h1 id="竞争"><a href="#竞争" class="headerlink" title="竞争"></a>竞争</h1><p>&emsp;&emsp;当一个程序的正确性依赖于一个线程要在另一个线程到达y点之前到达它的控制流中的x点时，就会发生竞争。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 4</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thread</span><span class="params">(<span class="keyword">void</span> *vargp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> mytid=*((<span class="keyword">int</span> *)vargp);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"hello from thread %d\n"</span>, mytid);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">pthread_t</span> tid[N]; </span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;N; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		pthread_create(&amp;tid[i], <span class="literal">NULL</span>, thread, &amp;i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;N; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		pthread_join(tid[i], <span class="literal">NULL</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.ax1x.com/2019/11/16/MwONPs.png" alt=""><br>&emsp;&emsp;竞争出现在第14行和第6行，如果在for循环之前就输出了i，则是正确的结果，如若不然，就会失败。<br>&emsp;&emsp;改进后的函数，给每个i都开辟一个单独的存储空间</p>
<figure class="highlight autoit"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span><span class="comment">; i&lt;N; i++)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">ptr</span>=(<span class="built_in">int</span> *)malloc(sizeof(<span class="built_in">int</span>))<span class="comment">;</span></span><br><span class="line">	*<span class="built_in">ptr</span>=i<span class="comment">;</span></span><br><span class="line">	pthread_create(&amp;tid[i], <span class="literal">NULL</span>, thread, <span class="built_in">ptr</span>)<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h1><p>&emsp;&emsp;指的是一组线程被阻塞了，等待一个永远不会为真的条件，<br>&emsp;&emsp;互斥锁加锁规则：给定所有互斥操作的一个全序，如果每个线程都是以一种顺序获得互斥锁并且以相反的顺序释放，则这个程序是无死锁的。</p>
]]></content>
      <categories>
        <category>csapp</category>
      </categories>
      <tags>
        <tag>Linux C/C++</tag>
        <tag>网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title>拓扑排序</title>
    <url>/2019/11/15/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<p>简介： 拓扑排序算法</p>
<a id="more"></a>
<p>&emsp;&emsp;可以求出拓扑序列</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">100010</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; adj[maxn],ans;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> indegree[maxn],n,m;  <span class="comment">//indegree是用来存每个节点的入度 </span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">topologicalSort</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> num=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(indegree[i]==<span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			q.push(i);</span><br><span class="line">		<span class="comment">//	cout&lt;&lt;i&lt;&lt;'.';</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(!q.empty())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> u=q.front();</span><br><span class="line">		q.pop();</span><br><span class="line"></span><br><span class="line">		ans.push_back(u);  <span class="comment">//把该节点加入数组，，其已经是拓扑序列中的一员了 </span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;adj[u].size(); i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> v=adj[u][i];</span><br><span class="line">			indegree[v]--;       <span class="comment">//入度减1</span></span><br><span class="line">			<span class="keyword">if</span>(indegree[v]==<span class="number">0</span>)	q.push(v); </span><br><span class="line">		&#125;</span><br><span class="line">		adj[u].clear();  <span class="comment">//清空从这条边出去的所有边 </span></span><br><span class="line">		num++;     <span class="comment">//加入拓扑序列的顶点数加1 </span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(num==n)	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">else</span>	<span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	<span class="keyword">while</span>(m--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> x,y;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;x&gt;&gt;y;</span><br><span class="line">		adj[x].push_back(y);</span><br><span class="line">		indegree[y]++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">bool</span> flag = topologicalSort();</span><br><span class="line">	<span class="keyword">if</span>(flag)</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">auto</span> i : ans)	<span class="built_in">cout</span>&lt;&lt;i&lt;&lt;<span class="string">' '</span>;</span><br><span class="line">	<span class="keyword">else</span>	<span class="built_in">cout</span>&lt;&lt;<span class="number">-1</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法笔记</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Trie</title>
    <url>/2019/11/14/Trie/</url>
    <content><![CDATA[<p>简介： 字典树</p>
<a id="more"></a>
<p>&emsp;&emsp;Trie字典树主要用于存储字符串，Trie 的每个 Node 保存一个字符。用链表来描述的话，就是一个字符串就是一个链表。每个Node都保存了它的所有子节点。例如我们往字典树中插入see、pain、paint三个单词:</p>
<p><img src="https://s2.ax1x.com/2019/11/14/MNHZkV.png" alt=""></p>
<h1 id="构建函数"><a href="#构建函数" class="headerlink" title="构建函数"></a>构建函数</h1><figure class="highlight axapta"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> insert(<span class="keyword">char</span> <span class="keyword">str</span>[])</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> p=<span class="number">0</span>;          <span class="comment">//第p个节点 ，0为根节点又为空节点 </span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; <span class="keyword">str</span>[i]; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> u=<span class="keyword">str</span>[i]-<span class="string">'a'</span>;</span><br><span class="line">		<span class="keyword">if</span>(!son[p][u])	son[p][u]=++idx;   	</span><br><span class="line">		p=son[p][u];         <span class="comment">//下一个字母 ,无论如何都会往下查找即执行这一句 </span></span><br><span class="line">	&#125;</span><br><span class="line">	cnt[p]++;       <span class="comment">//以p结尾的单词数量多了一个 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="查询函数"><a href="#查询函数" class="headerlink" title="查询函数"></a>查询函数</h1><figure class="highlight axapta"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> query(<span class="keyword">char</span> <span class="keyword">str</span>[])</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> p=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; <span class="keyword">str</span>[i]; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> u=<span class="keyword">str</span>[i]-<span class="string">'a'</span>;</span><br><span class="line">		<span class="keyword">if</span>(!son[p][u])	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		p=son[p][u];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> cnt[p];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法笔记</category>
      </categories>
  </entry>
  <entry>
    <title>echo-预线程化</title>
    <url>/2019/11/10/echo-%E9%A2%84%E7%BA%BF%E7%A8%8B%E5%8C%96/</url>
    <content><![CDATA[<p>简介： 基于预线程化的echo服务器</p>
<a id="more"></a>
<h1 id="main函数"><a href="#main函数" class="headerlink" title="main函数"></a>main函数</h1><p>&emsp;&emsp;创建一系列对等的工作线程，在工作线程中处理客户端传来的输入。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> main(<span class="built_in">int</span> argc, <span class="built_in">char</span> **argv)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">int</span> i,listenfd,connfd;</span><br><span class="line">	socklen_t clientlen;</span><br><span class="line">	<span class="keyword">struct</span> sockaddr_storage clientaddr;</span><br><span class="line">	pthread_t tid;</span><br><span class="line">	<span class="keyword">if</span>(argc != <span class="number">2</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		fprintf(stderr, <span class="string">"usage: %s &lt;port&gt;\n"</span>, argv<span class="literal">[<span class="number">0</span>]</span>);</span><br><span class="line">		exit(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	listenfd=<span class="keyword">open</span><span class="constructor">_listenfd(<span class="params">argv</span>[1])</span>;</span><br><span class="line">	sbuf<span class="constructor">_init(&amp;<span class="params">sbuf</span>, SBUFSIZE)</span>;	</span><br><span class="line">	<span class="comment">//工作线程 </span></span><br><span class="line">	for(i=<span class="number">0</span>; i&lt;NTHREADS; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		pthread<span class="constructor">_create(&amp;<span class="params">tid</span>, NULL, <span class="params">thread</span>, NULL)</span>;  <span class="comment">//创建对等线程 </span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		clientlen=sizeof(<span class="keyword">struct</span> sockaddr_storage);</span><br><span class="line">		connfd=accept(listenfd, (<span class="keyword">struct</span> sockaddr *)&amp;clientaddr, &amp;clientlen);</span><br><span class="line">		sbuf<span class="constructor">_insert(&amp;<span class="params">sbuf</span>, <span class="params">connfd</span>)</span>;	</span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="thread函数"><a href="#thread函数" class="headerlink" title="thread函数"></a>thread函数</h1><p>&emsp;&emsp;首先将线程分离，以便线程结束时系统回收线程的资源，然后读取客户端的输入。</p>
<figure class="highlight isbl"><table><tr><td class="code"><pre><span class="line"><span class="variable">void</span> *<span class="function"><span class="title">thread</span>(<span class="variable">void</span> *<span class="variable">vargp</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="function"><span class="title">pthread_detach</span>(<span class="title">pthread_self</span>());</span></span><br><span class="line"><span class="function">	<span class="title">while</span>(<span class="number">1</span>)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="variable">int</span> <span class="variable">connfd</span>=<span class="function"><span class="title">sbuf_remove</span>(&amp;<span class="variable">sbuf</span>);   <span class="comment">//取出连接符</span></span></span><br><span class="line"><span class="function">		<span class="title">echo_cnt</span>(<span class="variable">connfd</span>);</span></span><br><span class="line"><span class="function">		<span class="title">close</span>(<span class="variable">connfd</span>); </span></span><br><span class="line"><span class="function">	&#125;</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure>
<h1 id="echo-cnt函数"><a href="#echo-cnt函数" class="headerlink" title="echo_cnt函数"></a>echo_cnt函数</h1><p>&emsp;&emsp;调用echo_cnt函数时通过pthread_once函数来初始化线程，读取输入时，对统计总字符的变量加锁以保证其互斥访问。</p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">static void init_echo_cnt(void)</span><br><span class="line">&#123;</span><br><span class="line">	sem_init(&amp;mutex, <span class="number">0</span>, <span class="number">1</span>)<span class="comment">;</span></span><br><span class="line">	<span class="keyword">byte_cnt=0;</span></span><br><span class="line"><span class="keyword">&#125;</span></span><br><span class="line"><span class="keyword">void </span>echo_cnt(int connfd)</span><br><span class="line">&#123;</span><br><span class="line">	int n<span class="comment">;</span></span><br><span class="line">	char <span class="keyword">buf[MAXNLINE];</span></span><br><span class="line"><span class="keyword">	</span>rio_t rio<span class="comment">;</span></span><br><span class="line">	rio_readinitb(&amp;rio, connfd)<span class="comment">;</span></span><br><span class="line">	static pthread_once_t once = PTHREAD_ONCE_INIT<span class="comment">;</span></span><br><span class="line">	pthread_once(&amp;once, init_echo_cnt)<span class="comment">; //即使是在多线程程序中，此函数也只调用一次，由once参数控制 </span></span><br><span class="line">	while((n=rio_readlineb(&amp;rio, <span class="keyword">buf, </span>MAXNLINE)) != <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		P(&amp;mutex)<span class="comment">;</span></span><br><span class="line">		<span class="keyword">byte_cnt+=n;</span></span><br><span class="line"><span class="keyword">	</span>	printf(<span class="string">"server received %d (%d total) bytes on fd %d\n"</span>, n, <span class="keyword">byte_cnt, </span>connfd)<span class="comment">;</span></span><br><span class="line">		V(&amp;mutex)<span class="comment">;</span></span><br><span class="line">		rio_writen(connfd, <span class="keyword">buf, </span>n)<span class="comment">;</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="sbuf相关函数"><a href="#sbuf相关函数" class="headerlink" title="sbuf相关函数"></a>sbuf相关函数</h1><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">typedef <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">int</span> *buf;</span><br><span class="line">	<span class="built_in">int</span> n;</span><br><span class="line">	<span class="built_in">int</span> front,rear;</span><br><span class="line">	sem_t mutex;</span><br><span class="line">	sem_t items;</span><br><span class="line">	sem_t slots;</span><br><span class="line">&#125;sbuf_t;</span><br><span class="line"></span><br><span class="line">void sbuf<span class="constructor">_init(<span class="params">sbuf_t</span> <span class="operator">*</span><span class="params">sp</span>, <span class="params">int</span> <span class="params">x</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	sp-&gt;buf=(<span class="built_in">int</span> *)calloc(x, sizeof(<span class="built_in">int</span>));</span><br><span class="line">	sp-&gt;n=x;</span><br><span class="line">	sp-&gt;front=sp-&gt;rear=<span class="number">0</span>;</span><br><span class="line">	sem<span class="constructor">_init(&amp;<span class="params">sp</span>-&gt;<span class="params">mutex</span>, 0, 1)</span>;</span><br><span class="line">	sem<span class="constructor">_init(&amp;<span class="params">sp</span>-&gt;<span class="params">slots</span>, 0, <span class="params">x</span>)</span>;</span><br><span class="line">	sem<span class="constructor">_init(&amp;<span class="params">sp</span>-&gt;<span class="params">items</span>, 0, 0)</span>;</span><br><span class="line">&#125;</span><br><span class="line">void sbuf<span class="constructor">_insert(<span class="params">sbuf_t</span> <span class="operator">*</span><span class="params">sp</span>, <span class="params">int</span> <span class="params">item</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="constructor">P(&amp;<span class="params">sp</span>-&gt;<span class="params">slots</span>)</span>;</span><br><span class="line">	<span class="constructor">P(&amp;<span class="params">sp</span>-&gt;<span class="params">mutex</span>)</span>;</span><br><span class="line">	sp-&gt;buf<span class="literal">[(<span class="operator">++</span><span class="identifier">sp</span>-&gt;<span class="identifier">rear</span>) % (<span class="identifier">sp</span>-&gt;<span class="identifier">n</span>)]</span>=item;</span><br><span class="line">	<span class="constructor">V(&amp;<span class="params">sp</span>-&gt;<span class="params">items</span>)</span>;</span><br><span class="line">	<span class="constructor">V(&amp;<span class="params">sp</span>-&gt;<span class="params">mutex</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">int</span> sbuf<span class="constructor">_remove(<span class="params">sbuf_t</span> <span class="operator">*</span><span class="params">sp</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">int</span> item;</span><br><span class="line">	<span class="constructor">P(&amp;<span class="params">sp</span>-&gt;<span class="params">items</span>)</span>;      <span class="comment">//取出来以后可用项的数目减一 </span></span><br><span class="line">	<span class="constructor">P(&amp;<span class="params">sp</span>-&gt;<span class="params">mutex</span>)</span>;          <span class="comment">//加互斥锁 </span></span><br><span class="line">	item=sp-&gt;buf<span class="literal">[(<span class="operator">++</span><span class="identifier">sp</span>-&gt;<span class="identifier">front</span>)%(<span class="identifier">sp</span>-&gt;<span class="identifier">n</span>)]</span>;</span><br><span class="line">	<span class="constructor">V(&amp;<span class="params">sp</span>-&gt;<span class="params">mutex</span>)</span>;         <span class="comment">//解开互斥锁 </span></span><br><span class="line">	<span class="constructor">V(&amp;<span class="params">sp</span>-&gt;<span class="params">slots</span>)</span>;        <span class="comment">//取出来，空槽位加一	</span></span><br><span class="line">	return item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>csapp</category>
      </categories>
      <tags>
        <tag>Linux C/C++</tag>
        <tag>网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title>求组合数</title>
    <url>/2019/11/08/%E6%B1%82%E7%BB%84%E5%90%88%E6%95%B0/</url>
    <content><![CDATA[<p>简介： 求组合数的几种方法</p>
<a id="more"></a>
<h1 id="递推公式"><a href="#递推公式" class="headerlink" title="递推公式"></a>递推公式</h1><p>&emsp;&emsp;组合数(n中取m)的递推公式C(n,m)=C(n-1,m-1)+C(n-1,m)</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">void</span> unit()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>; i&lt;N; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> j=<span class="number">0</span>; j&lt;=i; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="number">0</span>==j)    s[i][j]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> s[i][j]=(s[i<span class="number">-1</span>][j]+s[i<span class="number">-1</span>][j<span class="number">-1</span>])%maxn;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="comment">//递推公式</span></span><br></pre></td></tr></table></figure>
<h1 id="逆元–求出阶乘"><a href="#逆元–求出阶乘" class="headerlink" title="逆元–求出阶乘"></a>逆元–求出阶乘</h1><ul>
<li>扩展欧几里得</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> n,a,b;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> fa[<span class="number">100010</span>],fb[<span class="number">100010</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exgcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> &amp;x, <span class="keyword">int</span> &amp;y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(b==<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		x=<span class="number">1</span>,y=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	exgcd(b,a%b,y,x);</span><br><span class="line">	y-=(a/b)*x%maxn;</span><br><span class="line">	<span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">	fa[<span class="number">0</span>]=fb[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;<span class="number">100010</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> x=<span class="number">0</span>,y=<span class="number">0</span>;</span><br><span class="line">		fa[i]=fa[i<span class="number">-1</span>]*i%maxn;</span><br><span class="line">		exgcd(i, maxn, x, y);</span><br><span class="line">		fb[i]=fb[i<span class="number">-1</span>]*(x%maxn+maxn)%maxn; <span class="comment">//此时可能逆元为负</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(n--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;fa[a]*fb[a-b]%maxn*fb[b]%maxn&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>费马小定理</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> n,a,b;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> fa[<span class="number">100010</span>],fb[<span class="number">100010</span>];</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">fuck</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a, <span class="keyword">long</span> <span class="keyword">long</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> res=<span class="number">1</span>,t=a;;</span><br><span class="line">    <span class="keyword">while</span>(b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>) res=res*t%maxn;</span><br><span class="line">        t=t*t%maxn;</span><br><span class="line">        b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exgcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> &amp;x, <span class="keyword">int</span> &amp;y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">	fa[<span class="number">0</span>]=fb[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;<span class="number">100010</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		fa[i]=fa[i<span class="number">-1</span>]*i%maxn;</span><br><span class="line">		<span class="keyword">long</span> <span class="keyword">long</span> x=fuck(i, maxn<span class="number">-2</span>);</span><br><span class="line">		fb[i]=fb[i<span class="number">-1</span>]*(x%maxn+maxn)%maxn;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(n--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;fa[a]*fb[a-b]%maxn*fb[b]%maxn&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="累乘法"><a href="#累乘法" class="headerlink" title="累乘法"></a>累乘法</h1><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">LL C(LL a, LL b, LL p)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(b&gt;a)	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	LL res=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(int <span class="built_in">i</span>=<span class="number">1</span>, <span class="built_in">j</span>=a; <span class="built_in">i</span>&lt;=b; <span class="built_in">i</span>++,<span class="built_in">j</span>--)</span><br><span class="line">	&#123;</span><br><span class="line">		res=res*<span class="built_in">j</span><span class="comment">%p;   //a - a-b+1</span></span><br><span class="line">		res=res*qmi(<span class="built_in">i</span>,p<span class="number">-2</span>,p)<span class="comment">%p;  // b!  (快速幂求逆元)</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法笔记</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>数论知识</title>
    <url>/2019/11/08/%E6%95%B0%E8%AE%BA%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<p>简介： 一些常见的数论问题</p>
<a id="more"></a>
<h1 id="线性筛法求素数"><a href="#线性筛法求素数" class="headerlink" title="线性筛法求素数"></a>线性筛法求素数</h1><p>&emsp;&emsp;每次都用其最小质因子筛，如果不是素数，就把它筛去</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">线性筛法求素数 </span><br><span class="line"><span class="built_in">int</span> primes[N], cnt;     <span class="comment">// primes[]存储所有素数</span></span><br><span class="line"><span class="built_in">bool</span> st[N];         <span class="comment">// st[x]存储x是否被筛掉</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">void</span> get_primes(<span class="built_in">int</span> n)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">2</span>; i &lt;= n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!st[i]) primes[cnt ++ ] = i;   <span class="comment">//当前i没有被筛过 </span></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> j = <span class="number">0</span>; primes[j] &lt;= n / i; j ++ )   <span class="comment">//枚举所有质数 </span></span><br><span class="line">        &#123;</span><br><span class="line">            st[primes[j] * i] = <span class="literal">true</span>;   <span class="comment">//用最小质因子筛，等于true就不会加入队列 </span></span><br><span class="line">            <span class="keyword">if</span> (i % primes[j] == <span class="number">0</span>) <span class="keyword">break</span>;  <span class="comment">//primers[j]是i的最小质因子，退出</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="欧几里得算法-求最大公约数"><a href="#欧几里得算法-求最大公约数" class="headerlink" title="欧几里得算法-求最大公约数"></a>欧几里得算法-求最大公约数</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">欧几里得算法 </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b ? gcd(b, a % b) : a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="欧拉函数"><a href="#欧拉函数" class="headerlink" title="欧拉函数"></a>欧拉函数</h1><p>&emsp;&emsp;欧拉函数表示1-N中与N互质的数的个数</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">结论： P(N)表示 <span class="number">1</span> ~ N 中与 N互质的数的个数</span><br><span class="line">N=p1^a1×p2^a2×……×pn^an   <span class="comment">//分解质因数 </span></span><br><span class="line">P(N)=N(<span class="number">1</span><span class="number">-1</span>/p1)(<span class="number">1</span><span class="number">-1</span>/p2)……(<span class="number">1</span><span class="number">-1</span>/pn)</span><br></pre></td></tr></table></figure>
<p>主要代码</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> phi(<span class="built_in">int</span> x)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> res = x;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">2</span>; i &lt;= x / i; i ++ )</span><br><span class="line">        <span class="keyword">if</span> (x % i == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            res = res / i * (i - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">while</span> (x % i == <span class="number">0</span>) x /= i;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">if</span> (x &gt; <span class="number">1</span>) res = res / x * (x - <span class="number">1</span>);   <span class="comment">//最后x如果不等于1，说明现在它是原来x的一个质因数 </span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="线性筛法求欧拉函数"><a href="#线性筛法求欧拉函数" class="headerlink" title="线性筛法求欧拉函数"></a>线性筛法求欧拉函数</h1><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> primes[N], cnt;     <span class="comment">// primes[]存储所有素数</span></span><br><span class="line"><span class="built_in">int</span> euler[N];           <span class="comment">// 存储每个数的欧拉函数</span></span><br><span class="line"><span class="built_in">bool</span> st[N];         <span class="comment">// st[x]存储x是否被筛掉</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">void</span> get_eulers(<span class="built_in">int</span> n)</span><br><span class="line">&#123;</span><br><span class="line">    euler[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">2</span>; i &lt;= n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!st[i])</span><br><span class="line">        &#123;</span><br><span class="line">            primes[cnt ++ ] = i;</span><br><span class="line">            euler[i] = i - <span class="number">1</span>;   <span class="comment">//一个数是质数，其欧拉函数值为i-1 ，因为前面i-1个数都与他互质 </span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> j = <span class="number">0</span>; primes[j] &lt;= n / i; j ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">int</span> t = primes[j] * i;</span><br><span class="line">            st[t] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % primes[j] == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                euler[t] = euler[i] * primes[j];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            euler[t] = euler[i] * (primes[j] - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="费马小定理"><a href="#费马小定理" class="headerlink" title="费马小定理"></a>费马小定理</h1><p>&emsp;&emsp;马小定理(Fermat’s little theorem)是数论中的一个重要定理，在1636年提出。如果p是一个质数，而整数a不是p的倍数，则有<code>a^（p-1）≡1（mod p）</code></p>
<h1 id="扩展的欧几里得算法"><a href="#扩展的欧几里得算法" class="headerlink" title="扩展的欧几里得算法"></a>扩展的欧几里得算法</h1><p>&emsp;&emsp;如果a、b是整数，那么一定存在整数x、y使得ax+by=gcd(a,b)<br><img src="https://s2.ax1x.com/2019/11/08/MZYagP.jpg" alt=""></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 求x, y，使得ax + by = gcd(a, b)</span></span><br><span class="line"><span class="built_in">int</span> exgcd(<span class="built_in">int</span> a, <span class="built_in">int</span> b, <span class="built_in">int</span> &amp;x, <span class="built_in">int</span> &amp;y)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!b)</span><br><span class="line">    &#123;</span><br><span class="line">        x = <span class="number">1</span>; y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">int</span> d = exgcd(b, a % b, y, x);  <span class="comment">//倒过来写 </span></span><br><span class="line">    y -= (a/b) * x;</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">		exgcd(b,a%b,x,y);</span></span><br><span class="line"><span class="comment">	    int temp=x;</span></span><br><span class="line"><span class="comment">	    x=y;</span></span><br><span class="line"><span class="comment">	    y=temp-(a/b)*y;</span></span><br><span class="line"><span class="comment">	*/</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="逆元"><a href="#逆元" class="headerlink" title="逆元"></a>逆元</h1><p>&emsp;&emsp;若a*x≡1(mod b),且a与b互质，我们定义x是a的逆元，记为a^(-1)，所以也可以说x是a在mod b意义下的倒数</p>
<h2 id="扩展的欧几里得算法求"><a href="#扩展的欧几里得算法求" class="headerlink" title="扩展的欧几里得算法求"></a>扩展的欧几里得算法求</h2><figure class="highlight gml"><table><tr><td class="code"><pre><span class="line">void exgcd(LL a, LL b, LL &amp;<span class="symbol">x</span>, LL &amp;<span class="symbol">y</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keywords">if</span>(b==<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="symbol">x</span>=<span class="number">1</span>;<span class="symbol">y</span>=<span class="number">0</span>;</span><br><span class="line">		<span class="keywords">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	exgcd(b,a%b,<span class="symbol">x</span>,<span class="symbol">y</span>);</span><br><span class="line">	int temp=<span class="symbol">x</span>;</span><br><span class="line">	<span class="symbol">x</span>=<span class="symbol">y</span>%<span class="keywords">mod</span>;</span><br><span class="line">	<span class="symbol">y</span>=(temp-(a/b)*<span class="symbol">y</span>)%<span class="keywords">mod</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="费马小定理求"><a href="#费马小定理求" class="headerlink" title="费马小定理求"></a>费马小定理求</h2><p>&emsp;&emsp;用快速幂求p的mod-2次方即为逆元</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">fuck</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a, <span class="keyword">long</span> <span class="keyword">long</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> res=<span class="number">1</span>,t=a;;</span><br><span class="line">    <span class="keyword">while</span>(b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>) res=res*t%maxn;</span><br><span class="line">        t=t*t%maxn;</span><br><span class="line">        b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法笔记</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>哈希表</title>
    <url>/2019/11/07/%E5%93%88%E5%B8%8C%E8%A1%A8/</url>
    <content><![CDATA[<p>简介： 如何建立哈希表 &amp; 如何解决冲突</p>
<a id="more"></a>
<p>&emsp;&emsp;哈希表：是根据关键码值(Key value)而直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表。</p>
<h1 id="拉链法"><a href="#拉链法" class="headerlink" title="拉链法"></a>拉链法</h1><p>&emsp;&emsp;把所有对maxn取模相等的数存在一起</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//stl</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; vi(<span class="number">100010</span>);   <span class="comment">//定义100010个空间，值不确定</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> x)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> k=(x%maxn+maxn)%maxn;      <span class="comment">//如 10%3=-1 </span></span><br><span class="line">	vi[k].push_back(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//数组模拟</span></span><br><span class="line"><span class="keyword">int</span> ans[maxn],e[maxn],ne[maxn],idx;</span><br><span class="line"><span class="keyword">int</span> n,x;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> x)</span>   <span class="comment">//头插法</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> k=(x%maxn+maxn)%maxn;      <span class="comment">//如 10%3=-1 </span></span><br><span class="line">	e[idx]=x;</span><br><span class="line">	ne[idx]=ans[k];</span><br><span class="line">	ans[k]=idx++;            <span class="comment">//ans[k]为head </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> k=(x%maxn + maxn) % maxn;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=ans[k]; i!=<span class="number">-1</span>; i=ne[i])  <span class="comment">//从前往后找next</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(e[i]==x)	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//需要在main中	//fill(ans, ans+maxn, -1);    //初始化为-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">string</span> s;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">	fill(ans, ans+maxn, <span class="number">-1</span>);        <span class="comment">//初始化为-1 </span></span><br><span class="line">	<span class="keyword">while</span>(n--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;s&gt;&gt;x;</span><br><span class="line">		<span class="keyword">if</span>(s==<span class="string">"I"</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			insert(x);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(find(x))	<span class="built_in">cout</span>&lt;&lt;<span class="string">"Yes"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">			<span class="keyword">else</span>	<span class="built_in">cout</span>&lt;&lt;<span class="string">"No"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="开放寻址法"><a href="#开放寻址法" class="headerlink" title="开放寻址法"></a>开放寻址法</h1><p>&emsp;&emsp;不断向后找坑位，找到就占住</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">200010</span>,N=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> ans[maxn],e[maxn],ne[maxn],idx;</span><br><span class="line"><span class="keyword">int</span> n,x;</span><br></pre></td></tr></table></figure>
<p>核心代码：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> find(<span class="built_in">int</span> x)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">int</span> k=(x%maxn + maxn) % maxn;</span><br><span class="line">	<span class="keyword">while</span>(ans[k]!=N &amp;&amp; ans[k]!=x)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//找下一个坑</span></span><br><span class="line">		k++;</span><br><span class="line">		<span class="keyword">if</span>(k==maxn)	k=<span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> x;       <span class="comment">//若没插入，则返回插入位置</span></span><br><span class="line">	                <span class="comment">//若插入了，返回数所在的位置 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">string</span> s;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">	<span class="comment">//fill(ans, ans+maxn, -1);        //初始化为-1 </span></span><br><span class="line">	<span class="built_in">memset</span>(ans,<span class="number">0x3f</span>,<span class="keyword">sizeof</span>(ans)); <span class="comment">//按字节 </span></span><br><span class="line">	<span class="keyword">while</span>(n--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;s&gt;&gt;x;</span><br><span class="line">		<span class="keyword">if</span>(s==<span class="string">"I"</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> k=find(x);</span><br><span class="line">			ans[k]=x;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> k=find(x);</span><br><span class="line">			<span class="keyword">if</span>(ans[k]!=null)	<span class="built_in">cout</span>&lt;&lt;<span class="string">"Yes"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">			<span class="keyword">else</span>	<span class="built_in">cout</span>&lt;&lt;<span class="string">"No"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法笔记</category>
      </categories>
  </entry>
  <entry>
    <title>并查集</title>
    <url>/2019/11/07/%E5%B9%B6%E6%9F%A5%E9%9B%86/</url>
    <content><![CDATA[<p>简介： 并查集算法</p>
<a id="more"></a>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">100010</span>;</span><br><span class="line"><span class="keyword">int</span> father[maxn];</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findfather</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//路径压缩 	</span></span><br><span class="line">	<span class="keyword">if</span>(x!=father[x])	father[x]=findfather(father[x]);     <span class="comment">//如果找到根节点，则返回根节点编号x </span></span><br><span class="line">	<span class="keyword">return</span> father[x];  <span class="comment">//否则，递归判断x的父节点是否是根节点 ,不能写成x，因为递归退回来的时候x仍然是1，2，3，4，5，。。。。。 并且不能写else return </span></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">		int a=x;</span></span><br><span class="line"><span class="comment">		//寻找根节点 </span></span><br><span class="line"><span class="comment">		while(x!=father[x])	x=father[x];</span></span><br><span class="line"><span class="comment">		//此时x为根节点，要把路径上所有节点的father改为x</span></span><br><span class="line"><span class="comment">		while(a!=father[a])</span></span><br><span class="line"><span class="comment">		&#123;</span></span><br><span class="line"><span class="comment">			int z=a;</span></span><br><span class="line"><span class="comment">			a=father[a];</span></span><br><span class="line"><span class="comment">			father[z]=x;</span></span><br><span class="line"><span class="comment">		&#125;</span></span><br><span class="line"><span class="comment">		return x;</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		father[i]=i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(m--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">char</span> op[<span class="number">2</span>];</span><br><span class="line">		<span class="keyword">int</span> a,b;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;op&gt;&gt;a&gt;&gt;b;</span><br><span class="line">		<span class="keyword">if</span>(op[<span class="number">0</span>]==<span class="string">'M'</span>)	father[findfather(a)]=findfather(b);          <span class="comment">//a的父亲节点是b </span></span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(findfather(a)==findfather(b))	<span class="built_in">cout</span>&lt;&lt;<span class="string">"YES"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">			<span class="keyword">else</span>	<span class="built_in">cout</span>&lt;&lt;<span class="string">"NO"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		 &#125; </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过路径压缩，能快速把节点的father全部设为其祖先</p>
]]></content>
      <categories>
        <category>算法笔记</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>最小生成树</title>
    <url>/2019/11/07/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/</url>
    <content><![CDATA[<p>简介： prim &amp; krusakl</p>
<a id="more"></a>
<h1 id="prim算法"><a href="#prim算法" class="headerlink" title="prim算法"></a>prim算法</h1><p>&emsp;&emsp;prim算法基于贪心，与Dijkstra算法类似，其时间复杂度为O(nlogn)，适合于稠密图。过程可以形象的表示为让一颗小树慢慢长大。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//------邻接矩阵---</span></span><br><span class="line"><span class="comment">//在main函数中要将G初始化为INF </span></span><br><span class="line"><span class="built_in">int</span> n,G[maxn][maxn],dis[maxn];       <span class="comment">//顶点与集合s的最短距离</span></span><br><span class="line"><span class="built_in">bool</span> vis[maxn];</span><br><span class="line"><span class="built_in">int</span> prim()</span><br><span class="line">&#123;</span><br><span class="line">	fill(dis, dis+manx, INF);</span><br><span class="line">	dis[<span class="number">1</span>]=<span class="number">0</span>         <span class="comment">//表示与集合s的最小距离 </span></span><br><span class="line">	<span class="built_in">int</span> ans=<span class="number">0</span>;                <span class="comment">//存储最小生成树边权之和</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">int</span> u=<span class="number">-1</span>,mi=INF;</span><br><span class="line">		<span class="keyword">for</span>(<span class="built_in">int</span> j=<span class="number">0</span>; j&lt;n; j++)  <span class="comment">//找到未访问节点中dis[]最小的 </span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(vis[j]==<span class="literal">false</span> &amp;&amp; dis[j]&lt;mi)</span><br><span class="line">			&#123;</span><br><span class="line">				u=j,mi=dis[j];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(u==<span class="number">-1</span>)	<span class="keyword">return</span> <span class="number">-1</span>;          <span class="comment">//找不到小于INF的d[u]，说明剩下的点与集合s不连通</span></span><br><span class="line">		vis[u]=<span class="literal">true</span>;</span><br><span class="line">		ans+=dis[u];</span><br><span class="line">		<span class="keyword">for</span>(<span class="built_in">int</span> v=<span class="number">1</span>; v&lt;=n; v++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(vis[v]==<span class="literal">false</span> &amp;&amp; G[u][v]!=INF &amp;&amp; G[u][v]&lt;d[v])	dis[v]=G[u][v];</span><br><span class="line">		 &#125; </span><br><span class="line">	 &#125; </span><br><span class="line">	 <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="kruskal算法"><a href="#kruskal算法" class="headerlink" title="kruskal算法"></a>kruskal算法</h1><p>&emsp;&emsp;kruskal算法时间复杂度为O(ElogE)，适用于稀疏图。其思想是每次找出最短的那条边连到生成树集合中。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">struct node</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">int</span> x,y,cost;</span><br><span class="line">	<span class="built_in">bool</span> operator&lt;(node &amp;s) <span class="keyword">const</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> cost&lt;s.cost;</span><br><span class="line">	&#125; </span><br><span class="line">&#125;E[maxn];</span><br><span class="line"><span class="built_in">int</span> krusakl(<span class="built_in">int</span> n, <span class="built_in">int</span> m)     <span class="comment">//n为顶点，m为边 </span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">int</span> ans=<span class="number">0</span>,num_edge=<span class="number">0</span>;       <span class="comment">//num_edge表示当前生成树的边数</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		fataher[i]=i;        <span class="comment">//初始化并查集 </span></span><br><span class="line">	 &#125; </span><br><span class="line">	 sort(E, E+m);         <span class="comment">//按边权从小到大排序</span></span><br><span class="line">	 <span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>; i&lt;m; i++)			<span class="comment">//枚举的是所有的边 </span></span><br><span class="line">	 &#123;</span><br><span class="line">	 	<span class="built_in">int</span> faU=findfather(E[i].u);         <span class="comment">//查询测试边两个端点所在集合的根节点</span></span><br><span class="line">		<span class="built_in">int</span> faV=findfather(E[i].v);</span><br><span class="line">		<span class="keyword">if</span>(faU!=faV)</span><br><span class="line">		&#123;</span><br><span class="line">			father[faU]=faV;     <span class="comment">//合并集合，把测试边加入到最小生成树中 </span></span><br><span class="line">			ans+=E[i].cost;</span><br><span class="line">			num_edge++;</span><br><span class="line">			<span class="keyword">if</span>(num_edge==n<span class="number">-1</span>)	<span class="keyword">break</span>; </span><br><span class="line">		 &#125; </span><br><span class="line">	  &#125; </span><br><span class="line">	  <span class="keyword">if</span>(num_edge!=n<span class="number">-1</span>)	<span class="keyword">return</span> INF;</span><br><span class="line">	  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法笔记</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>快速幂</title>
    <url>/2019/11/07/%E5%BF%AB%E9%80%9F%E5%B9%82/</url>
    <content><![CDATA[<p>简介： 快速幂求n次方</p>
<a id="more"></a>
<p>快速幂的基本思想是把n次看成一个二进制数，每次取末尾的1，其时间复杂度为log2(n)</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">求 m^k mod p，时间复杂度 O(logk)。</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> qmi(<span class="built_in">int</span> m, <span class="built_in">int</span> k, <span class="built_in">int</span> p)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> res = <span class="number">1</span>, t = m;</span><br><span class="line">    <span class="keyword">while</span> (k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (k&amp;<span class="number">1</span>) res = res * t % p;  <span class="comment">//若此位为1，则相乘 </span></span><br><span class="line">        t = t * t % p;   <span class="comment">//每次都要算乘积 </span></span><br><span class="line">        k &gt;&gt;= <span class="number">1</span>;   <span class="comment">//丢弃算完的这一位 </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法笔记</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树</title>
    <url>/2019/11/07/%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<p>简介： 二叉树的一些基本操作</p>
<a id="more"></a>
<h1 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h1><figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">struct <span class="keyword">node</span><span class="title"></span></span><br><span class="line"><span class="title">&#123;</span></span><br><span class="line"><span class="title">	int</span> x;</span><br><span class="line">	<span class="keyword">node</span> <span class="title">*lchild</span>,*rchild;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="新建节点"><a href="#新建节点" class="headerlink" title="新建节点"></a>新建节点</h1><figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Node</span> <span class="title">*newNode</span>(int x)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">node</span> <span class="title">*Noot</span>=new <span class="keyword">node</span><span class="title">;</span></span><br><span class="line"><span class="title">	Node-</span>&gt;<span class="attr">lchild=</span><span class="keyword">Node</span><span class="title">-&gt;rchild</span>=nullptr;</span><br><span class="line">	<span class="keyword">Node</span><span class="title">-&gt;data</span>=x;</span><br><span class="line">	return <span class="keyword">Node</span><span class="title">;</span></span><br><span class="line"><span class="title">&#125;</span></span><br></pre></td></tr></table></figure>
<h1 id="插入节点"><a href="#插入节点" class="headerlink" title="插入节点"></a>插入节点</h1><figure class="highlight xquery"><table><tr><td class="code"><pre><span class="line">void <span class="keyword">insert</span>(<span class="type">node</span> *<span class="built_in">&amp;root</span>, int x)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span><span class="built_in">(root</span>==nullptr)</span><br><span class="line">	&#123;</span><br><span class="line">	<span class="built_in">	root</span>=newNode(x);</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(x&lt;<span class="built_in">=root</span>-&gt;data)	<span class="keyword">insert</span><span class="built_in">(root</span>-&gt;lchild, x);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">insert</span><span class="built_in">(root</span>-&gt;rchild, x);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h1 id="建树"><a href="#建树" class="headerlink" title="建树"></a>建树</h1><figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line"><span class="keyword">node</span> <span class="title">*creat</span>(int data[], int n)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">node</span> <span class="title">*root</span>=nullptr;</span><br><span class="line">	for(int i=<span class="number">0</span>; i<span class="tag">&lt;n; i++)</span></span><br><span class="line"><span class="tag">	&#123;</span></span><br><span class="line"><span class="tag">		insert(root, data[i]);</span></span><br><span class="line"><span class="tag">	&#125;</span></span><br><span class="line"><span class="tag">	return root;</span></span><br><span class="line"><span class="tag">&#125;</span></span><br></pre></td></tr></table></figure>

<h1 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h1><figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line">void research(node *root, int x, int <span class="keyword">new</span><span class="type">data</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(root==nullptr)	<span class="keyword">return</span> ;  <span class="comment">//找不到</span></span><br><span class="line">	<span class="keyword">if</span>(root-&gt;data==x)	root-&gt;data=<span class="keyword">new</span><span class="type">data</span>;</span><br><span class="line">	research(root-&gt;lchild, x, <span class="keyword">new</span><span class="type">data</span>);      <span class="comment">//递归查找 </span></span><br><span class="line">	research(root-&gt;rchild, x, <span class="keyword">new</span><span class="type">data</span>); </span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法笔记</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>线程同步</title>
    <url>/2019/11/07/%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5/</url>
    <content><![CDATA[<p>简介： 如何解决线程的同步问题</p>
<a id="more"></a>
<h1 id="共享变量"><a href="#共享变量" class="headerlink" title="共享变量"></a>共享变量</h1><p>&emsp;&emsp;一个变量v是<strong>同步</strong>的，当且仅当它的一个实例被一个以上的线程引用。<br>&emsp;&emsp;每个线程都有它自己独立的上下文，包括<strong>线程ID、栈、栈指针、PC、条件码和通用目的寄存器值</strong>。每个线程和其他线程共享进程上下文的剩余部分，这包括整个用户虚拟地址空间，它是由制度文本（代码）、读/写数据、堆以及所有的共享库代码和数据区域组成的。在实际的线程内存模型中，寄存器的值虽然是隔离且被保护的，但是在栈中的值并不是这样的（其他线程也可以访问）。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> **ptr;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thread</span><span class="params">(<span class="keyword">void</span> *vargp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> myid=(<span class="keyword">int</span>)vargp;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"[%d]: %s (cnt=%d)\n"</span>, myid, ptr[myid], ++cnt);   <span class="comment">//每个线程都可以访问全局变量 </span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">pthread_t</span> tid;</span><br><span class="line">	<span class="keyword">char</span>* msgs[N]=</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="string">"hello from foo"</span>,</span><br><span class="line">		<span class="string">"hello from bar"</span>	</span><br><span class="line">	&#125;;</span><br><span class="line">	</span><br><span class="line">	ptr = msgs;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;N; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		pthread_create(&amp;tid, <span class="literal">NULL</span>, thread, (<span class="keyword">void</span> *)i);</span><br><span class="line">	&#125;</span><br><span class="line">	pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="用信号量同步线程"><a href="#用信号量同步线程" class="headerlink" title="用信号量同步线程"></a>用信号量同步线程</h1><h2 id="同步不正确的计数器程序"><a href="#同步不正确的计数器程序" class="headerlink" title="同步不正确的计数器程序"></a>同步不正确的计数器程序</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">long</span> cnt=<span class="number">0</span>; <span class="comment">//系统总是重新从它所在的内存读取数据，即使它前面的指令刚刚从该处读取过数据。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thread</span><span class="params">(<span class="keyword">void</span> *vargp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">long</span> i, niters=*((<span class="keyword">long</span> *)vargp);</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;niters; i++)	cnt++;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">long</span> niters=<span class="number">1000000</span>;</span><br><span class="line">	<span class="keyword">pthread_t</span> tid1, tid2;</span><br><span class="line"><span class="comment">//	if(argc != 2)</span></span><br><span class="line"><span class="comment">//	&#123;</span></span><br><span class="line"><span class="comment">//		fprintf(stderr, "usage: %s &lt;niters&gt;\n", argv[0]);</span></span><br><span class="line"><span class="comment">//		return 0;</span></span><br><span class="line"><span class="comment">//	&#125;</span></span><br><span class="line"><span class="comment">//	niters=atoi(argv[1]);   //把字符串转换为整形数,参数为const char *,C++使用时需调用.c_str()</span></span><br><span class="line">	<span class="comment">// 创建一个线程并且等待它们终止</span></span><br><span class="line">	pthread_create(&amp;tid1, <span class="literal">NULL</span>, thread, &amp;niters); </span><br><span class="line">	pthread_create(&amp;tid2, <span class="literal">NULL</span>, thread, &amp;niters);</span><br><span class="line">	pthread_join(tid1, <span class="literal">NULL</span>);</span><br><span class="line">	pthread_join(tid2, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="comment">//检查结果</span></span><br><span class="line">	<span class="keyword">if</span>(cnt != (<span class="number">2</span>*niters))	<span class="built_in">printf</span>(<span class="string">"BOOM! cnt=%ld\n"</span>, cnt);</span><br><span class="line">	<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"OK cnt=%ld\n"</span>, cnt);</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>); </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;运行结果为：<br><img src="https://s2.ax1x.com/2019/11/07/MkaTzV.png" alt=""><br>&emsp;&emsp;可见结果并不像预期的一样时2*niters，这是因为我们没有办法预测操作系统是否将为你的线程选择一个正确的顺序。<br>&emsp;&emsp;汇编代码为：<br><img src="https://s2.ax1x.com/2019/11/07/MkwTDU.png" alt=""><br>&emsp;&emsp;比如按如下指令顺序次序执行，会得到一个错误的值：<br><img src="https://s2.ax1x.com/2019/11/07/Mk03Ps.png" alt=""><br>关于volatile关键字可以参考：<a href="https://blog.csdn.net/ijn842/article/details/81273232" target="_blank" rel="noopener">https://blog.csdn.net/ijn842/article/details/81273232</a></p>
<h3 id="临界区（critical-section）"><a href="#临界区（critical-section）" class="headerlink" title="临界区（critical section）"></a>临界区（critical section）</h3><p>&emsp;&emsp;操作共享变量cnt内容的指令（L，U，S）构成了一个（关于共享变量cnt）的<strong>临界区</strong>，这个临界区不应该和其他线程的临界区交替执行。如果我们想要<strong>拥有对共享变量的互斥访问</strong>，就必须确保每个线程在执行它的临界区的指令时不和其他线程的临界区交替执行。</p>
<h2 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h2><p>&emsp;&emsp;可以利用PV操作来解决临界区问题。</p>
<ul>
<li>P( <strong>s</strong> ): 如果s不为0，那么P将s减1，并且立即返回。如果s为0，那么就挂起这个线程，直到s变为非0，而一个V操作会重启这个线程。</li>
<li>V( <strong>s</strong> ): V操作将s加1。如果有线程阻塞在P操作等待s变为非0，那么V操作会重启这些线程中的一个。V唯一的要求就是必须重启一个正在等待的线程，所有<strong>当多个线程在等待同一信号量时，不能预测V操作要重启哪一个线程</strong>。<br>&emsp;&emsp;PV操作保证了一个程序不可能有一个负值信号量，这个属性称为<strong>信号量不变性</strong>。</li>
</ul>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">#<span class="keyword">include</span> &lt;semaphore.h&gt;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> sem<span class="constructor">_init(<span class="params">sem_t</span> <span class="operator">*</span><span class="params">sem</span>, 0, <span class="params">unsigned</span> <span class="params">int</span> <span class="params">value</span>)</span>;</span><br><span class="line"><span class="comment">//将信号量sem初始化为value</span></span><br><span class="line"><span class="comment">//第二个参数不为0时此信号量在进程间共享，否则只能为当前进程的所有线程共享</span></span><br><span class="line"><span class="built_in">int</span> sem<span class="constructor">_wait(<span class="params">sem_t</span> <span class="operator">*</span><span class="params">s</span>)</span>    <span class="comment">//P(s)</span></span><br><span class="line"><span class="built_in">int</span> sem<span class="constructor">_post(<span class="params">sem_t</span> <span class="operator">*</span><span class="params">s</span>)</span>    <span class="comment">//V(s)</span></span><br></pre></td></tr></table></figure>

<h2 id="同步正确的计数器程序"><a href="#同步正确的计数器程序" class="headerlink" title="同步正确的计数器程序"></a>同步正确的计数器程序</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;semaphore.h&gt; </span></span></span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">long</span> cnt=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">sem_t</span> mutex;      <span class="comment">//申请互斥变量 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">P</span><span class="params">(<span class="keyword">sem_t</span> *s)</span>    <span class="comment">//P操作 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(sem_wait(s)&lt;<span class="number">0</span>)	 <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"sem_wait error: %s\n"</span>, strerror(errno)),<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">V</span><span class="params">(<span class="keyword">sem_t</span> *s)</span>   <span class="comment">//V操作 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(sem_post(s)&lt;<span class="number">0</span>)	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"sem_post error: %s\n"</span>, strerror(errno)),<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thread</span><span class="params">(<span class="keyword">void</span> *vargp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">long</span> niters=(*(<span class="keyword">long</span> *)vargp);</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;niters; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		P(&amp;mutex);        <span class="comment">//进行pv操作， 保护临界区 </span></span><br><span class="line">		cnt++;</span><br><span class="line">		V(&amp;mutex);</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">long</span> niters=<span class="number">1000</span>;</span><br><span class="line">	<span class="keyword">pthread_t</span> tid1,tid2;</span><br><span class="line">	sem_init(&amp;mutex, <span class="number">0</span>, <span class="number">1</span>);   <span class="comment">//将mutex初始化为1 </span></span><br><span class="line">	pthread_create(&amp;tid1, <span class="literal">NULL</span>, thread, &amp;niters);	</span><br><span class="line">	pthread_create(&amp;tid2, <span class="literal">NULL</span>, thread, &amp;niters);	</span><br><span class="line">	pthread_join(tid1, <span class="literal">NULL</span>);</span><br><span class="line">	pthread_join(tid2, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span>(cnt != (<span class="number">2</span>*niters))	<span class="built_in">printf</span>(<span class="string">"BOOM! cnt=%ld\n"</span>, cnt);</span><br><span class="line">	<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"OK cnt=%ld\n"</span>, cnt);</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;利用PV操作，可以做到互斥访问临界区，所以能得到正确的结果</p>
<h2 id="生产者-消费者问题"><a href="#生产者-消费者问题" class="headerlink" title="生产者-消费者问题"></a>生产者-消费者问题</h2><p>&emsp;&emsp;生产者和消费者线程共享一个有n个槽的有限缓冲区。生产者线程反复生成新的项目，并把它们插入到缓冲区中，消费者线程不断地从缓冲区中取出这些项目，然后消费它们。<br><img src="https://s2.ax1x.com/2019/11/08/MZcnXQ.png" alt=""><br>&emsp;&emsp;因为插入和消费都涉及更新共享变量，所以我们必须保证对缓冲区的访问时互斥的。</p>
<p><strong>结构体</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> *buf;      <span class="comment">//buf数组</span></span><br><span class="line">	<span class="keyword">int</span> n;         <span class="comment">//槽位的最大值</span></span><br><span class="line">	<span class="keyword">int</span> front;     <span class="comment">//buf中的第一个值前面 </span></span><br><span class="line">	<span class="keyword">int</span> rear;      <span class="comment">//buf中的最后一个值</span></span><br><span class="line">	<span class="keyword">sem_t</span> mutex;   <span class="comment">//对buf进行控制的互斥量</span></span><br><span class="line">	<span class="keyword">sem_t</span> slots;   <span class="comment">//统计buf中空槽位数目</span></span><br><span class="line">	<span class="keyword">sem_t</span> items;   <span class="comment">//统计buf中可用项数目 </span></span><br><span class="line">&#125;<span class="keyword">sbuf_t</span>;</span><br></pre></td></tr></table></figure>
<p><strong>初始化结构体</strong></p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">//初始化缓冲区 </span></span><br><span class="line">void sbuf<span class="constructor">_intit(<span class="params">sbuf_t</span> <span class="operator">*</span><span class="params">sp</span>, <span class="params">int</span> <span class="params">n</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	sp-&gt;buf=(<span class="built_in">int</span> *)calloc(n, sizeof(<span class="built_in">int</span>));   <span class="comment">//分配n个 </span></span><br><span class="line">	<span class="comment">//calloc在动态分配完内存后,自动初始化该内存空间为零,而</span></span><br><span class="line">	<span class="comment">//malloc不做初始化,分配到的空间中的数据是随机数据</span></span><br><span class="line">	sp-&gt;n=n;</span><br><span class="line">	sp-&gt;front=sp-&gt;rear=<span class="number">0</span>;</span><br><span class="line">	sem<span class="constructor">_init(&amp;<span class="params">sp</span>-&gt;<span class="params">mutex</span>, 0, 1)</span>;    <span class="comment">//将mutex初始化为1</span></span><br><span class="line">	sem<span class="constructor">_init(&amp;<span class="params">sp</span>-&gt;<span class="params">slots</span>, 0, <span class="params">n</span>)</span>;    <span class="comment">//将空槽位初始化为n</span></span><br><span class="line">	sem<span class="constructor">_init(&amp;<span class="params">sp</span>-&gt;<span class="params">items</span>, 0, 0)</span>;    <span class="comment">//将可用项数目初始化为0 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>释放申请的buf空间</strong></p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">void <span class="keyword">sbuf_deinit(sbuf </span>*<span class="built_in">sp</span>)</span><br><span class="line">&#123;</span><br><span class="line">	free(<span class="built_in">sp</span>-&gt;<span class="keyword">buf);	</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>将一个可用项插入buf</strong></p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">void sbuf<span class="constructor">_insert(<span class="params">sbuf_t</span> <span class="operator">*</span><span class="params">sp</span>, <span class="params">int</span> <span class="params">item</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="constructor">P(&amp;<span class="params">sp</span>-&gt;<span class="params">slots</span>)</span>;  <span class="comment">//将可用槽位的数目减一 </span></span><br><span class="line">	<span class="constructor">P(&amp;<span class="params">sp</span>-&gt;<span class="params">mutex</span>)</span>;  <span class="comment">//加互斥锁 </span></span><br><span class="line">	sp-&gt;buf<span class="literal">[(<span class="operator">++</span><span class="identifier">sp</span>-&gt;<span class="identifier">rear</span>)%(<span class="identifier">sp</span>-&gt;<span class="identifier">n</span>)]</span> = item;     <span class="comment">//当到达buf尾端时，要取模</span></span><br><span class="line">	<span class="constructor">V(&amp;<span class="params">sp</span>-&gt;<span class="params">mutex</span>)</span>;      <span class="comment">//解开互斥锁 </span></span><br><span class="line">	<span class="constructor">V(&amp;<span class="params">sp</span>-&gt;<span class="params">items</span>)</span>;       <span class="comment">//可用项的数目加一 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>从buf中取出一个可用项</strong></p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> sbuf<span class="constructor">_remove(<span class="params">sbuf_t</span> <span class="operator">*</span><span class="params">sp</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">int</span> item;</span><br><span class="line">	<span class="constructor">P(&amp;<span class="params">sp</span>-&gt;<span class="params">items</span>)</span>;      <span class="comment">//取出来以后可用项的数目减一 </span></span><br><span class="line">	<span class="constructor">P(&amp;<span class="params">sp</span>-&gt;<span class="params">mutex</span>)</span>;          <span class="comment">//加互斥锁 </span></span><br><span class="line">	item=sp-&gt;buf<span class="literal">[(<span class="operator">++</span><span class="identifier">sp</span>-&gt;<span class="identifier">front</span>)%(<span class="identifier">sp</span>-&gt;<span class="identifier">n</span>)]</span>;</span><br><span class="line">	<span class="constructor">V(&amp;<span class="params">sp</span>-&gt;<span class="params">mutex</span>)</span>;         <span class="comment">//解开互斥锁 </span></span><br><span class="line">	<span class="constructor">V(&amp;<span class="params">sp</span>-&gt;<span class="params">slots</span>)</span>;        <span class="comment">//取出来，空槽位加一	</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>PV操作</strong></p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">void P(sem_t *s)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(sem_wait(s) &lt; <span class="number">0</span>)	fprintf(stderr, <span class="string">"sem_wait error: %s\n"</span>, strerror(errno)),<span class="keyword">exit</span>(<span class="number">0</span>);</span><br><span class="line"> &#125; </span><br><span class="line">void V(sem_t *s)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(sem_post(s) &lt; <span class="number">0</span>)	fprintf(stderr, <span class="string">"sem_post error: %s\n"</span>, strerror(errno)),<span class="keyword">exit</span>(<span class="number">0</span>);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>csapp</category>
      </categories>
      <tags>
        <tag>Linux C/C++</tag>
        <tag>网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title>字符串哈希</title>
    <url>/2019/11/06/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%93%88%E5%B8%8C/</url>
    <content><![CDATA[<p>简介： 字符串前缀哈希法</p>
<a id="more"></a>
<p>&emsp;&emsp;判断一个字符串两段字符是否相等</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//要人品足够好，保证没有冲突现象发生 </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ULL;		<span class="comment">//溢出相当于取模 </span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">100010</span>,P=<span class="number">131</span>;  <span class="comment">//p=131或者13331为经验值 ,若哈希值特别大，则需要取模，对2^64取模为经验值 </span></span><br><span class="line">ULL p[maxn],h[maxn];</span><br><span class="line"><span class="keyword">char</span> str[maxn];</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="function">ULL <span class="title">get</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span>  <span class="comment">//结果溢出即为取模 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> h[r]-h[l<span class="number">-1</span>]*p[r-l+<span class="number">1</span>];           <span class="comment">//公式	高位|--------l-1----相当于乘10的n次-------r|低位  </span></span><br><span class="line">	<span class="comment">//参数为1-l哈希值，1-r哈希值 </span></span><br><span class="line"> &#125; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m&gt;&gt;str+<span class="number">1</span>;</span><br><span class="line">	p[<span class="number">0</span>]=<span class="number">1</span>;          <span class="comment">//p的0次方等于1 </span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		p[i]=p[i<span class="number">-1</span>]*P;             <span class="comment">//预处理p数组，，用于字符串哈希，相当于p进制 </span></span><br><span class="line">		h[i]=h[i<span class="number">-1</span>]*P + str[i];     <span class="comment">//计算哈希值 ，a*p^0 + b*p^2+..... 并且不断取模 </span></span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">while</span>(m--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> l1,r1,l2,r2;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;l1&gt;&gt;r1&gt;&gt;l2&gt;&gt;r2;</span><br><span class="line">		<span class="keyword">if</span>(get(l1,r1)==get(l2,r2))	<span class="built_in">cout</span>&lt;&lt;<span class="string">"Yes"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="string">"No"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法笔记</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>KMP</title>
    <url>/2019/11/06/KMP/</url>
    <content><![CDATA[<p>简介： KMP算法</p>
<a id="more"></a>
<p>&emsp;&emsp;kmp算法时间复杂度：O(m+n)<br>&emsp;&emsp;在某个字符失配时，该字符对应的next 值会告诉你下一步匹配中，模式串应该跳到哪个位置（跳到next [j] 的位置）。此时不必重新开始匹配。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">10010</span>,M=<span class="number">100010</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">char</span> p[N],s[M];</span><br><span class="line"><span class="keyword">int</span> ne[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;p+<span class="number">1</span>&gt;&gt;m&gt;&gt;s+<span class="number">1</span>;</span><br><span class="line">	<span class="comment">//求next的过程， next[1]=0 找前面子集字符串 	</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>,j=<span class="number">0</span>; i&lt;=n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span>(j &amp;&amp; p[i]!=p[j+<span class="number">1</span>])	j=ne[j];</span><br><span class="line">		<span class="keyword">if</span>(p[i]==p[j+<span class="number">1</span>])	j++;</span><br><span class="line">		ne[i]=j;</span><br><span class="line">	 &#125; </span><br><span class="line">	 </span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,j=<span class="number">0</span>; i&lt;=m; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span>(j &amp;&amp; p[j+<span class="number">1</span>]!=s[i])	j=ne[j];    <span class="comment">//没有匹配上，求next</span></span><br><span class="line">		<span class="keyword">if</span>(s[i]==p[j+<span class="number">1</span>]) j++;      <span class="comment">//这个字符匹配，求下一个</span></span><br><span class="line">		<span class="keyword">if</span>(j==n)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;i-n&lt;&lt;<span class="string">" "</span>;      <span class="comment">//完全匹配上</span></span><br><span class="line">			j=ne[j];           <span class="comment">//求解下一个 </span></span><br><span class="line">		 &#125; </span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法笔记</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>最短路径</title>
    <url>/2019/11/06/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/</url>
    <content><![CDATA[<p>简介： 最短路径算法</p>
<a id="more"></a>
<h1 id="Dijkstra-算法"><a href="#Dijkstra-算法" class="headerlink" title="Dijkstra 算法"></a>Dijkstra 算法</h1><p>&emsp;&emsp;时间复杂度O(n²），适用于稠密图。<br>&emsp;&emsp;示例：<br><img src="https://s2.ax1x.com/2019/11/06/Mi30sI.jpg" alt=""></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="built_in">int</span> maxn=<span class="number">510</span>,INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="built_in">int</span> G[maxn][maxn],dis[maxn];            <span class="comment">//G为矩阵，dis为起点到各个点的最短距离</span></span><br><span class="line"><span class="built_in">bool</span> vis[maxn];</span><br><span class="line"><span class="built_in">void</span> dijkstra(<span class="built_in">int</span> s)      <span class="comment">//s为起点 </span></span><br><span class="line">&#123;</span><br><span class="line">	fill(dis, dis+maxn, INF);             <span class="comment">//将距离初始化为INF，即就是无穷大	</span></span><br><span class="line">	d[s]=<span class="number">0</span>;                <span class="comment">//起点到起点的距离为0</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>; i&lt;n; i++)      <span class="comment">//循环n次 </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">int</span> u=<span class="number">-1</span>,mi=INF;         </span><br><span class="line">		<span class="keyword">for</span>(<span class="built_in">int</span> j=<span class="number">1</span>; j&lt;=n; j++)	<span class="comment">//找到为访问顶点中的d[]最小的 </span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(vis[j]==<span class="literal">false</span> &amp;&amp; d[j]&lt;mi)</span><br><span class="line">			&#123;</span><br><span class="line">				u=j;</span><br><span class="line">				mi=d[j];</span><br><span class="line">			&#125; </span><br><span class="line">		&#125;  </span><br><span class="line">		<span class="keyword">if</span>(u==<span class="number">-1</span>)	<span class="keyword">return</span> ;            <span class="comment">//如果找不到小于MI的d[]，说明剩下的顶点与起点s不连通      </span></span><br><span class="line">		vis[u]=<span class="literal">true</span>;          <span class="comment">//标记为访问过 </span></span><br><span class="line">		<span class="keyword">for</span>(<span class="built_in">int</span> v=<span class="number">1</span>; v&lt;=n; v++)</span><br><span class="line">		&#123;       <span class="comment">//如果v没有访问 &amp;&amp; u能到达v &amp;&amp; 以u为中介点能使d[v] 更优</span></span><br><span class="line">			<span class="keyword">if</span>(vis[v]==<span class="literal">false</span> &amp;&amp; G[u][v]!=INF &amp;&amp; d[v]&gt;d[u]+G[u][v])	d[v]=G[u][v]+d[v];    <span class="comment">//优化		</span></span><br><span class="line">		&#125; </span><br><span class="line">	 &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="堆优化版的Dijkstra算法"><a href="#堆优化版的Dijkstra算法" class="headerlink" title="堆优化版的Dijkstra算法"></a>堆优化版的Dijkstra算法</h1><p>&emsp;&emsp;时间复杂度O((m+n)logn)，适用于稀疏图。利用stl中的优先队列来进行优化。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//--------------堆优化</span></span><br><span class="line"><span class="keyword">using</span> PII = pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dij</span><span class="params">(<span class="keyword">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	fill(dis, dis+maxn, INF);</span><br><span class="line">	dis[s]=<span class="number">0</span>;</span><br><span class="line">	priority_queue&lt;PII, <span class="built_in">vector</span>&lt;PII&gt;, greater&lt;PII&gt;&gt; heap;</span><br><span class="line">	heap.push(&#123;<span class="number">0</span>,s&#125;);         <span class="comment">//s到自己的距离为0   //一定要注意要先写距离再写点，，因为堆排序的时候要用距离作为第一尺度 </span></span><br><span class="line">	<span class="keyword">while</span>(heap.size())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">auto</span> t=heap.top();</span><br><span class="line">		heap.pop();</span><br><span class="line">		<span class="keyword">int</span> u=t.second,w=t.first;        <span class="comment">//取出最小的点和该店到源点的最短距离 </span></span><br><span class="line">		<span class="keyword">if</span>(vis[u]) <span class="keyword">continue</span>;              <span class="comment">//可能存在一些冗余边比如2-&gt;3(2);2-&gt;3(4) 后面的被舍弃 </span></span><br><span class="line">		vis[u]=<span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;adj[u].size(); j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> v=adj[u][j].v;</span><br><span class="line">			<span class="keyword">if</span>(vis[v]==<span class="literal">false</span> &amp;&amp; dis[v]&gt;w+adj[u][j].dis)</span><br><span class="line">			&#123;</span><br><span class="line">				dis[v]=w+adj[u][j].dis;</span><br><span class="line">				heap.push(&#123;dis[v],v&#125;);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; </span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="folyd-算法"><a href="#folyd-算法" class="headerlink" title="folyd 算法"></a>folyd 算法</h1><p>&emsp;&emsp;时间复杂度为O(n³)</p>
<figure class="highlight accesslog"><table><tr><td class="code"><pre><span class="line">void floyd()</span><br><span class="line">&#123;</span><br><span class="line">	for(int k=<span class="number">1</span>; k&lt;=n; k++)       //以k为中介，枚举所有顶点 </span><br><span class="line">	&#123;</span><br><span class="line">		for(int i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			for(int j=<span class="number">1</span>; j&lt;=n; j++)</span><br><span class="line">			&#123;</span><br><span class="line">				if(dis<span class="string">[i]</span><span class="string">[k]</span>!=INF &amp;&amp; dis<span class="string">[k]</span><span class="string">[j]</span>!=INF &amp;&amp; dis<span class="string">[i]</span><span class="string">[k]</span>+dis<span class="string">[k]</span><span class="string">[j]</span>&lt;dis<span class="string">[i]</span><span class="string">[j]</span>)</span><br><span class="line">					dis<span class="string">[i]</span><span class="string">[j]</span>=dis<span class="string">[i]</span><span class="string">[k]</span>+dis<span class="string">[k]</span><span class="string">[j]</span>;               //存的时候要把dis<span class="string">[i]</span><span class="string">[i]</span>设置为<span class="number">0</span>，因为自己到自己的距离为<span class="number">0</span> </span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Bellman-算法"><a href="#Bellman-算法" class="headerlink" title="Bellman 算法"></a>Bellman 算法</h1><p>&emsp;&emsp;时间复杂度为O(nm),适用于权值为负的情况</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">100010</span>,INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> v,dis;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;node&gt; adj[maxn];</span><br><span class="line"><span class="keyword">int</span> m,n,d[maxn],vis[maxn];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Bellman</span><span class="params">(<span class="keyword">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	fill(d,d+maxn,INF);</span><br><span class="line">	d[s]=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n<span class="number">-1</span>; i++)   <span class="comment">//n-1次松弛操作   两个点一条边要一次松弛 </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//copy(dis, dis+maxn, ans); //保证不发生串联 如果不加，可能会用更新后的值依次更新后面的节点 ,此时一次只更新一层 </span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> u=<span class="number">1</span>; u&lt;=n; u++)   <span class="comment">//枚举每一条边 </span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;adj[u].size(); j++)   <span class="comment">//如果以u为中介可以使d[v]变小 </span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">int</span> v=adj[u][j].v;</span><br><span class="line">				<span class="keyword">int</span> dis=adj[u][j].dis;</span><br><span class="line">				<span class="keyword">if</span>(d[u]+dis&lt;d[v])	d[v]=d[u]+dis;     <span class="comment">//松弛操作 </span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//if(dis[n] &gt;INF/2)	return false;     //可能会有一条负权边把n号点更新 </span></span><br><span class="line">	<span class="comment">//return true;</span></span><br><span class="line">	<span class="comment">//判断负环</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> u=<span class="number">1</span>; u&lt;=n; u++)     <span class="comment">//如果还能进行松弛操作 </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;adj[u].size(); j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> v=adj[u][j].v;</span><br><span class="line">			<span class="keyword">int</span> dis=adj[u][j].dis;</span><br><span class="line">			<span class="keyword">if</span>(d[u]+dis&lt;d[v])	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="spfa算法"><a href="#spfa算法" class="headerlink" title="spfa算法"></a>spfa算法</h1><p>&emsp;&emsp;一般情况下时间复杂度为O(m)最坏时间复杂度为O(nm),适用于权值为负的情况。对比Bellman算法，spfa只有在松弛操作后才会入队，同样适用于权值为负的情况。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">100010</span>,INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">bool</span> vis[maxn];</span><br><span class="line"><span class="keyword">int</span> n,dis[maxn],num[maxn];         <span class="comment">//num数组记录顶点的入队次数 </span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">SPFA</span><span class="params">(<span class="keyword">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	fill(dis, dis+maxn, INF); </span><br><span class="line">	dis[s]=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">	q.push(s);        <span class="comment">//源点入队</span></span><br><span class="line">	vis[s]=<span class="literal">true</span>;</span><br><span class="line">	num[s]++; <span class="comment">//入队次数加1</span></span><br><span class="line">	<span class="keyword">while</span>(!q.empty())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">auto</span> u=q.front();</span><br><span class="line">		q.pop();</span><br><span class="line">		vis[u]=<span class="literal">false</span>;          <span class="comment">//设置u不在队列</span></span><br><span class="line">		<span class="comment">//遍历所有邻边</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;adj[u].size(); j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> v=adj[u][j].v;</span><br><span class="line">			<span class="keyword">int</span> d=adj[u][j].dis;</span><br><span class="line">			<span class="keyword">if</span>(dis[u]+d &lt; dis[v])</span><br><span class="line">			&#123;</span><br><span class="line">				dis[v]=dis[u]+d;</span><br><span class="line">				<span class="keyword">if</span>(!vis[v])     <span class="comment">//v不在队列 </span></span><br><span class="line">				&#123;</span><br><span class="line">					q.push(v);   <span class="comment">//有松弛操作才入队 </span></span><br><span class="line">					vis[v]=<span class="literal">true</span>;</span><br><span class="line">					num[v]++;</span><br><span class="line">					<span class="keyword">if</span>(num[v]&gt;=n)	<span class="keyword">return</span> <span class="literal">false</span>;      <span class="comment">//有可达负环 </span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		 &#125; </span><br><span class="line">	 &#125; </span><br><span class="line">	 <span class="keyword">return</span> <span class="literal">true</span>; </span><br><span class="line">	 </span><br><span class="line">		</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法笔记</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>echo服务器-基于线程</title>
    <url>/2019/11/06/echo%E6%9C%8D%E5%8A%A1%E5%99%A8%E2%80%94%E2%80%94%E5%9F%BA%E4%BA%8E%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<p>简介： 基于线程的并发编程</p>
<a id="more"></a>
<h1 id="并行方法"><a href="#并行方法" class="headerlink" title="并行方法"></a>并行方法</h1><p>&emsp;&emsp;前面实现的服务器，一次只能处理一个请求，只有当前的请求处理完了，才能继续处理下一个。<br><img src="https://s2.ax1x.com/2019/11/06/MPrLjK.jpg" alt=""><br>&emsp;&emsp;服务器初始化后listen客户端的connect请求，当客户端向服务器发送connect请求后，服务器accept并且开始等待客户端的输入，客户端 1 write之后转为等待响应(call read)，服务器的read接收到内容之后，发送响应(write) 后进入等待(read)，而客户端 1 接收到了响应(ret read)，最后根据用户指令退出(close)。而只有当客户端 1 断开之后，服务器才会处理客户端 2 的请求。我们可以使用并行的策略，同时处理不同客户端发来的请求。</p>
<h2 id="基于进程"><a href="#基于进程" class="headerlink" title="基于进程"></a>基于进程</h2><p>&emsp;&emsp;为每个客户端分离出一个单独的进程，是建立了连接之后才开始并行，连接的建立还是串行的。服务器在 accept 中返回 connfd 并且 fork 一个子进程来处理客户端连接。</p>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul>
<li>每个客户端由独立子进程处理<ul>
<li>必须回收僵尸进程，来避免严重的内存泄露</li>
</ul>
</li>
<li>内核自动管理多个逻辑流</li>
<li>每个进程有其私有的地址空间</li>
<li>不同进程之间不共享数据</li>
<li>父进程和子进程都有 listenfd 和 connfd，所以在父进程中需要关闭 connfd，在子进程中需要关闭 listenfd<ul>
<li>内核会保存每个 socket 的引用计数，在 fork 之后 refcnt(connfd) = 2，所以在父进程需要关闭 connfd，这样在子进程结束后引用计数才会为零</li>
</ul>
</li>
</ul>
<h2 id="基于事件"><a href="#基于事件" class="headerlink" title="基于事件"></a>基于事件</h2><p>&emsp;&emsp;服务器会维护一个 connection 数组，包含若干 connfd，每个输入请求都被当做事件，然后每次从已有的事件中选取一个进行处理。</p>
<h3 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h3><ul>
<li>由程序员手动控制多个逻辑流</li>
<li>所有的逻辑流共享同一个地址空间</li>
<li>这个技术称为 I/O multiplexing</li>
</ul>
<h2 id="基于线程"><a href="#基于线程" class="headerlink" title="基于线程"></a>基于线程</h2><p>&emsp;&emsp;<strong>线程</strong>就是运行在进程上下文中的逻辑流<br>&emsp;&emsp;一个进程则包括线程、代码、数据和上下文。也就是说，线程作为单独可执行的部分，被抽离出来了，一个进程可以有多个线程。<br>&emsp;&emsp;每个线程有自己的线程 id，有自己的逻辑控制流，也有自己的用来保存局部变量的栈（其他线程可以修改）但是会共享所有的代码、数据以及内核上下文。和进程不同的是，线程没有一个明确的树状结构（使用 fork 是有明确父进程子进程区分的）。和进程中『并行』的概念一样，如果两个线程的控制流在时间上有『重叠』（或者说有交叉），那么就是并行的。线程共享代码和数据（进程通常不会），线程开销比较小（创建和回收）。一个线程可以杀死它的任何对等线程，或者等待它的任意对等线程终止，而且每个对等线程能读写相同的共享数据。</p>
<h3 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h3><ul>
<li>内核自动管理多个逻辑流</li>
<li>每个线程共享地址空间</li>
</ul>
<h1 id="Posix-线程"><a href="#Posix-线程" class="headerlink" title="Posix 线程"></a>Posix 线程</h1><p>&emsp;&emsp;Posix线程是在c语言中处理线程的一个标准接口，Pthreads定义了大概60个函数，允许程序创建、杀死、回收线程，与对等线程安全的共享数据，还可以通知对等线程系统状态的变化。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thread</span><span class="params">(<span class="keyword">void</span> *vargp)</span>  <span class="comment">//每个线程例程都以一个通用指针作为输入，返回一个通用指针 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"helo"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">pthread_t</span> tid;      <span class="comment">//存放线程ID </span></span><br><span class="line">	pthread_create(&amp;tid, <span class="literal">NULL</span>, thread, <span class="literal">NULL</span>);    <span class="comment">//创建对等线程，此函数返回时，主线程与对等线程同时运行 </span></span><br><span class="line">	pthread_join(tid, <span class="literal">NULL</span>);   <span class="comment">//子线程合入主线程，主线程阻塞等待子线程结束，然后回收子线程资源。 </span></span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);   <span class="comment">//终止运行在这个进程中的所有进程 </span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h2 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h2><p>&emsp;&emsp;线程通过调用pthread_create函数来创建其他线程:</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">typedef void *(func)(void *);</span><br><span class="line"><span class="built_in">int</span> pthread<span class="constructor">_create(<span class="params">pthread_t</span> <span class="operator">*</span><span class="params">tid</span>, <span class="params">pthread_attr_t</span> <span class="operator">*</span><span class="params">attr</span>, <span class="params">func</span> <span class="operator">*</span><span class="params">f</span>, <span class="params">void</span> <span class="operator">*</span><span class="params">arg</span>)</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;此函数创建一个新线程，并带着一个输入变量args，在新线程的上下文中运行线程例程f。可用attr参数来改变新线程的默认属性。当此函数返回时，tid包含新创建的线程ID，可调用pthread_self函数来获得自己的线程ID:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ptherad_t</span> pthread_self(<span class="keyword">void</span>);</span><br></pre></td></tr></table></figure>
<h2 id="终止线程"><a href="#终止线程" class="headerlink" title="终止线程"></a>终止线程</h2><ul>
<li>顶层线程例程返回时，线程会隐式终止</li>
<li>调用pthread_exit函数，线程显式终止，此时线程占用的资源不会释放<code>void pthread_exit(void *thread_return)</code>参数可以通过pthread_join传递</li>
<li>某个对等线程调用exit函数，该函数终止进程以及与进程相关的所有线程</li>
<li>另一个对等线程通过以当前线程ID为参数调用pthread_cancel</li>
</ul>
<h2 id="回收资源"><a href="#回收资源" class="headerlink" title="回收资源"></a>回收资源</h2><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> pthread<span class="constructor">_join(<span class="params">pthread_t</span> <span class="params">tid</span>, <span class="params">void</span> <span class="operator">**</span><span class="params">thread_return</span>)</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;pthread_join会阻塞，直到线程tid终止，将线程例程返回的通用指针赋值为thread_return指向的位置，然后回收终止线程占用的资源</p>
<h2 id="分离线程"><a href="#分离线程" class="headerlink" title="分离线程"></a>分离线程</h2><p>&emsp;&emsp;在任何一个时间点上，线程是可结合或者分离的。<br>&emsp;&emsp;一个<strong>可结合</strong>线程能<strong>被其他线程收回和杀死</strong>。在被其他线程回收之前，它的<strong>内存资源是不释放</strong>的。<br>&emsp;&emsp;一个<strong>分离</strong>的线程不能被其他线程回收或者杀死，它的<strong>内存资源在它终止时由系统自动释放</strong>。<br>&emsp;&emsp;默认情况下，线程被创建为可结合的，pthread_detach可分离可结合线程tid</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> pthread<span class="constructor">_detach(<span class="params">pthread_t</span> <span class="params">tid</span>)</span>;</span><br></pre></td></tr></table></figure>

<h2 id="初始化线程"><a href="#初始化线程" class="headerlink" title="初始化线程"></a>初始化线程</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pthread_once_t</span> once_control = PTHREAD_ONCE_INIT;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_once</span><span class="params">(<span class="keyword">pthread_once_t</span> *once_control, <span class="keyword">void</span> (*init_routine)(<span class="keyword">void</span>))</span></span>;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;此函数允许你初始化与线程例程相关的状态，once_control是一个全局或者静态变量，总是被初始化为PTHREAD_ONCE。</p>
<h1 id="并发服务器-基于线程"><a href="#并发服务器-基于线程" class="headerlink" title="并发服务器-基于线程"></a>并发服务器-基于线程</h1><p>&emsp;&emsp;主线程不断等待连接请求，然后创建一个对等线程处理该请求。<br>Q：当我们调用pthread_create时，如何将已连接描述符传递给对等线程<br>A：传递一个指向描述符的指针</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"csapp.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">echo</span><span class="params">(<span class="keyword">int</span> connfd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">size_t</span> n;</span><br><span class="line">	<span class="keyword">rio_t</span> rio;</span><br><span class="line">	<span class="keyword">char</span> buf[MAXNLINE];</span><br><span class="line">	rio_readinitb(&amp;rio, connfd);</span><br><span class="line">	<span class="keyword">while</span>((n=rio_readlineb(&amp;rio, buf, MAXNLINE)) != <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"serve received %d bytes\n"</span>, (<span class="keyword">int</span>)n);</span><br><span class="line">		rio_writen(connfd, buf, n);</span><br><span class="line">	&#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thread</span><span class="params">(<span class="keyword">void</span> *vargp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> connfd = *((<span class="keyword">int</span> *)vargp);       <span class="comment">//把描述符取出来</span></span><br><span class="line">	pthread_detach(pthread_self());     <span class="comment">//分离线程，参数为线程ID</span></span><br><span class="line">	<span class="built_in">free</span>(vargp);    <span class="comment">//释放空间</span></span><br><span class="line">	echo(connfd);</span><br><span class="line">	close(connfd);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> listenfd,*connfdp;</span><br><span class="line">	<span class="keyword">socklen_t</span> clientlen;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_storage</span> <span class="title">clientaddr</span>;</span></span><br><span class="line">	<span class="keyword">pthread_t</span> tid;</span><br><span class="line">	<span class="keyword">if</span>(argc != <span class="number">2</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"usage: %s &lt;port&gt;\n"</span>, argv[<span class="number">0</span>]);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	listenfd = open_listenfd(argv[<span class="number">1</span>]);</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		clientlen=<span class="keyword">sizeof</span>(struct sockaddr_storage);</span><br><span class="line">		connfdp = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>));      <span class="comment">//开辟一个int大小的空间存描述符 </span></span><br><span class="line">		*connfdp = accept(listenfd, (struct sockaddr *)&amp; clientaddr, &amp;clientlen);</span><br><span class="line">		pthread_create(&amp;tid, <span class="literal">NULL</span>, thread, connfdp);  <span class="comment">//将指向描述符的指针传递给对等线程</span></span><br><span class="line">		 </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>csapp</category>
      </categories>
      <tags>
        <tag>Linux C/C++</tag>
        <tag>网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title>大整数运算</title>
    <url>/2019/11/04/%E5%A4%A7%E6%95%B4%E6%95%B0%E8%BF%90%E7%AE%97/</url>
    <content><![CDATA[<p>简介： 常用的大整数运算</p>
<a id="more"></a>
<h1 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h1><p>&emsp;&emsp;用string存储数组，将其倒着存，使得最高位在vector的末尾，这是为了方便进位</p>
<h1 id="加法"><a href="#加法" class="headerlink" title="加法"></a>加法</h1><p>&emsp;&emsp;注意最后可能t不为0，要将其存进去</p>
<figure class="highlight mel"><table><tr><td class="code"><pre><span class="line"><span class="keyword">vector</span>&lt;<span class="keyword">int</span>&gt; add(<span class="keyword">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;a, <span class="keyword">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;b)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">vector</span>&lt;<span class="keyword">int</span>&gt; C;</span><br><span class="line">	<span class="keyword">int</span> t=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;a.<span class="keyword">size</span>()||i&lt;b.<span class="keyword">size</span>(); i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(i&lt;a.<span class="keyword">size</span>())	t+=a[i];</span><br><span class="line">		<span class="keyword">if</span>(i&lt;b.<span class="keyword">size</span>())	t+=b[i];</span><br><span class="line">		C.push_back(t%10);</span><br><span class="line">		t/=<span class="number">10</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(t)	C.push_back(t);</span><br><span class="line">	<span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="减法"><a href="#减法" class="headerlink" title="减法"></a>减法</h1><p>&emsp;&emsp;主要存模的时候要先加10再对10取模，因为t可能是负数，在c++中，比如-2%10=-2。<br>&emsp;&emsp;最后得到结果可能含有前导0，要pop_back</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="built_in">int</span>&gt; sub(vector&lt;<span class="built_in">int</span>&gt; &amp;a, vector&lt;<span class="built_in">int</span>&gt; &amp;b)</span><br><span class="line">&#123;</span><br><span class="line">	vector&lt;<span class="built_in">int</span>&gt; C;</span><br><span class="line">	<span class="built_in">int</span> t=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>; i&lt;a.size(); i++)</span><br><span class="line">	&#123;</span><br><span class="line">		t=a[i]-t;     <span class="comment">//要减去借位 </span></span><br><span class="line"> 		<span class="keyword">if</span>(i&lt;b.size())	t-=b[i];</span><br><span class="line">		C.push_back((t+<span class="number">10</span>)%<span class="number">10</span>);</span><br><span class="line">		<span class="keyword">if</span>(t&lt;<span class="number">0</span>)	t=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">else</span>	t=<span class="number">0</span>; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(C.size()&gt;<span class="number">1</span> &amp;&amp; C.back()==<span class="number">0</span>)	C.pop_back();</span><br><span class="line">	<span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="乘法"><a href="#乘法" class="headerlink" title="乘法"></a>乘法</h1><p>&emsp;&emsp;不断相乘取模即可</p>
<figure class="highlight mel"><table><tr><td class="code"><pre><span class="line"><span class="keyword">vector</span>&lt;<span class="keyword">int</span>&gt; mul(<span class="keyword">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;a, <span class="keyword">int</span> b)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">vector</span>&lt;<span class="keyword">int</span>&gt; C;</span><br><span class="line">	<span class="keyword">int</span> t=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;a.<span class="keyword">size</span>()||t; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(i&lt;a.<span class="keyword">size</span>())	t+=b*a[i];</span><br><span class="line">		C.push_back(t%10);</span><br><span class="line">		t/=<span class="number">10</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="除法"><a href="#除法" class="headerlink" title="除法"></a>除法</h1><p>&emsp;&emsp;此时需要倒着遍历，因为除法运算需要从最高为开始除，最后需要把结果倒置并去除前置0。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="built_in">int</span>&gt; div(vector&lt;<span class="built_in">int</span>&gt; &amp;a, <span class="built_in">int</span> b, <span class="built_in">int</span> &amp;r)</span><br><span class="line">&#123;</span><br><span class="line">	vector&lt;<span class="built_in">int</span>&gt; C;</span><br><span class="line">	r=<span class="number">0</span>;</span><br><span class="line">	for(<span class="built_in">int</span> i=a.size<span class="literal">()</span>-<span class="number">1</span>; i&gt;=<span class="number">0</span>; --i)</span><br><span class="line">	&#123;</span><br><span class="line">		r=r*<span class="number">10</span>+a<span class="literal">[<span class="identifier">i</span>]</span>;</span><br><span class="line">		<span class="module-access"><span class="module"><span class="identifier">C</span>.</span></span>push<span class="constructor">_back(<span class="params">r</span><span class="operator">/</span><span class="params">b</span>)</span>;</span><br><span class="line">		r=r%b;</span><br><span class="line">	&#125;</span><br><span class="line">	reverse(<span class="module-access"><span class="module"><span class="identifier">C</span>.</span></span><span class="keyword">begin</span><span class="literal">()</span>, <span class="module-access"><span class="module"><span class="identifier">C</span>.</span></span><span class="keyword">end</span><span class="literal">()</span>);</span><br><span class="line">	<span class="keyword">while</span>(<span class="module-access"><span class="module"><span class="identifier">C</span>.</span></span>size<span class="literal">()</span>&gt;<span class="number">1</span><span class="operator"> &amp;&amp; </span><span class="module-access"><span class="module"><span class="identifier">C</span>.</span></span>back<span class="literal">()</span>==<span class="number">0</span>)	<span class="module-access"><span class="module"><span class="identifier">C</span>.</span></span>pop<span class="constructor">_back()</span>;</span><br><span class="line">	return C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法笔记</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>排序算法</title>
    <url>/2019/11/04/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>简介： 常用的排序算法</p>
<a id="more"></a>
<h1 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h1><p>&emsp;&emsp;每次从未排序序列中选最小的一个数插入到前面已排序序列</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*          选择排序   1&lt;=i&lt;=n</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">#<span class="keyword">if</span> <span class="number">0</span></span><br><span class="line"><span class="built_in">int</span> A&#123;maxn&#125;, n; </span><br><span class="line"><span class="built_in">void</span> SelectSort()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">1</span>; i&lt;=n; ++i)        <span class="comment">//进行n趟操作 </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">int</span> k=i;</span><br><span class="line">		<span class="keyword">for</span>(<span class="built_in">int</span> j=i; j&lt;=n; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(A[k]&gt;A[j])             <span class="comment">//比前面大，记录下来 </span></span><br><span class="line">			&#123;</span><br><span class="line">				k=j;</span><br><span class="line">			&#125; </span><br><span class="line">		&#125;</span><br><span class="line">		swap(A[k], A[i]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h1><p>&emsp;&emsp;遍历数组，将遍历到的值插入前面已排序序列中</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*          插入排序   1&lt;=i&lt;=n</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> A[maxn], n;</span><br><span class="line"><span class="built_in">void</span> InsertSort()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">2</span>; i&lt;=n; ++i)        <span class="comment">//进行n-1趟查找 </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">int</span> temp=A[i],j=i;	</span><br><span class="line">		<span class="keyword">while</span>(A[j<span class="number">-1</span>]&gt;temp &amp;&amp; j&gt;<span class="number">1</span>)   <span class="comment">//只要temp小于前面一个元素 </span></span><br><span class="line">		&#123;</span><br><span class="line">			A[j]=A[j<span class="number">-1</span>];           <span class="comment">//覆盖</span></span><br><span class="line">			j--; </span><br><span class="line">		&#125;</span><br><span class="line">		A[j]=temp;         <span class="comment">//插入 </span></span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><p>&emsp;&emsp;冒n-1趟，每次把最小的/最大的冒泡的顶端</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*          冒泡排序   0&lt;i&lt;n</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> A[maxn], n;</span><br><span class="line"><span class="built_in">void</span> BubbleSort()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>; i&lt;n<span class="number">-1</span>; ++i)          <span class="comment">//n-1次排序 </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">bool</span> flag =<span class="literal">false</span>;          <span class="comment">//只要某一趟没有交换元素，则说明排序完成 </span></span><br><span class="line">		<span class="keyword">for</span>(<span class="built_in">int</span> j=<span class="number">0</span>; j&lt;n-i<span class="number">-1</span>; ++j)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(A[j+<span class="number">1</span>] &lt; A[j])</span><br><span class="line">			&#123;</span><br><span class="line">				swap(A[j], A[j+<span class="number">1</span>]);</span><br><span class="line">				flag=<span class="literal">true</span>;        <span class="comment">//交换了元素 </span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;	</span><br><span class="line">		<span class="keyword">if</span>(!flag)	<span class="keyword">break</span>; </span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><p>&emsp;&emsp;把区间分为若干等份，每次取n等份排序，到最后一次的时候序列就为有序序列</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*          归并排序   0&lt;i&lt;n         </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">void</span> merge(<span class="built_in">int</span> s[], <span class="built_in">int</span> l, <span class="built_in">int</span> r)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(l&gt;=r)	<span class="keyword">return</span> ;   <span class="comment">//当l=r时没必要再排序 </span></span><br><span class="line">	<span class="built_in">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	merge(s,l,mid);</span><br><span class="line">	merge(s,mid+<span class="number">1</span>,r);</span><br><span class="line">	<span class="built_in">int</span> k=<span class="number">0</span>,i=l,j=mid+<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(i&lt;=mid &amp;&amp; j&lt;=r)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(s[i]&lt;s[j])	temp[k++]=s[i++];</span><br><span class="line">		<span class="keyword">else</span>	temp[k++]=s[j++];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(i&lt;=mid)	temp[k++]=s[i++];</span><br><span class="line">	<span class="keyword">while</span>(j&lt;=r)	temp[k++]=s[j++];</span><br><span class="line">	<span class="keyword">for</span>(<span class="built_in">int</span> i=l,j=<span class="number">0</span>; i&lt;=r; i++,j++)	s[i]=temp[j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><p>&emsp;&emsp;每次选取一个主元，一次排序后主元左边的数都小于等于它，右边的数都大于等于它</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*          快速排序   0&lt;i&lt;n         </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">void quick<span class="constructor">_sort(<span class="params">int</span> <span class="params">q</span>[], <span class="params">int</span> <span class="params">l</span>, <span class="params">int</span> <span class="params">r</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&gt;=r)    return ;<span class="comment">//只有一个数不用再排序</span></span><br><span class="line">    <span class="built_in">int</span> i = l-<span class="number">1</span>,j = r+<span class="number">1</span>,x = q<span class="literal">[<span class="identifier">l</span>+<span class="identifier">r</span>&gt;&gt;<span class="number">1</span>]</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; j) <span class="comment">//最后i和j会相差1</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">do</span> i++; <span class="keyword">while</span>(q<span class="literal">[<span class="identifier">i</span>]</span> &lt; x);</span><br><span class="line">        <span class="keyword">do</span> j--; <span class="keyword">while</span>(q<span class="literal">[<span class="identifier">j</span>]</span> &gt; x);</span><br><span class="line">        <span class="keyword">if</span>(i&lt;j) swap(q<span class="literal">[<span class="identifier">i</span>]</span>, q<span class="literal">[<span class="identifier">j</span>]</span>);     <span class="comment">//因为最后确定位置的数不知道在哪，所以两边都要递归</span></span><br><span class="line">    &#125;</span><br><span class="line">    quick<span class="constructor">_sort(<span class="params">q</span>, <span class="params">l</span>, <span class="params">j</span>)</span>;               <span class="comment">//不用i的原因是，比如 1，2两个数的情况会出错 分为两边，一边小于等于一边大于等于 --------j-i-1----------- </span></span><br><span class="line">                                <span class="comment">//可以这样改：用i的时候x不能为左边界，用j的时候x不能为有边界，改q[l+r&gt;&gt;1]即可</span></span><br><span class="line">    quick<span class="constructor">_sort(<span class="params">q</span>, <span class="params">j</span>+1, <span class="params">r</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h1><p>&emsp;&emsp;类似于数，每次都用down或者up操作不断上升/下降，直到整个堆有序，此时每个父节点都大于/小于它的子节点</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">100010</span>;</span><br><span class="line"><span class="keyword">int</span> heap[maxn],size;</span><br><span class="line"><span class="keyword">int</span> m,n;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">down</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> t=u;</span><br><span class="line">	<span class="keyword">if</span>(u*<span class="number">2</span>&lt;=size &amp;&amp; heap[u*<span class="number">2</span>]&lt;heap[t])     	t=u*<span class="number">2</span>;  <span class="comment">//有左儿子并且小于它 </span></span><br><span class="line">	<span class="keyword">if</span>(u*<span class="number">2</span>+<span class="number">1</span>&lt;=size &amp;&amp; heap[u*<span class="number">2</span>+<span class="number">1</span>]&lt;heap[t])	t=u*<span class="number">2</span>+<span class="number">1</span>; <span class="comment">//有右儿子并且小于它 </span></span><br><span class="line">	<span class="keyword">if</span>(u!=t)</span><br><span class="line">	&#123;</span><br><span class="line">		swap(heap[t], heap[u]);</span><br><span class="line">		down(t);            <span class="comment">//递归dowm下去 </span></span><br><span class="line">	 &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">up</span><span class="params">(<span class="keyword">int</span> u)</span>   <span class="comment">//插入使用 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(u/<span class="number">2</span> &amp;&amp; heap[u/<span class="number">2</span>]&gt;heap[u])  <span class="comment">//有祖先并且祖先比它大 </span></span><br><span class="line">	&#123;</span><br><span class="line">		swap(heap[u], heap[u/<span class="number">2</span>]);</span><br><span class="line">		u/=<span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)	<span class="built_in">cin</span>&gt;&gt;heap[i];</span><br><span class="line">	size=n;        <span class="comment">//size指向最后一个元素 </span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=n/<span class="number">2</span>; i; --i)	down(i);          <span class="comment">//利用二叉树性质，最后一个父节点开始down </span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=<span class="number">6</span>; i++)	<span class="built_in">cout</span>&lt;&lt;heap[i]&lt;&lt;<span class="string">' '</span>;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">while</span>(m--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;heap[<span class="number">1</span>]&lt;&lt;<span class="string">" "</span>; </span><br><span class="line">		heap[<span class="number">1</span>]=heap[size];      <span class="comment">//删掉堆顶元素 </span></span><br><span class="line">		size--;    <span class="comment">//删掉元素</span></span><br><span class="line">		down(<span class="number">1</span>); </span><br><span class="line">	 &#125; 	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法笔记</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>查找算法</title>
    <url>/2019/11/04/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>简介： 常用的查找算法</p>
<a id="more"></a>
<h1 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h1><p>&emsp;&emsp;每次去中点mid，然后将区间分为两部分</p>
<figure class="highlight excel"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">*			二分查找  区间为【<span class="built_in">left</span>，<span class="built_in">right</span>】，均为闭区间，传入的初始值为【<span class="number">0</span>，<span class="built_in">n</span>-<span class="number">1</span>】 </span><br><span class="line">*/ </span><br><span class="line"><span class="built_in">int</span> BinarySearch(<span class="built_in">int</span> A[], <span class="built_in">int</span> <span class="built_in">left</span>, <span class="built_in">int</span> <span class="built_in">right</span>, <span class="built_in">int</span> x)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">int</span> <span class="built_in">mid</span>;</span><br><span class="line">	while(<span class="built_in">left</span>&lt;=<span class="built_in">right</span>)             //此处为&lt;= </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">mid</span>=(<span class="built_in">left</span>+<span class="built_in">right</span>)/<span class="number">2</span>;</span><br><span class="line">		<span class="built_in">if</span>(A[<span class="built_in">mid</span>]==x)</span><br><span class="line">		&#123;</span><br><span class="line">			return <span class="built_in">mid</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		else <span class="built_in">if</span>(A[<span class="built_in">mid</span>]&gt;x)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">right</span>=<span class="built_in">mid</span>-<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		else</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">left</span>=<span class="built_in">mid</span>+<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return -<span class="number">1</span>;              //查找失败 </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="二分查找-将区间分为-left-mid-1-mid-right"><a href="#二分查找-将区间分为-left-mid-1-mid-right" class="headerlink" title="二分查找(将区间分为[left,mid-1],[mid, right])"></a>二分查找(将区间分为[left,mid-1],[mid, right])</h1><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 区间[l, r]被划分成[l, mid - 1]和[mid, r]时使用</span></span><br><span class="line"><span class="built_in">int</span> bsearch_1(<span class="built_in">int</span> l, <span class="built_in">int</span> r)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">while</span>(l&lt;r)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">int</span> mid=l+r+<span class="number">1</span>&gt;&gt;<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(check(mid))	l=mid;</span><br><span class="line">		<span class="keyword">else</span> r=mid<span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="二分查找-将区间分为-left-mid-mid-1-right"><a href="#二分查找-将区间分为-left-mid-mid-1-right" class="headerlink" title="二分查找(将区间分为[left, mid],[mid+1, right])"></a>二分查找(将区间分为[left, mid],[mid+1, right])</h1><p>&emsp;&emsp;此时计算mid时需要取left+right&gt;&gt;1。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用</span></span><br><span class="line"><span class="built_in">int</span> bsearch_1(<span class="built_in">int</span> l, <span class="built_in">int</span> r)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">while</span>(l&lt;r)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(check(mid))	r=mid;</span><br><span class="line">		<span class="keyword">else</span> l=mid+<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="浮点数二分"><a href="#浮点数二分" class="headerlink" title="浮点数二分"></a>浮点数二分</h1><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//浮点数二分</span></span><br><span class="line"><span class="built_in">double</span> bsearch_1(<span class="built_in">double</span> l, <span class="built_in">double</span> r)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">const</span> <span class="built_in">double</span> eps=<span class="number">1e-8</span>;</span><br><span class="line">	<span class="keyword">while</span>(r-l&gt;eps)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">double</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(check(mid))	r=mid;</span><br><span class="line">		<span class="keyword">else</span>	l=mid;	</span><br><span class="line">	&#125;	</span><br><span class="line">	<span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法笔记</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>echo服务器</title>
    <url>/2019/11/04/echo%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
    <content><![CDATA[<p>简介： echo客户端&amp;服务器</p>
<a id="more"></a>
<h1 id="echo客户端"><a href="#echo客户端" class="headerlink" title="echo客户端"></a>echo客户端</h1><h2 id="main函数-amp-open-clientfd函数"><a href="#main函数-amp-open-clientfd函数" class="headerlink" title="main函数 &amp; open_clientfd函数"></a>main函数 &amp; open_clientfd函数</h2><p>&emsp;&emsp;echo客户端输入两个参数，一个是服务器的ip，一个是服务器的端口，将ip与端口传入open_clientfd函数获取一个已连接描述符。在和服务器连接以后，客户端应该进入一个循环，反复从标准输入读取文本行，发送文本行给服务器，从服务器读取回送的行，并输出结果到标准输出。当fgets在标准输入上遇到EOF时，或者因为用户在键盘上输入ctrl+D，或者在遇到一个重定向的输入文件中用尽了所有的文本行时，循环截止。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">open_clientfd</span><span class="params">(<span class="keyword">char</span> *hostname, <span class="keyword">char</span> *port)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> clientfd;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">addrinfo</span> *<span class="title">p</span>,*<span class="title">listp</span>,<span class="title">hints</span>;</span></span><br><span class="line">	<span class="built_in">memset</span>(&amp;hints, <span class="number">0</span>, <span class="keyword">sizeof</span>(struct addrinfo));</span><br><span class="line">	hints.ai_socktype = SOCK_STREAM;</span><br><span class="line">	hints.ai_flags = AI_NUMERICSERV | AI_ADDRCONFIG | AI_PASSIVE;</span><br><span class="line">	<span class="comment">//ai_addrconfig 只有当主机配置为ipv4时，getaddrinfo返回ipv4</span></span><br><span class="line">	<span class="comment">//ai_passive 使得getaddrinfo默认返回套接字地址</span></span><br><span class="line">	<span class="comment">//ai_numericserv 强制第二个参数service默认为端口号 </span></span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	getaddrinfo(hostname, port, &amp;hints, &amp;listp);</span><br><span class="line">	<span class="keyword">for</span>(p=listp; p; p=p-&gt;ai_next)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>((clientfd = socket(p-&gt;ai_family, p-&gt;ai_socktype, p-&gt;ai_protocol)) &lt; <span class="number">0</span>)	<span class="keyword">continue</span>;</span><br><span class="line">		<span class="comment">// 通过connect建立与服务器的连接</span></span><br><span class="line">		<span class="comment">// int connect(int clientfd, const struct sockaddr *addr, socklen_t adddrlen)</span></span><br><span class="line">		<span class="keyword">if</span>(connect(clientfd, p-&gt;ai_addr, p-&gt;ai_addrlen) != <span class="number">-1</span>)	<span class="keyword">break</span>;</span><br><span class="line">		close(clientfd); </span><br><span class="line">	&#125;</span><br><span class="line">	freeaddrinfo(listp);</span><br><span class="line">	<span class="keyword">if</span>(!p)	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> clientfd;      <span class="comment">//客户端不需要监听 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> clientfd;</span><br><span class="line">	<span class="keyword">char</span> *host, *port, buf[MAXNLINE];</span><br><span class="line">	<span class="keyword">rio_t</span> rio;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(argc != <span class="number">3</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"usage: %s &lt;host&gt; &lt;port&gt;\n"</span>, argv[<span class="number">0</span>]);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;		</span><br><span class="line">	&#125;	</span><br><span class="line">	host = argv[<span class="number">1</span>], port = argv[<span class="number">2</span>];</span><br><span class="line">	clientfd = open_clientfd(host, port);	</span><br><span class="line">	rio_readinitb(&amp;rio, clientfd);</span><br><span class="line">	<span class="keyword">while</span>(fgets(buf, MAXNLINE, <span class="built_in">stdin</span>) != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		rio_writen(clientfd, buf, <span class="built_in">strlen</span>(buf));</span><br><span class="line">		rio_readlineb(&amp;rio, buf, MAXNLINE);  <span class="comment">//服务器写回来再让客户端读 </span></span><br><span class="line">		<span class="built_in">fputs</span>(buf, <span class="built_in">stdout</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	close(clientfd);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="rio函数"><a href="#rio函数" class="headerlink" title="rio函数"></a>rio函数</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LISTENQ 1024</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RIOBUFSIZE 1024*8</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXNLINE 1024*8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> rio_fd,rio_cnt;</span><br><span class="line">	<span class="keyword">char</span> rio_buf[RIOBUFSIZE], *rio_bufptr;</span><br><span class="line">&#125;<span class="keyword">rio_t</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">ssize_t</span> rio_writen(<span class="keyword">int</span> fd, <span class="keyword">void</span> *usrbuf, <span class="keyword">size_t</span> n)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">size_t</span> nleft=n;</span><br><span class="line">	<span class="keyword">size_t</span> nwritten;</span><br><span class="line">	<span class="keyword">char</span> *buf = usrbuf;</span><br><span class="line">	<span class="keyword">while</span>(nleft &gt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>((nwritten = write(fd, buf, nleft)) &lt;= <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(errno == EINTR)	nwritten=<span class="number">0</span>;      <span class="comment">//中断了 </span></span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		nleft -= nwritten;</span><br><span class="line">		buf += nwritten;</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> n;	</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">ssize_t</span> rio_read(<span class="keyword">rio_t</span> *rp, <span class="keyword">char</span> *rc, <span class="keyword">size_t</span> n)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> cnt;</span><br><span class="line">	<span class="keyword">while</span>(rp-&gt;rio_cnt &lt;= <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		rp-&gt;rio_cnt=read(rp-&gt;rio_fd, rp-&gt;rio_buf, <span class="keyword">sizeof</span>(rp-&gt;rio_buf));</span><br><span class="line">		<span class="keyword">if</span>(rp-&gt;rio_cnt &lt; <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(errno != EINTR)	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(rp-&gt;rio_cnt == <span class="number">0</span>)	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">else</span> rp-&gt;rio_bufptr = rp-&gt;rio_buf;</span><br><span class="line">	&#125;</span><br><span class="line">	cnt = n;</span><br><span class="line">	<span class="keyword">if</span>(rp-&gt;rio_cnt &lt; n)	cnt=rp-&gt;rio_cnt;</span><br><span class="line">	<span class="built_in">memcpy</span>(rc, rp-&gt;rio_bufptr, cnt);</span><br><span class="line">	rp-&gt;rio_bufptr+=cnt;</span><br><span class="line">	rp-&gt;rio_cnt-=cnt;</span><br><span class="line">	<span class="keyword">return</span> cnt;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">ssize_t</span> rio_readlineb(<span class="keyword">rio_t</span> *rio, <span class="keyword">void</span> *usrbuf, <span class="keyword">size_t</span> maxlen)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">char</span> *buf=usrbuf, c;</span><br><span class="line">	<span class="keyword">int</span> n,rc;</span><br><span class="line">	<span class="keyword">for</span>(n=<span class="number">1</span>; n&lt;maxlen; n++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>((rc = rio_read(rio, &amp;c, <span class="number">1</span>)) == <span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			*buf++ = c;</span><br><span class="line">			<span class="keyword">if</span>(c==<span class="string">'\n'</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				n++;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(rc == <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(n==<span class="number">1</span>)	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	*buf = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> n<span class="number">-1</span>;</span><br><span class="line">		</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rio_readinitb</span><span class="params">(<span class="keyword">rio_t</span> *rio, <span class="keyword">int</span> fd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	rio-&gt;rio_fd=fd;</span><br><span class="line">	rio-&gt;rio_cnt=<span class="number">0</span>;</span><br><span class="line">	rio-&gt;rio_bufptr=rio-&gt;rio_buf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="echo服务器-普通版"><a href="#echo服务器-普通版" class="headerlink" title="echo服务器(普通版)"></a>echo服务器(普通版)</h1><h2 id="main函数-amp-open-listenfd函数"><a href="#main函数-amp-open-listenfd函数" class="headerlink" title="main函数 &amp; open_listenfd函数"></a>main函数 &amp; open_listenfd函数</h2><p>&emsp;&emsp;服务器主程序，打开监听描述符，进入循环，等待一个来自客户端的连接请求，输出已连接的客户端域名和IP地址，并调用echo函数为这个客户端服务，在echo程序返回之后，主程序关闭已连接的描述符，一旦客户端和服务器都关闭了他们各自的描述符，连接终止。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">open_listenfd</span><span class="params">(<span class="keyword">char</span> *port)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">addrinfo</span> <span class="title">hints</span>,*<span class="title">p</span>,*<span class="title">listp</span>;</span></span><br><span class="line">    <span class="keyword">int</span> listenfd, optval=<span class="number">1</span>,rc;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;hints, <span class="number">0</span>, <span class="keyword">sizeof</span>(struct addrinfo));</span><br><span class="line">    hints.ai_socktype=SOCK_STREAM;</span><br><span class="line">    hints.ai_flags = AI_PASSIVE | AI_ADDRCONFIG;</span><br><span class="line">    hints.ai_flags |= AI_NUMERICSERV;</span><br><span class="line">    <span class="comment">//socket----&gt;bind----&gt;listen</span></span><br><span class="line">    getaddrinfo(<span class="literal">NULL</span>, port, &amp;hints, &amp;listp);</span><br><span class="line">   <span class="comment">// if(listp == NULL) </span></span><br><span class="line">    <span class="keyword">for</span>(p=listp; p; p=p-&gt;ai_next)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>((listenfd=socket(p-&gt;ai_family, p-&gt;ai_socktype, p-&gt;ai_protocol)) &lt; <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">       <span class="keyword">if</span>((rc= setsockopt(listenfd, SOL_SOCKET, SO_REUSEADDR, &amp; optval, <span class="keyword">sizeof</span>(<span class="keyword">int</span>))) &lt; <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, strerror(errno));</span><br><span class="line">        <span class="keyword">if</span>(bind(listenfd, p-&gt;ai_addr, p-&gt;ai_addrlen) == <span class="number">0</span>)     <span class="comment">//printf("%s\n", strerror(errno)); //break;</span></span><br><span class="line">        		<span class="keyword">break</span>;</span><br><span class="line">		close(listenfd);</span><br><span class="line">    &#125;</span><br><span class="line">    freeaddrinfo(listp);</span><br><span class="line">    <span class="keyword">if</span>(!p)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(listen(listenfd, LISTENQ) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        close(listenfd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> listenfd;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> listenfd, connfd;</span><br><span class="line">	<span class="keyword">socklen_t</span> clientlen;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_storage</span> <span class="title">clientaddr</span>;</span></span><br><span class="line">	<span class="keyword">char</span> client_hostname[MAXNLINE], client_port[MAXNLINE];</span><br><span class="line">	<span class="keyword">if</span>(argc != <span class="number">2</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"usage: %s &lt;port&gt;\n"</span>, argv[<span class="number">0</span>]);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;	</span><br><span class="line">	&#125;	</span><br><span class="line">	listenfd = open_listenfd(argv[<span class="number">1</span>]);</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		clientlen = <span class="keyword">sizeof</span>(clientaddr);</span><br><span class="line">		connfd = accept(listenfd, (struct sockaddr *)&amp;clientaddr, &amp;clientlen);</span><br><span class="line">		getnameinfo((struct sockaddr *)&amp;clientaddr, clientlen, client_hostnmae, MAXNLINE, client_port, MAXNLINE, <span class="number">0</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Connected to (%s %s)\n"</span>, client_hostname, client_port);</span><br><span class="line">		echo(connfd);</span><br><span class="line">		close(connfd);</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="echo函数"><a href="#echo函数" class="headerlink" title="echo函数"></a>echo函数</h2><p>&emsp;&emsp;服务器调用echo函数读取从客户端传来的数据，读完以后再写回客户端让客户端读取输出。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">void echo(<span class="built_in">int</span> connfd)</span><br><span class="line">&#123;</span><br><span class="line">	size_t n;</span><br><span class="line">	<span class="built_in">char</span> buf<span class="literal">[MAXNLINE]</span>;</span><br><span class="line">	rio_t rio;</span><br><span class="line">	rio<span class="constructor">_readinitb(&amp;<span class="params">rio</span>, <span class="params">connfd</span>)</span>;</span><br><span class="line">	<span class="keyword">while</span>((n=rio<span class="constructor">_readlineb(&amp;<span class="params">rio</span>, <span class="params">buf</span>, MAXNLINE)</span>) != <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		printf(<span class="string">"serve received %d bytes\n"</span>, (<span class="built_in">int</span>)n);</span><br><span class="line">		rio<span class="constructor">_writen(<span class="params">connfd</span>, <span class="params">buf</span>, <span class="params">n</span>)</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="echo服务器-基于进程并发"><a href="#echo服务器-基于进程并发" class="headerlink" title="echo服务器(基于进程并发)"></a>echo服务器(基于进程并发)</h1><h2 id="main函数"><a href="#main函数" class="headerlink" title="main函数"></a>main函数</h2><p>&emsp;&emsp;利用SIGCHLD信号，在一个进程终止或者停止时，将SIGCHLD信号发送给其父进程，按系统默认将忽略此信号。建立连接后，创建一个子进程，再子进程中进行操作，最后由父进程回收子进程资源。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> listenfd, connfd;</span><br><span class="line">	<span class="keyword">socklen_t</span> clientlen;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_storage</span> <span class="title">clientaddr</span>;</span></span><br><span class="line">	<span class="keyword">if</span>(argc != <span class="number">2</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"usage: %s &lt;port&gt;\n"</span>, argv[<span class="number">0</span>]);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	listenfd = open_listenfd(argv[<span class="number">1</span>]);</span><br><span class="line">	signal(SIGCHLD, sigchld_handler);  <span class="comment">//signal（参数1，参数2） 参数1：我们要进行处理的信号。参数2：我们处理的方式</span></span><br><span class="line">	<span class="comment">//  在一个进程终止或者停止时，将SIGCHLD信号发送给其父进程，按系统默认将忽略此信号</span></span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		clientlen = <span class="keyword">sizeof</span>(struct sockaddr_storage);</span><br><span class="line">		connfd = accept(listenfd, (struct sockaddr *)&amp; clientaddr, &amp;clientlen);</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(fork() == <span class="number">0</span>)     <span class="comment">//子进程 </span></span><br><span class="line">		&#123;</span><br><span class="line">			close(listenfd);       <span class="comment">//关闭副本中的监听描述符 </span></span><br><span class="line">			echo(connfd);</span><br><span class="line">			close(connfd);</span><br><span class="line">			<span class="built_in">exit</span>(<span class="number">0</span>); </span><br><span class="line">		&#125;</span><br><span class="line">		close(connfd);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="sigchld-handler函数"><a href="#sigchld-handler函数" class="headerlink" title="sigchld_handler函数"></a>sigchld_handler函数</h2><p>&emsp;&emsp;当能回收到子进程时，就一直循环，若退出，说明子进程以及全部回收完毕。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">void</span> sigchld_handler(<span class="built_in">int</span> sig)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">while</span>(waitpid(<span class="number">-1</span>, <span class="number">0</span>, WNOHANG) &gt; <span class="number">0</span>) ;        <span class="comment">//-1表示回收任意子进程 </span></span><br><span class="line">	<span class="comment">//正常返回回收id，，没有回收返回0，，出错返回-1</span></span><br><span class="line">	<span class="keyword">return</span> ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="echo函数-1"><a href="#echo函数-1" class="headerlink" title="echo函数"></a>echo函数</h2><p>&emsp;&emsp;服务器调用echo函数读取从客户端传来的数据，读完以后再写回客户端让客户端读取输出。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">void echo(<span class="built_in">int</span> connfd)</span><br><span class="line">&#123;</span><br><span class="line">	size_t n;</span><br><span class="line">	<span class="built_in">char</span> buf<span class="literal">[MAXNLINE]</span>;</span><br><span class="line">	rio_t rio;</span><br><span class="line">	rio<span class="constructor">_readinitb(&amp;<span class="params">rio</span>, <span class="params">connfd</span>)</span>;</span><br><span class="line">	<span class="keyword">while</span>((n=rio<span class="constructor">_readlineb(&amp;<span class="params">rio</span>, <span class="params">buf</span>, MAXNLINE)</span>) != <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		printf(<span class="string">"serve received %d bytes\n"</span>, (<span class="built_in">int</span>)n);</span><br><span class="line">		rio<span class="constructor">_writen(<span class="params">connfd</span>, <span class="params">buf</span>, <span class="params">n</span>)</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="echo服务器-基于I-O多路复用"><a href="#echo服务器-基于I-O多路复用" class="headerlink" title="echo服务器(基于I/O多路复用)"></a>echo服务器(基于I/O多路复用)</h1><h2 id="main函数-1"><a href="#main函数-1" class="headerlink" title="main函数"></a>main函数</h2><p>&emsp;&emsp;利用一个read_set，其类似与一个数组，初始时使FD_SET把已连接描述符位和STDIN_FILENO位置为1，调用select函数，若FD_ISSET为true，则证明是客户端输入/服务端输入，此时再进行下一步操作,其中select函数在sys/select.h中。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> main(<span class="built_in">int</span> argc, <span class="built_in">char</span> **argv)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">int</span> listenfd, connfd;</span><br><span class="line">	socklen_t clientlen;</span><br><span class="line">	<span class="keyword">struct</span> sockaddr_storage clientaddr;</span><br><span class="line">	fd_set read_set, ready_set;</span><br><span class="line">	<span class="keyword">if</span>(argc!=<span class="number">2</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		fprintf(stderr, <span class="string">"usage: %s &lt;port&gt;\n"</span>, argv<span class="literal">[<span class="number">0</span>]</span>);</span><br><span class="line">		exit(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	listenfd = <span class="keyword">open</span><span class="constructor">_listen(<span class="params">argv</span>[1])</span>;</span><br><span class="line">	<span class="constructor">FD_ZERO(&amp;<span class="params">read_set</span>)</span></span><br><span class="line">	<span class="comment">// stdin类型为 FILE*</span></span><br><span class="line">    <span class="comment">//   STDIN_FILENO类型为 int</span></span><br><span class="line">    <span class="comment">// STDIN_FILENO    0    -----  STDOUT_FILENO   1  -----  STDERR_FILENO   2</span></span><br><span class="line">	<span class="constructor">FD_SET(STDIN_FILENO, &amp;<span class="params">read_set</span>)</span>;</span><br><span class="line">	<span class="constructor">FD_SET(LISTENFD, &amp;<span class="params">readset</span>)</span>;          <span class="comment">//把listenfd与标准输入位置为1</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		ready_set = read_set;</span><br><span class="line">		select(listenfd+<span class="number">1</span>, &amp;ready_set, NULL, NULL, NULL);	</span><br><span class="line">		<span class="keyword">if</span>(<span class="constructor">FD_ISSET(STDIN_FILENO, &amp;<span class="params">ready_set</span>)</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			command<span class="literal">()</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(<span class="constructor">FD_ISSET(<span class="params">listenfd</span>, &amp;<span class="params">ready_set</span>)</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			clientlen=sizeof(<span class="keyword">struct</span> sockaddr_storage);</span><br><span class="line">			connfd=accept(listenfd, (<span class="keyword">struct</span> sockaddr*)&amp; clientaddr, &amp;clientlen);</span><br><span class="line">			echo(connfd);</span><br><span class="line">			close(connfd);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="command函数"><a href="#command函数" class="headerlink" title="command函数"></a>command函数</h2><p>&emsp;&emsp;若为服务端输入，调用command函数，读取终端输入的字符串。</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">void command()   <span class="regexp">//</span>当STDIN_FILENO为<span class="number">1</span>时，会读取输入 </span><br><span class="line">&#123;</span><br><span class="line">	char buf[MAXNLINE];</span><br><span class="line">	<span class="keyword">if</span>(fgets(buf, MAXNLINE, stdin) != NULL)</span><br><span class="line">	&#123;</span><br><span class="line">		printf(<span class="string">"%s"</span>, buf);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>	<span class="keyword">exit</span>(<span class="number">0</span>);       <span class="regexp">//</span>EOF,什么都没有读到 </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="echo函数-2"><a href="#echo函数-2" class="headerlink" title="echo函数"></a>echo函数</h2><p>&emsp;&emsp;服务器调用echo函数读取从客户端传来的数据，读完以后再写回客户端让客户端读取输出。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">void echo(<span class="built_in">int</span> connfd)</span><br><span class="line">&#123;</span><br><span class="line">	size_t n;</span><br><span class="line">	<span class="built_in">char</span> buf<span class="literal">[MAXNLINE]</span>;</span><br><span class="line">	rio_t rio;</span><br><span class="line">	rio<span class="constructor">_readinitb(&amp;<span class="params">rio</span>, <span class="params">connfd</span>)</span>;</span><br><span class="line">	<span class="keyword">while</span>((n=rio<span class="constructor">_readlineb(&amp;<span class="params">rio</span>, <span class="params">buf</span>, MAXNLINE)</span>) != <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		printf(<span class="string">"serve received %d bytes\n"</span>, (<span class="built_in">int</span>)n);</span><br><span class="line">		rio<span class="constructor">_writen(<span class="params">connfd</span>, <span class="params">buf</span>, <span class="params">n</span>)</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="echo服务器-基于I-O多路复用且适用于并发事件"><a href="#echo服务器-基于I-O多路复用且适用于并发事件" class="headerlink" title="echo服务器(基于I/O多路复用且适用于并发事件)"></a>echo服务器(基于I/O多路复用且适用于并发事件)</h1><h2 id="状态机"><a href="#状态机" class="headerlink" title="状态机"></a>状态机</h2><p>&emsp;&emsp;状态机就是一组状态、输入时间、和转移，其中转移是将状态和输入事件映射到状态。<br><img src="https://s2.ax1x.com/2019/11/06/MPa00A.png" alt=""></p>
<h2 id="pool-结构体"><a href="#pool-结构体" class="headerlink" title="pool 结构体"></a>pool 结构体</h2><p>&emsp;&emsp;pool结构体中维护着客户端的集合，当一个连接请求到达时，服务器打开连接，将该客户端添加到池中。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span>  maxfd;   <span class="comment">//read_set最大的描述符 </span></span><br><span class="line">	fd_set read_set,ready_set;  <span class="comment">//描述符集合 </span></span><br><span class="line">	<span class="keyword">int</span> nready, maxi;        <span class="comment">//nready表示就绪的描述符数 ，maxi表示新加入到pool中的clientfd下标（到clientfd数组的最大索引） </span></span><br><span class="line">	<span class="keyword">int</span> clientfd[FD_SETSIZE];  <span class="comment">//活动的描述符的集合 </span></span><br><span class="line">	<span class="keyword">rio_t</span> clientrio[FD_SETSIZE];   <span class="comment">//存取缓存集合 </span></span><br><span class="line">&#125;pool;          <span class="comment">//线程池</span></span><br></pre></td></tr></table></figure>

<h2 id="init-pool-函数"><a href="#init-pool-函数" class="headerlink" title="init_pool 函数"></a>init_pool 函数</h2><p>&emsp;&emsp;初始化pool,clientfd数组表示已连接描述符的集合<br>其中整数-1表示一个可用的槽位。初始时，已连接描述符集合是空的，而且，监听描述符是select读集合中唯一的描述符。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">void init<span class="constructor">_pool(<span class="params">int</span> <span class="params">listenfd</span>, <span class="params">pool</span> <span class="operator">*</span><span class="params">p</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 初始化，此时没有任何已连接描述符</span></span><br><span class="line">	<span class="built_in">int</span> i;</span><br><span class="line">	p-&gt;maxi = -<span class="number">1</span>;</span><br><span class="line">	for(i=<span class="number">0</span>; i&lt;FD_SETSIZE; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		p-&gt;clientfd<span class="literal">[<span class="identifier">i</span>]</span>=-<span class="number">1</span>;      <span class="comment">//没有已连接描述符	</span></span><br><span class="line">	&#125; </span><br><span class="line">	<span class="comment">//初始化，listenfd是read_set唯一的成员</span></span><br><span class="line">	p-&gt;maxfd = listenfd;</span><br><span class="line">	<span class="constructor">FD_ZERO(&amp;<span class="params">p</span>-&gt;<span class="params">read_set</span>)</span>;</span><br><span class="line">	<span class="constructor">FD_SET(<span class="params">listenfd</span>, &amp;<span class="params">p</span>-&gt;<span class="params">read_set</span>)</span>;</span><br></pre></td></tr></table></figure>
<h2 id="main-函数"><a href="#main-函数" class="headerlink" title="main 函数"></a>main 函数</h2><p>&emsp;&emsp;每次都更新新的ready_set，调用select返回准备好的描述符个数，其中只有客户端发起了连接对应的描述符才会就位，超时则会返回0。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> main(<span class="built_in">int</span> argc, <span class="built_in">char</span> **argv)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">int</span> listenfd,connfd;</span><br><span class="line">	socklen_t clientlen;</span><br><span class="line">	<span class="keyword">struct</span> sockaddr_storage clientaddr;</span><br><span class="line">	static pool pool;</span><br><span class="line">	<span class="keyword">if</span>(argc != <span class="number">2</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		fprintf(stderr, <span class="string">"usage: %s &lt;port&gt;\n"</span>, argv<span class="literal">[<span class="number">0</span>]</span>);</span><br><span class="line">		return <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	listenfd = <span class="keyword">open</span><span class="constructor">_listenfd(<span class="params">argv</span>[1])</span>;</span><br><span class="line">	init<span class="constructor">_pool(<span class="params">listenfd</span>, &amp;<span class="params">pool</span>)</span>;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		pool.ready_set=pool.read_set;</span><br><span class="line">		pool.nready=select(pool.maxfd+<span class="number">1</span>, &amp;pool.ready_set, NULL, NULL, NULL);</span><br><span class="line">		<span class="keyword">if</span>(<span class="constructor">FD_ISSET(<span class="params">listenfd</span>, &amp;<span class="params">pool</span>.<span class="params">ready_set</span>)</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			clientlen = sizeof(<span class="keyword">struct</span> sockaddr);</span><br><span class="line">			connfd = accept(listenfd, (<span class="keyword">struct</span> sockaddr*)&amp;clientaddr, &amp;clientlen);</span><br><span class="line">			add<span class="constructor">_client(<span class="params">connfd</span>, &amp;<span class="params">pool</span>)</span>;   <span class="comment">//创建一个新的状态机 </span></span><br><span class="line">		&#125;</span><br><span class="line">		check<span class="constructor">_clients(&amp;<span class="params">pool</span>)</span>;  <span class="comment">//回送输入行，从而执行状态转移，并且当客户端完成文本行发送时，要删除这个状态机 </span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="add-client-函数"><a href="#add-client-函数" class="headerlink" title="add_client 函数"></a>add_client 函数</h2><p>&emsp;&emsp;add_client函数添加一个新客户端到活动客户端池中，在clientfd数组中找到空位后服务器将这个已连接描述符添加到数组中，并初始rio读缓冲区，这样就能使用这个描述符调用rio_readlineb函数，然后将已连接描述符放入select读集合，并更新池中的一些全局属性。</p>
<figure class="highlight xl"><table><tr><td class="code"><pre><span class="line">void add_client(int connfd, pool *p)</span><br><span class="line">&#123;</span><br><span class="line">	int i;</span><br><span class="line">	<span class="function"><span class="title">p</span>-&gt;</span>nready--;          <span class="comment">//就绪的描述符数减一void add_client(int connfd, pool *p)</span></span><br><span class="line">&#123;</span><br><span class="line">	int i;</span><br><span class="line">	<span class="function"><span class="title">p</span>-&gt;</span>nready--;          <span class="comment">//就绪的描述符数减一 </span></span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;FD_SETSIZE; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="function"><span class="title">if</span>(p-&gt;</span>clientfd[i] &lt; <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="function"><span class="title">p</span>-&gt;</span>clientfd[i]=connfd;         <span class="comment">//找到一个空位 </span></span><br><span class="line">			<span class="function"><span class="title">rio_readinitb</span>(&amp;p-&gt;</span>clientrio[i], connfd); </span><br><span class="line">			<span class="comment">//把此描述符加入描述符列表</span></span><br><span class="line">			FD_SET(<span class="function"><span class="title">connfd</span>, &amp;p-&gt;</span>read_set);</span><br><span class="line">			<span class="comment">//更新最大的描述符 和 新加入到pool中的描述符索引</span></span><br><span class="line">			<span class="function"><span class="title">if</span>(connfd &gt; p-&gt;</span>maxfd)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="function"><span class="title">p</span>-&gt;</span>maxfd=connfd;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="function"><span class="title">if</span>(i &gt; p-&gt;</span>maxi)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="function"><span class="title">p</span>-&gt;</span>maxi=i;</span><br><span class="line">			&#125;</span><br><span class="line">			break;          <span class="comment">//更新完退出 </span></span><br><span class="line">		&#125;	</span><br><span class="line">	&#125;	</span><br><span class="line">	<span class="keyword">if</span>(i == FD_SETSIZE)</span><br><span class="line">	&#123;</span><br><span class="line">		fprintf(stderr, <span class="string">"add_client error: Too many clients\n"</span>);	</span><br><span class="line">	&#125; </span><br><span class="line">&#125; </span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;FD_SETSIZE; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="function"><span class="title">if</span>(p-&gt;</span>clientfd[i] &lt; <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="function"><span class="title">p</span>-&gt;</span>clientfd[i]=connfd;         <span class="comment">//找到一个空位 </span></span><br><span class="line">			<span class="function"><span class="title">rio_readinitb</span>(&amp;p-&gt;</span>clientrio[i], connfd); </span><br><span class="line">			<span class="comment">//把此描述符加入描述符列表</span></span><br><span class="line">			FD_SET(<span class="function"><span class="title">connfd</span>, &amp;p-&gt;</span>read_set);</span><br><span class="line">			<span class="comment">//更新最大的描述符 和 新加入到pool中的描述符索引</span></span><br><span class="line">			<span class="function"><span class="title">if</span>(connfd &gt; p-&gt;</span>maxfd)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="function"><span class="title">p</span>-&gt;</span>maxfd=connfd;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="function"><span class="title">if</span>(i &gt; p-&gt;</span>maxi)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="function"><span class="title">p</span>-&gt;</span>maxi=i;</span><br><span class="line">			&#125;</span><br><span class="line">			break;          <span class="comment">//更新完退出 </span></span><br><span class="line">		&#125;	</span><br><span class="line">	&#125;	</span><br><span class="line">	<span class="keyword">if</span>(i == FD_SETSIZE)</span><br><span class="line">	&#123;</span><br><span class="line">		fprintf(stderr, <span class="string">"add_client error: Too many clients\n"</span>);	</span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="check-clients-函数"><a href="#check-clients-函数" class="headerlink" title="check_clients 函数"></a>check_clients 函数</h2><p>&emsp;&emsp;回送来自每个准备好的已连接描述符的一个文本行，如果读到了EOF，则关闭该描述符。</p>
<figure class="highlight xl"><table><tr><td class="code"><pre><span class="line">void check_clients(pool *p)        <span class="comment">//服务准备好的客户端连接 (开始操作)</span></span><br><span class="line">&#123;</span><br><span class="line">	int i,connfd,n;</span><br><span class="line">	char buf[MAXNLINE];</span><br><span class="line">	rio_t rio;</span><br><span class="line">	<span class="function"><span class="title">for</span>(i=0; (i&lt;=p-&gt;</span><span class="function"><span class="title">maxi</span>) &amp;&amp; (p-&gt;</span>nready&gt;<span class="number">0</span>); i++)  <span class="comment">//在存值的范围内查找 </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="function"><span class="title">connfd</span> = p-&gt;</span>clientfd[i];</span><br><span class="line">		<span class="function"><span class="title">rio</span> = p-&gt;</span>clientrio[i];</span><br><span class="line">		<span class="function"><span class="title">if</span>(connfd &gt; 0 &amp;&amp; (FD_ISSET(connfd, &amp;p-&gt;</span>ready_set)))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="function"><span class="title">p</span>-&gt;</span>nready--;      <span class="comment">//开始服务</span></span><br><span class="line">			<span class="keyword">if</span>((n=rio_readlineb(&amp;rio, buf, MAXNLINE)) &gt; <span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				byte_cnt += n;  <span class="comment">//读到了n个字符</span></span><br><span class="line">				printf(<span class="string">"Server received %d (%d total) bytes on fd %d\n"</span>, n, byte_cnt, connfd);</span><br><span class="line">				rio_writen(connfd, buf, n); </span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// EOF时从池中删除描述符</span></span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				close(connfd);   <span class="comment">//关闭连接端 </span></span><br><span class="line">				FD_CLR(<span class="function"><span class="title">connfd</span>, &amp;p-&gt;</span>read_set);   <span class="comment">//清除描述符 </span></span><br><span class="line">				<span class="function"><span class="title">p</span>-&gt;</span>clientfd[i] = -<span class="number">1</span>;</span><br><span class="line">			 &#125; </span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h2 id="I-O多路复用优劣"><a href="#I-O多路复用优劣" class="headerlink" title="I/O多路复用优劣"></a>I/O多路复用优劣</h2><p>优点：<br>&emsp;&emsp;比基于进程的设计给了程序员更多的对程序行为的控制。<br>&emsp;&emsp;基于I/O多路复用的事件驱动服务器运行在单一进程上下文中，因此每个逻辑流都能访问进程的全部地址空间，使得共享数据变得容易。<br>缺点：<br>&emsp;&emsp;编码复杂。。。</p>
]]></content>
      <categories>
        <category>csapp</category>
      </categories>
      <tags>
        <tag>Linux C/C++</tag>
        <tag>网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title>Tiny Web</title>
    <url>/2019/11/04/Tiny%20Web/</url>
    <content><![CDATA[<p>简介： Tiny Web 项目 </p>
<a id="more"></a>


<h1 id="客户端-服务器编程模型"><a href="#客户端-服务器编程模型" class="headerlink" title="客户端-服务器编程模型"></a>客户端-服务器编程模型</h1><p>&emsp;&emsp;客户端-服务器编程模型是一个典型的进程间通信模型。客户端进程和服务器进程通常分处两个不同的主机，如下图所示，客户端发送请求给服务器，服务器从本地资源库中查找需要的资源，然后发送响应给客户端，最后客户端（通常是浏览器）处理这个响应，把结果显示在浏览器上。<br><img src="https://s2.ax1x.com/2019/11/18/M65Qk4.png" alt=""></p>
<p>&emsp;&emsp;这个过程看起来很简单，但是我们需要深入具体的实现细节。我们知道，TCP是基于连接的，需要先建立连接才能互相通信。在Linux中，socket为我们提供了方便的解决方案。每一对网络连接称为一个socket对，包括两个端点的socket地址，表示如下：<strong>(cliaddr : cliport, servaddr : servport)</strong></p>
<h1 id="C-S流程图"><a href="#C-S流程图" class="headerlink" title="C/S流程图"></a>C/S流程图</h1><p><img src="https://s2.ax1x.com/2019/11/18/M65a7D.png" alt=""><br>&emsp;&emsp;服务器调用socket函数获取一个socket，然后调用bind函数绑定本机的IP地址和端口，再调用listen函数开启监听，最后调用accept函数等待直到有客户端发起连接。</p>
<p>&emsp;&emsp;另一方面，客户端调用socket函数获取一个socket，然后调用connect函数向指定服务器发起连接请求，当连接成功或出现错误后返回。若连接成功，服务器端的accept函数也会成功返回，返回另一个已连接的socket（不是最初调用socket函数得到的socket），该socket可以直接用于与客户端通信。而服务器最初的那个socket可以继续循环调用accept函数，等待下一次连接的到来。</p>
<p>&emsp;&emsp;连接成功后，无论是客户端还是服务器，只要向socket读写数据就可以实现与对方socket的通信。图中rio_readlineb和rio_written是作者封装的I/O读写函数，与Linux系统提供的read和write作用基本相同。</p>
<p>&emsp;&emsp;客户端关闭连接时会发送一个EOF到服务器，服务器读取后关闭连接，进入下一个循环。这里面用到的所有Linux网络编程接口都定义在&lt;sys/socket.h&gt;头文件中。</p>
<h1 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h1><h2 id="HTTP-请求"><a href="#HTTP-请求" class="headerlink" title="HTTP 请求"></a>HTTP 请求</h2><p>&emsp;&emsp;一个HTTP请求：一个请求行(request line) 后面跟随0个或多个请求报头(request header), 再跟随一个空的文本行来终止报头。</p>
<p>&emsp;&emsp;请求行： <code>&lt;method&gt; &lt;uri&gt; &lt;version&gt;</code></p>
<p>&emsp;&emsp;请求报头：<code>&lt;header name&gt; : &lt;header data&gt;</code> 为服务器提供了额外的信息，例如浏览器的版本类型</p>
<h2 id="HTTP响应"><a href="#HTTP响应" class="headerlink" title="HTTP响应"></a>HTTP响应</h2><p>&emsp;&emsp;一个HTTP响应：一个响应行(response line) 后面跟随0个或多个响应报头(response header)，再跟随一个空的文本行来终止报头，最后跟随一个响应主体(response body)。</p>
<h1 id="服务动态内容"><a href="#服务动态内容" class="headerlink" title="服务动态内容"></a>服务动态内容</h1><h2 id="客户端如何将程序参数传递给服务器"><a href="#客户端如何将程序参数传递给服务器" class="headerlink" title="客户端如何将程序参数传递给服务器"></a>客户端如何将程序参数传递给服务器</h2><p>&emsp;&emsp;GET请求的参数在URI中传递，“?”字符分隔了文件名和参数，每个参数都用一个”&amp;”分隔开，参数中不允许有空格，必须用字符串“%20”来表示。</p>
<h2 id="服务器如何将参数传递给子进程"><a href="#服务器如何将参数传递给子进程" class="headerlink" title="服务器如何将参数传递给子进程"></a>服务器如何将参数传递给子进程</h2><pre><code>GET /cgi-bin/adder?123&amp;456 HTTP/1.1</code></pre><p>&emsp;&emsp;它调用 fork 来创建一个子进程，并调用 execve 在子进程的上下文中执行 /cgi-bin/adder 程序。</p>
<p>&emsp;&emsp;在调用 execve 之前，子进程将CGI环境变量 QUERY_STRING 设置为”123&amp;456”， adder 程序在运行时可以用unix getenv 函数来引用它。</p>
<h2 id="服务器如何将其他信息传递给子进程"><a href="#服务器如何将其他信息传递给子进程" class="headerlink" title="服务器如何将其他信息传递给子进程"></a>服务器如何将其他信息传递给子进程</h2><p><img src="https://s2.ax1x.com/2019/11/18/M6IEUe.png" alt=""></p>
<h2 id="子进程将它的输出发送到哪里"><a href="#子进程将它的输出发送到哪里" class="headerlink" title="子进程将它的输出发送到哪里"></a>子进程将它的输出发送到哪里</h2><p>&emsp;&emsp;一个CGI程序将它的动态内容发送到标准输出，在子进程加载并运行CGI程序之前，它使用UNIX dup2 函数将它标准输出重定向到和客户端相关连的已连接描述符。因此，任何CGI程序写到标准输出的东西都会直接到达客户端。</p>
<h1 id="Tiny-Web服务器代码分析"><a href="#Tiny-Web服务器代码分析" class="headerlink" title="Tiny Web服务器代码分析"></a>Tiny Web服务器代码分析</h1><h2 id="main函数-amp-open-listenfd函数"><a href="#main函数-amp-open-listenfd函数" class="headerlink" title="main函数 &amp; open_listenfd函数"></a>main函数 &amp; open_listenfd函数</h2><p>&emsp;&emsp;Tiny是一个迭代服务器，监听在命令行中传递来的端口上的连接请求，在通过调用 open_listenfd 函数打开一个监听套接字以后，执行无限服务器循环，不断接受连接请求，执行事务，并关闭连接它的那一端。</p>
<figure class="highlight perl"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> open_listenfd(char *port)</span><br><span class="line">&#123;</span><br><span class="line">    struct addrinfo hints,*p,*listp;</span><br><span class="line">    <span class="keyword">int</span> listenfd, optval=<span class="number">1</span>,rc;</span><br><span class="line">    memset(&amp;hints, <span class="number">0</span>, sizeof(struct addrinfo));</span><br><span class="line">    hints.ai_socktype=SOCK_STREAM;</span><br><span class="line">    hints.ai_flags = AI_PASSIVE | AI_ADDRCONFIG;</span><br><span class="line">    hints.ai_flags |= AI_NUMERICSERV;</span><br><span class="line">    //<span class="keyword">socket</span>----&gt;<span class="keyword">bind</span>----&gt;<span class="keyword">listen</span></span><br><span class="line">    getaddrinfo(NULL, port, &amp;hints, &amp;listp);</span><br><span class="line">   // <span class="keyword">if</span>(listp == NULL) </span><br><span class="line">    <span class="keyword">for</span>(p=listp; p; p=p-&gt;ai_next)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>((listenfd=<span class="keyword">socket</span>(p-&gt;ai_family, p-&gt;ai_socktype, p-&gt;ai_protocol)) &lt; <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">       <span class="keyword">if</span>((rc= <span class="keyword">setsockopt</span>(listenfd, SOL_SOCKET, SO_REUSEADDR, &amp; optval, sizeof(<span class="keyword">int</span>))) &lt; <span class="number">0</span>) <span class="keyword">printf</span>(<span class="string">"%s\n"</span>, strerror(errno));</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">bind</span>(listenfd, p-&gt;ai_addr, p-&gt;ai_addrlen) == <span class="number">0</span>)     //<span class="keyword">printf</span>(<span class="string">"%s\n"</span>, strerror(errno)); <span class="regexp">//break</span>;</span><br><span class="line">        		<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">close</span>(listenfd);</span><br><span class="line">    &#125;</span><br><span class="line">    freeaddrinfo(listp);</span><br><span class="line">    <span class="keyword">if</span>(!p)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">listen</span>(listenfd, LISTENQ) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">close</span>(listenfd);</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> listenfd;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> listenfd,connfd;</span><br><span class="line">    socklen_t clientlen;</span><br><span class="line">    char hostname[MAXNLINE], port[MAXNLINE];</span><br><span class="line">    struct sockaddr_storage clientaddr;</span><br><span class="line">    <span class="keyword">if</span>(argc&lt;<span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        fprintf(stderr, <span class="string">"usage: %s &lt;port&gt;\n"</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    listenfd=open_listenfd(argv[<span class="number">1</span>]);</span><br><span class="line">    //<span class="keyword">printf</span>(<span class="string">"%d"</span>, listenfd);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        clientlen = sizeof(clientaddr); </span><br><span class="line">        connfd = <span class="keyword">accept</span>(listenfd, (struct sockaddr *)&amp;clientaddr, &amp;clientlen);    <span class="regexp">//</span>等待客户端连接请求 </span><br><span class="line">        getnameinfo((struct sockaddr*)&amp; clientaddr, clientlen, hostname, MAXNLINE, port, MAXNLINE, <span class="number">0</span>);</span><br><span class="line">       // <span class="keyword">printf</span>(<span class="string">"\n%d\n"</span>, connfd);</span><br><span class="line">        <span class="keyword">printf</span>(<span class="string">"Accept connection from (%s %s)\n"</span>, hostname, port);</span><br><span class="line">      //  <span class="keyword">if</span>(connfd==<span class="number">152</span> || connfd ==<span class="number">153</span> || connfd==<span class="number">151</span> || connfd==<span class="number">154</span> || connfd==<span class="number">147</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        doit(connfd);</span><br><span class="line">        <span class="keyword">close</span>(connfd);</span><br><span class="line">        //<span class="keyword">if</span>( <span class="keyword">close</span>(connfd) &lt; <span class="number">0</span>) <span class="keyword">printf</span>(<span class="string">"%s"</span>, strerror(errno));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="doit函数"><a href="#doit函数" class="headerlink" title="doit函数"></a>doit函数</h2><p>&emsp;&emsp;doit函数处理一个HTTP事务，首先读和解析请求行(request line)，注意，我们使用rio_readlineb函数读取请求行。<br>Tiny只支持GET方法，如果客户端请求其他方法，发送一个错误信息。<br>然后将URI解析为一个文件名和一个可能为空的CGI参数字符串，并且设置一个标志表明请求的是静态内容还是动态内容,如果请求的是静态内容，就验证是否为普通文件，有读权限如果请求的是动态内容，就验证是否为可执行文件，如果是，就提供动态内容。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">void doit(<span class="built_in">int</span> fd)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> is_static;</span><br><span class="line">    <span class="keyword">struct</span> stat sbuf;</span><br><span class="line">    <span class="built_in">char</span> buf<span class="literal">[MAXNLINE]</span>, filename<span class="literal">[MAXNLINE]</span>, uri<span class="literal">[MAXNLINE]</span>, verson<span class="literal">[MAXNLINE]</span>;</span><br><span class="line">    <span class="built_in">char</span> <span class="keyword">method</span><span class="literal">[MAXNLINE]</span>, cgiargs<span class="literal">[MAXNLINE]</span>;   </span><br><span class="line">    rio_t rio;</span><br><span class="line"></span><br><span class="line">    rio<span class="constructor">_readinitb(&amp;<span class="params">rio</span>, <span class="params">fd</span>)</span>;        <span class="comment">//fd是与服务器通信的套接字 </span></span><br><span class="line">    rio<span class="constructor">_readlineb(&amp;<span class="params">rio</span>, <span class="params">buf</span>, MAXNLINE)</span>;</span><br><span class="line">    printf(<span class="string">"Request headers:\n"</span>);</span><br><span class="line">    printf(<span class="string">"%s"</span>, buf);</span><br><span class="line">    sscanf(buf, <span class="string">"%s %s %s"</span>, <span class="keyword">method</span>, uri, verson);</span><br><span class="line">    <span class="keyword">if</span>(strcasecmp(<span class="keyword">method</span>, <span class="string">"GET"</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        clienterror(fd, <span class="keyword">method</span>, <span class="string">"501"</span>, <span class="string">"Not implemented"</span>, <span class="string">"Tiny does not implement this method"</span>);</span><br><span class="line">        return ;</span><br><span class="line">    &#125;</span><br><span class="line">    read<span class="constructor">_requesthds(&amp;<span class="params">rio</span>)</span>;       <span class="comment">//读请求头 </span></span><br><span class="line">    is_static = prase<span class="constructor">_uri(<span class="params">uri</span>, <span class="params">filename</span>, <span class="params">cgiargs</span>)</span>;</span><br><span class="line">    <span class="keyword">if</span>(stat(filename, &amp;sbuf) &lt; <span class="number">0</span>)   <span class="comment">//通过文件名获取文件信息 </span></span><br><span class="line">    &#123;</span><br><span class="line">       clienterror(fd, filename, <span class="string">"404"</span>, <span class="string">"Not Found"</span>, <span class="string">"Tiny couldn't find this file"</span>);  <span class="comment">//返回错误信息 </span></span><br><span class="line">        return ; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(is_static==<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!(<span class="constructor">S_ISREG(<span class="params">sbuf</span>.<span class="params">st_mode</span>)</span>) <span class="pattern-match"><span class="operator">||</span>!(sbuf.st<span class="constructor">_mode</span> &amp; <span class="constructor">S_IRUSR</span>))</span></span><br><span class="line"><span class="pattern-match">        &#123;</span></span><br><span class="line"><span class="pattern-match">            clienterror(fd, filename, "403", "<span class="constructor">Not</span> <span class="constructor">Found</span>", "<span class="constructor">Tiny</span> couldn't read this file");  </span></span><br><span class="line"><span class="pattern-match">            return ;    </span></span><br><span class="line"><span class="pattern-match">        &#125;</span></span><br><span class="line"><span class="pattern-match">        serve<span class="constructor">_static(<span class="params">fd</span>, <span class="params">filename</span>, <span class="params">sbuf</span>.<span class="params">st_size</span>)</span>;</span></span><br><span class="line"><span class="pattern-match">    &#125;</span></span><br><span class="line"><span class="pattern-match">    <span class="keyword">else</span></span></span><br><span class="line"><span class="pattern-match">    &#123;</span></span><br><span class="line"><span class="pattern-match">        <span class="keyword">if</span>(!<span class="constructor">S_ISREG(<span class="params">sbuf</span>.<span class="params">st_mode</span>)</span> <span class="operator">||</span> !(<span class="constructor">S_IRUSR</span> &amp; sbuf.st<span class="constructor">_mode</span>))</span></span><br><span class="line"><span class="pattern-match">        &#123;</span></span><br><span class="line"><span class="pattern-match">            clienterror(fd, filename, "403", "<span class="constructor">Forbidden</span>", "<span class="constructor">Tiny</span> couldn't run the <span class="constructor">CGI</span> program");  </span></span><br><span class="line"><span class="pattern-match">            return ;</span></span><br><span class="line"><span class="pattern-match">        &#125;</span></span><br><span class="line"><span class="pattern-match">        serve<span class="constructor">_dynamic(<span class="params">fd</span>, <span class="params">filename</span>, <span class="params">cgiargs</span>)</span>;</span></span><br><span class="line"><span class="pattern-match">     &#125; </span></span><br><span class="line"><span class="pattern-match">&#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="clienterror函数"><a href="#clienterror函数" class="headerlink" title="clienterror函数"></a>clienterror函数</h2><p>&emsp;&emsp;clienterror函数检查一些明显的错误，并把它报告给客户端。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">void clienterror(<span class="built_in">int</span> fd, <span class="built_in">char</span> *cause, <span class="built_in">char</span> *errnum, <span class="built_in">char</span> *shortmsg, <span class="built_in">char</span> *longmsg)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">char</span> buf<span class="literal">[MAXNLINE]</span>,body<span class="literal">[MAXNLINE]</span>;</span><br><span class="line">    <span class="comment">//build http response body</span></span><br><span class="line">    sprintf(body, <span class="string">"&lt;html&gt;&lt;title&gt;Tiny Error&lt;/title&gt;"</span>);</span><br><span class="line">    sprintf(body, <span class="string">"%s&lt;body bgcolor="</span><span class="string">"ffffff"</span><span class="string">"&gt;\r\n"</span>, body);</span><br><span class="line">    sprintf(body, <span class="string">"%s%s: %s\r\n"</span>, body, errnum, shortmsg);</span><br><span class="line">    sprintf(body, <span class="string">"%s&lt;p&gt;%s: %s\r\n"</span>, body, longmsg, cause);</span><br><span class="line">    sprintf(body, <span class="string">"%s&lt;hr&gt;&lt;em&gt;The Tiny Web server&lt;/em&gt;\r\n"</span>, body);</span><br><span class="line">    <span class="comment">//打印信息 </span></span><br><span class="line">    sprintf(buf, <span class="string">"HTTP/1.0 %s %s\r\n"</span>, errnum, shortmsg);</span><br><span class="line">    rio<span class="constructor">_writen(<span class="params">fd</span>, <span class="params">buf</span>, <span class="params">strlen</span>(<span class="params">buf</span>)</span>);</span><br><span class="line">    sprintf(buf, <span class="string">"Content-type: text/html\r\n"</span>);</span><br><span class="line">    rio<span class="constructor">_writen(<span class="params">fd</span>, <span class="params">buf</span>, <span class="params">strlen</span>(<span class="params">buf</span>)</span>);</span><br><span class="line">    sprintf(buf, <span class="string">"Content-length: %d\r\n\r\n"</span>, (<span class="built_in">int</span>)strlen(body));</span><br><span class="line">    rio<span class="constructor">_writen(<span class="params">fd</span>, <span class="params">buf</span>, <span class="params">strlen</span>(<span class="params">buf</span>)</span>);</span><br><span class="line">    rio<span class="constructor">_writen(<span class="params">fd</span>, <span class="params">body</span>, <span class="params">strlen</span>(<span class="params">body</span>)</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="read-requesthdrs函数"><a href="#read-requesthdrs函数" class="headerlink" title="read_requesthdrs函数"></a>read_requesthdrs函数</h2><p>&emsp;&emsp;Tiny不使用请求报头中的任何信息，仅仅调用 read_requesthdrs函数来读取并忽略这些报头。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">void read<span class="constructor">_requesthds(<span class="params">rio_t</span> <span class="operator">*</span><span class="params">rp</span>)</span>       <span class="comment">//鎶把请求头读出来 </span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">char</span> buf<span class="literal">[MAXNLINE]</span>;</span><br><span class="line">    rio<span class="constructor">_readlineb(<span class="params">rp</span>, <span class="params">buf</span>, MAXNLINE)</span>;</span><br><span class="line">    printf(<span class="string">"%s"</span>, buf);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(strcmp(buf, <span class="string">"\r\n"</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        rio<span class="constructor">_readlineb(<span class="params">rp</span> , <span class="params">buf</span>, MAXNLINE)</span>;</span><br><span class="line">        printf(<span class="string">"%s"</span>, buf);</span><br><span class="line">    &#125;</span><br><span class="line">    return ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="parse-uri函数"><a href="#parse-uri函数" class="headerlink" title="parse_uri函数"></a>parse_uri函数</h2><p>&emsp;&emsp;Tiny假设静态内容的主目录就是当前目录，可执行文件的主目录是 ./cgi-bin/ 任何包含字符串 cgi-bin 的URI都认为是对动态内容的请求。</p>
<p>&emsp;&emsp;首先将URI解析为一个文件名和一个可选的CGI参数字符串，如果请求的是静态内容，就清除CGI参数串(第6行)，然后将URI转换为一个相对的unix 路径名，例如 ./index.html。</p>
<p>&emsp;&emsp;如果URI是用’/‘ 结尾的,我们就把默认的文件名加在后面。如果请求的是动态内容，就会抽取所有的CGI参数，并将URI剩下的部分转换为一个相应的unix文件名</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">prase_uri</span><span class="params">(<span class="keyword">char</span> *uri, <span class="keyword">char</span> *filename, <span class="keyword">char</span> *cgiargs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *ptr;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">strstr</span>(uri, <span class="string">"cgi-bin"</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">strcpy</span>(cgiargs, <span class="string">""</span>);</span><br><span class="line">        <span class="built_in">strcpy</span>(filename, <span class="string">"."</span>);</span><br><span class="line">        <span class="built_in">strcat</span>(filename, uri);</span><br><span class="line">        <span class="keyword">if</span>(uri[<span class="built_in">strlen</span>(uri)<span class="number">-1</span>]==<span class="string">'/'</span>) <span class="built_in">strcat</span>(filename, <span class="string">"home.html"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        ptr = index(uri, <span class="string">'?'</span>);</span><br><span class="line">        <span class="keyword">if</span>(ptr)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">strcpy</span>(cgiargs, ptr+<span class="number">1</span>);</span><br><span class="line">            *ptr=<span class="string">'\0'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">strcpy</span>(cgiargs, <span class="string">""</span>);</span><br><span class="line">        <span class="built_in">strcpy</span>(filename, <span class="string">"."</span>);</span><br><span class="line">        <span class="built_in">strcat</span>(filename, uri);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="serve-static函数"><a href="#serve-static函数" class="headerlink" title="serve_static函数"></a>serve_static函数</h2><p>&emsp;&emsp;Tiny提供四种不同的静态内容：HTML文件、无格式的文本文件、GIF编码格式图片、JPEG编码格式图片。serve_static 函数发送一个HTTP响应，其主体包含一个本地文件的内容。</p>
<p>&emsp;&emsp;首先我们通过检查文件名的后缀来判断文件类型，并且发送响应行和响应报头给客户端。注意用一个空行终止报头，我们使用 unix mmap函数将被请求文件映射到一个虚拟存储器空间，调用mmap将文件srcfd的前filesize个字节映射到一个从地址srcp开始的私有只读虚拟存储器区域。</p>
<p>&emsp;&emsp;一旦文件映射到存储器，就不再需要它的描述符了，关闭这个文件。rio_writen 函数拷贝从srcp位置开始的filesize个字节(已经被映射到了所请求的文件) 到客户端的已连接描述符。最后释放了映射的虚拟存储器区域，避免潜在的内存泄露。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getfiletype</span><span class="params">(<span class="keyword">char</span> *filename, <span class="keyword">char</span> *filetype)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strstr</span>(filename, <span class="string">".html"</span>))   <span class="built_in">strcpy</span>(filetype, <span class="string">"text/html"</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">strstr</span>(filename, <span class="string">".gif"</span>))   <span class="built_in">strcpy</span>(filetype, <span class="string">"image/gif"</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">strstr</span>(filename, <span class="string">".png"</span>))   <span class="built_in">strcpy</span>(filetype, <span class="string">"image/png"</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">strstr</span>(filename, <span class="string">".jpg"</span>))   <span class="built_in">strcpy</span>(filetype, <span class="string">"image/jpeg"</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">strcpy</span>(filetype, <span class="string">"text/plain"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">serve_static</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">char</span> *filename, <span class="keyword">int</span> filesize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> srcfd;</span><br><span class="line">    <span class="keyword">char</span> *srcp, filetype[MAXNLINE], buf[MAXNLINE];</span><br><span class="line">    <span class="comment">//  发送响应报头给客户端 </span></span><br><span class="line">    getfiletype(filename, filetype);      <span class="comment">//返回静态内容类型 </span></span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">"HTTP/1.0 200 OK\r\n"</span>);</span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">"%sServer: Tiny Web Server\r\n"</span>, buf);</span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">"%sConnection: close\r\n"</span>, buf);</span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">"%sContent-length %d\r\n"</span>, buf, filesize);</span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">"%sContent-type: %s\r\n\r\n"</span>, buf, filetype);</span><br><span class="line">    rio_writen(fd, buf, <span class="built_in">strlen</span>(buf));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Response headers:\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s"</span>, buf);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//  发送响应体给客户端 </span></span><br><span class="line">    srcfd = open(filename, O_RDONLY, <span class="number">0</span>); </span><br><span class="line">    srcp = mmap(<span class="number">0</span>, filesize, PROT_READ, MAP_PRIVATE, srcfd, <span class="number">0</span>);</span><br><span class="line">    close(srcfd);</span><br><span class="line">    rio_writen(fd, srcp, filesize);</span><br><span class="line">    munmap(srcp, filesize);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="serve-dynamic-函数"><a href="#serve-dynamic-函数" class="headerlink" title="serve_dynamic 函数"></a>serve_dynamic 函数</h2><p>&emsp;&emsp;Tiny通过派生一个子进程并在子进程的上下文中运行一个CGI程序，来提供各种类型的动态内容。</p>
<p>&emsp;&emsp;serve_dynamic函数一开始就向客户端发送一个表明成功的响应行，同时还包括带有信息的server报头。</p>
<p>&emsp;&emsp;子进程用来自请求URI的CGI参数初始化QUERY_STRING环境变量</p>
<p>&emsp;&emsp;子进程重定向它的标准输出到已连接文件描述符</p>
<p>&emsp;&emsp;加载并运行CGI程序，因为CGI程序运行在子进程的上下文中，它能够访问所有在调用execve函数之前就存在的打开文件和环境变量</p>
<p>&emsp;&emsp;父进程阻塞在对wait的调用中，等待子进程终止的时候，回收操作系统那个分配给子进程的资源</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">void serve<span class="constructor">_dynamic(<span class="params">int</span> <span class="params">fd</span>, <span class="params">char</span> <span class="operator">*</span><span class="params">filename</span>, <span class="params">char</span> <span class="operator">*</span><span class="params">cgiargs</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">char</span> buf<span class="literal">[MAXNLINE]</span>, *emptylist<span class="literal">[]</span>=&#123;NULL&#125;;</span><br><span class="line">    pid_t pid;</span><br><span class="line">    printf(<span class="string">"-----------%s-------------"</span>, cgiargs);</span><br><span class="line">    sprintf(buf, <span class="string">"HTTP/1.0 200 OK\r\n"</span>);</span><br><span class="line">    rio<span class="constructor">_writen(<span class="params">fd</span>, <span class="params">buf</span>, <span class="params">strlen</span>(<span class="params">buf</span>)</span>);</span><br><span class="line">    sprintf(buf, <span class="string">"Server: Tiny Web Server\r\n"</span>);</span><br><span class="line">    rio<span class="constructor">_writen(<span class="params">fd</span>, <span class="params">buf</span>, <span class="params">strlen</span>(<span class="params">buf</span>)</span>);</span><br><span class="line">    pid=fork<span class="literal">()</span>;</span><br><span class="line">    <span class="keyword">if</span>(pid==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        setenv(<span class="string">"QUERY_STRING"</span>, cgiargs, <span class="number">1</span>);   <span class="comment">//改变或者增加环境变量内容，为1则改 </span></span><br><span class="line">        dup2(fd, STDOUT_FILENO);</span><br><span class="line">       <span class="comment">/*</span></span><br><span class="line"><span class="comment">        *         来执行参数filename字符串所代表的文件路径，第二个参数是利</span></span><br><span class="line"><span class="comment">		    用数组指针来传递给执行文件，并且需要以空指针(NULL)结束，最后一个参数则为传递给执行文件</span></span><br><span class="line"><span class="comment">			    的新环境变量数组。execve()用来执行参数filename字符串所代表的文件路径，第二个参数是利用数组指针来传递给执</span></span><br><span class="line"><span class="comment">			  行文件，并且需要以空指针(NULL)结束，最后一个参数则为传递给执行文件的新环境变量数组</span></span><br><span class="line"><span class="comment">			  */</span> </span><br><span class="line">        execve(filename, emptylist, environ);</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="keyword">else</span>  wait(NULL);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="rio函数"><a href="#rio函数" class="headerlink" title="rio函数"></a>rio函数</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXNLINE 1024*8</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LISTENQ 1024</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">char</span> **environ;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> rio_fd,rio_cnt;</span><br><span class="line">    <span class="keyword">char</span> rio_buf[MAXNLINE],*rio_bufptr;</span><br><span class="line">&#125; <span class="keyword">rio_t</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">ssize_t</span> rio_writen(<span class="keyword">int</span> fd, <span class="keyword">void</span> *usrbuf, <span class="keyword">size_t</span> n)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">size_t</span> nleft=n;</span><br><span class="line">    <span class="keyword">ssize_t</span> nwritten;</span><br><span class="line">    <span class="keyword">char</span> *bufp=usrbuf;</span><br><span class="line">    <span class="keyword">while</span>(nleft&gt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>((nwritten = write(fd, bufp, nleft)) &lt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(errno == EINTR)</span><br><span class="line">            &#123;</span><br><span class="line">                nwritten=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        nleft-=nwritten;</span><br><span class="line">        bufp+=nwritten;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rio_readinitb</span><span class="params">(<span class="keyword">rio_t</span> *rio, <span class="keyword">int</span> fd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    rio-&gt;rio_fd=fd;</span><br><span class="line">    rio-&gt;rio_cnt=<span class="number">0</span>;</span><br><span class="line">    rio-&gt;rio_bufptr=rio-&gt;rio_buf;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> ssize_t <span class="title">rio_read</span><span class="params">(<span class="keyword">rio_t</span> *rp, <span class="keyword">char</span> *rc, <span class="keyword">size_t</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt;</span><br><span class="line">    <span class="keyword">while</span>(rp-&gt;rio_cnt&lt;=<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        rp-&gt;rio_cnt=read(rp-&gt;rio_fd, rp-&gt;rio_buf, <span class="keyword">sizeof</span>(rp-&gt;rio_buf));</span><br><span class="line">        <span class="keyword">if</span>(rp-&gt;rio_cnt&lt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(errno != EINTR)  <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">//此时为不中断 </span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(rp-&gt;rio_cnt==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> rp-&gt;rio_bufptr=rp-&gt;rio_buf;</span><br><span class="line">    &#125;</span><br><span class="line">    cnt=n;</span><br><span class="line">    <span class="keyword">if</span>(rp-&gt;rio_cnt &lt; n) cnt=rp-&gt;rio_cnt;</span><br><span class="line">    <span class="built_in">memcpy</span>(rc, rp-&gt;rio_bufptr, cnt);</span><br><span class="line">    rp-&gt;rio_bufptr+=cnt;</span><br><span class="line">    rp-&gt;rio_cnt-=cnt;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">ssize_t</span> rio_readlineb(<span class="keyword">rio_t</span> *rp, <span class="keyword">void</span> *usrbuf, <span class="keyword">size_t</span> maxnlen)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">char</span> *buf=usrbuf,c;</span><br><span class="line">    <span class="keyword">int</span> n,rc;</span><br><span class="line">    <span class="keyword">for</span>(n=<span class="number">1</span>; n&lt;maxnlen; ++n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>((rc=rio_read(rp, &amp;c, <span class="number">1</span>))==<span class="number">1</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            *buf++ = c;</span><br><span class="line">            <span class="keyword">if</span>(c == <span class="string">'\n'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                n++;</span><br><span class="line">                <span class="keyword">break</span>;  </span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(rc == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(n==<span class="number">1</span>)    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;   </span><br><span class="line">    *buf=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> n<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>csapp</category>
      </categories>
      <tags>
        <tag>Linux C/C++</tag>
        <tag>网络编程</tag>
      </tags>
  </entry>
</search>
